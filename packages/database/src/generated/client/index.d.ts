
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model OrganizationMember
 * 
 */
export type OrganizationMember = $Result.DefaultSelection<Prisma.$OrganizationMemberPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Listing
 * 
 */
export type Listing = $Result.DefaultSelection<Prisma.$ListingPayload>
/**
 * Model CancellationPolicy
 * 
 */
export type CancellationPolicy = $Result.DefaultSelection<Prisma.$CancellationPolicyPayload>
/**
 * Model Availability
 * 
 */
export type Availability = $Result.DefaultSelection<Prisma.$AvailabilityPayload>
/**
 * Model FavoriteListing
 * 
 */
export type FavoriteListing = $Result.DefaultSelection<Prisma.$FavoriteListingPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model BookingStateHistory
 * 
 */
export type BookingStateHistory = $Result.DefaultSelection<Prisma.$BookingStateHistoryPayload>
/**
 * Model LedgerEntry
 * 
 */
export type LedgerEntry = $Result.DefaultSelection<Prisma.$LedgerEntryPayload>
/**
 * Model DepositHold
 * 
 */
export type DepositHold = $Result.DefaultSelection<Prisma.$DepositHoldPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Refund
 * 
 */
export type Refund = $Result.DefaultSelection<Prisma.$RefundPayload>
/**
 * Model Payout
 * 
 */
export type Payout = $Result.DefaultSelection<Prisma.$PayoutPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageReadReceipt
 * 
 */
export type MessageReadReceipt = $Result.DefaultSelection<Prisma.$MessageReadReceiptPayload>
/**
 * Model ConditionReport
 * 
 */
export type ConditionReport = $Result.DefaultSelection<Prisma.$ConditionReportPayload>
/**
 * Model ReportPhoto
 * 
 */
export type ReportPhoto = $Result.DefaultSelection<Prisma.$ReportPhotoPayload>
/**
 * Model Dispute
 * 
 */
export type Dispute = $Result.DefaultSelection<Prisma.$DisputePayload>
/**
 * Model DisputeResponse
 * 
 */
export type DisputeResponse = $Result.DefaultSelection<Prisma.$DisputeResponsePayload>
/**
 * Model DisputeEvidence
 * 
 */
export type DisputeEvidence = $Result.DefaultSelection<Prisma.$DisputeEvidencePayload>
/**
 * Model DisputeTimelineEvent
 * 
 */
export type DisputeTimelineEvent = $Result.DefaultSelection<Prisma.$DisputeTimelineEventPayload>
/**
 * Model DisputeResolution
 * 
 */
export type DisputeResolution = $Result.DefaultSelection<Prisma.$DisputeResolutionPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model InsurancePolicy
 * 
 */
export type InsurancePolicy = $Result.DefaultSelection<Prisma.$InsurancePolicyPayload>
/**
 * Model DeviceToken
 * 
 */
export type DeviceToken = $Result.DefaultSelection<Prisma.$DeviceTokenPayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  SUPPORT: 'SUPPORT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  BANNED: 'BANNED',
  DELETED: 'DELETED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const VerificationStatus: {
  PENDING: 'PENDING',
  IN_REVIEW: 'IN_REVIEW',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type VerificationStatus = (typeof VerificationStatus)[keyof typeof VerificationStatus]


export const GovernmentIdType: {
  PASSPORT: 'PASSPORT',
  DRIVERS_LICENSE: 'DRIVERS_LICENSE',
  NATIONAL_ID: 'NATIONAL_ID',
  OTHER: 'OTHER'
};

export type GovernmentIdType = (typeof GovernmentIdType)[keyof typeof GovernmentIdType]


export const OrganizationStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  DELETED: 'DELETED'
};

export type OrganizationStatus = (typeof OrganizationStatus)[keyof typeof OrganizationStatus]


export const OrgRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type OrgRole = (typeof OrgRole)[keyof typeof OrgRole]


export const BookingMode: {
  INSTANT_BOOK: 'INSTANT_BOOK',
  REQUEST_TO_BOOK: 'REQUEST_TO_BOOK'
};

export type BookingMode = (typeof BookingMode)[keyof typeof BookingMode]


export const PricingMode: {
  PER_HOUR: 'PER_HOUR',
  PER_DAY: 'PER_DAY',
  PER_WEEK: 'PER_WEEK',
  PER_MONTH: 'PER_MONTH',
  CUSTOM: 'CUSTOM'
};

export type PricingMode = (typeof PricingMode)[keyof typeof PricingMode]


export const ListingStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  ARCHIVED: 'ARCHIVED',
  REJECTED: 'REJECTED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const ListingCondition: {
  NEW: 'NEW',
  EXCELLENT: 'EXCELLENT',
  GOOD: 'GOOD',
  FAIR: 'FAIR',
  POOR: 'POOR'
};

export type ListingCondition = (typeof ListingCondition)[keyof typeof ListingCondition]


export const DepositType: {
  FIXED_AMOUNT: 'FIXED_AMOUNT',
  PERCENTAGE: 'PERCENTAGE'
};

export type DepositType = (typeof DepositType)[keyof typeof DepositType]


export const CancellationPolicyType: {
  FLEXIBLE: 'FLEXIBLE',
  MODERATE: 'MODERATE',
  STRICT: 'STRICT',
  NON_REFUNDABLE: 'NON_REFUNDABLE'
};

export type CancellationPolicyType = (typeof CancellationPolicyType)[keyof typeof CancellationPolicyType]


export const BookingStatus: {
  DRAFT: 'DRAFT',
  PENDING_OWNER_APPROVAL: 'PENDING_OWNER_APPROVAL',
  PENDING_PAYMENT: 'PENDING_PAYMENT',
  CONFIRMED: 'CONFIRMED',
  ACTIVE: 'ACTIVE',
  IN_PROGRESS: 'IN_PROGRESS',
  AWAITING_RETURN_INSPECTION: 'AWAITING_RETURN_INSPECTION',
  COMPLETED: 'COMPLETED',
  SETTLED: 'SETTLED',
  CANCELLED: 'CANCELLED',
  DISPUTED: 'DISPUTED',
  REFUNDED: 'REFUNDED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const LedgerSide: {
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT'
};

export type LedgerSide = (typeof LedgerSide)[keyof typeof LedgerSide]


export const LedgerEntryStatus: {
  PENDING: 'PENDING',
  SETTLED: 'SETTLED',
  FAILED: 'FAILED',
  REVERSED: 'REVERSED'
};

export type LedgerEntryStatus = (typeof LedgerEntryStatus)[keyof typeof LedgerEntryStatus]


export const DepositStatus: {
  AUTHORIZED: 'AUTHORIZED',
  CAPTURED: 'CAPTURED',
  RELEASED: 'RELEASED',
  EXPIRED: 'EXPIRED',
  FAILED: 'FAILED'
};

export type DepositStatus = (typeof DepositStatus)[keyof typeof DepositStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const RefundStatus: {
  PENDING: 'PENDING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type RefundStatus = (typeof RefundStatus)[keyof typeof RefundStatus]


export const PayoutStatus: {
  PENDING: 'PENDING',
  IN_TRANSIT: 'IN_TRANSIT',
  PAID: 'PAID',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type PayoutStatus = (typeof PayoutStatus)[keyof typeof PayoutStatus]


export const ReviewType: {
  LISTING_REVIEW: 'LISTING_REVIEW',
  RENTER_REVIEW: 'RENTER_REVIEW',
  OWNER_REVIEW: 'OWNER_REVIEW'
};

export type ReviewType = (typeof ReviewType)[keyof typeof ReviewType]


export const ReviewStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  HIDDEN: 'HIDDEN',
  DELETED: 'DELETED'
};

export type ReviewStatus = (typeof ReviewStatus)[keyof typeof ReviewStatus]


export const ConversationType: {
  BOOKING: 'BOOKING',
  INQUIRY: 'INQUIRY',
  SUPPORT: 'SUPPORT',
  GENERAL: 'GENERAL'
};

export type ConversationType = (typeof ConversationType)[keyof typeof ConversationType]


export const ConversationStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  DELETED: 'DELETED'
};

export type ConversationStatus = (typeof ConversationStatus)[keyof typeof ConversationStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  SYSTEM: 'SYSTEM',
  BOOKING_UPDATE: 'BOOKING_UPDATE'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const MessageStatus: {
  SENDING: 'SENDING',
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  FAILED: 'FAILED',
  DELETED: 'DELETED'
};

export type MessageStatus = (typeof MessageStatus)[keyof typeof MessageStatus]


export const ReportType: {
  CHECK_IN: 'CHECK_IN',
  CHECK_OUT: 'CHECK_OUT'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]


export const ReportStatus: {
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  ACKNOWLEDGED: 'ACKNOWLEDGED',
  DISPUTED: 'DISPUTED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const DisputeType: {
  PROPERTY_DAMAGE: 'PROPERTY_DAMAGE',
  MISSING_ITEMS: 'MISSING_ITEMS',
  CONDITION_MISMATCH: 'CONDITION_MISMATCH',
  REFUND_REQUEST: 'REFUND_REQUEST',
  PAYMENT_ISSUE: 'PAYMENT_ISSUE',
  OTHER: 'OTHER'
};

export type DisputeType = (typeof DisputeType)[keyof typeof DisputeType]


export const DisputeStatus: {
  OPEN: 'OPEN',
  UNDER_REVIEW: 'UNDER_REVIEW',
  INVESTIGATING: 'INVESTIGATING',
  AWAITING_RESPONSE: 'AWAITING_RESPONSE',
  IN_MEDIATION: 'IN_MEDIATION',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type DisputeStatus = (typeof DisputeStatus)[keyof typeof DisputeStatus]


export const DisputePriority: {
  CRITICAL: 'CRITICAL',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type DisputePriority = (typeof DisputePriority)[keyof typeof DisputePriority]


export const EvidenceType: {
  PHOTO: 'PHOTO',
  VIDEO: 'VIDEO',
  DOCUMENT: 'DOCUMENT',
  RECEIPT: 'RECEIPT',
  OTHER: 'OTHER'
};

export type EvidenceType = (typeof EvidenceType)[keyof typeof EvidenceType]


export const ResolutionOutcome: {
  RESOLVED_INITIATOR_FAVOR: 'RESOLVED_INITIATOR_FAVOR',
  RESOLVED_DEFENDANT_FAVOR: 'RESOLVED_DEFENDANT_FAVOR',
  RESOLVED_COMPROMISE: 'RESOLVED_COMPROMISE',
  RESOLVED_NO_ACTION: 'RESOLVED_NO_ACTION',
  ESCALATED: 'ESCALATED',
  CANCELLED: 'CANCELLED'
};

export type ResolutionOutcome = (typeof ResolutionOutcome)[keyof typeof ResolutionOutcome]


export const NotificationType: {
  BOOKING_REQUEST: 'BOOKING_REQUEST',
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  BOOKING_CANCELLED: 'BOOKING_CANCELLED',
  BOOKING_REMINDER: 'BOOKING_REMINDER',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  REVIEW_RECEIVED: 'REVIEW_RECEIVED',
  PAYOUT_PROCESSED: 'PAYOUT_PROCESSED',
  DISPUTE_OPENED: 'DISPUTE_OPENED',
  DISPUTE_RESOLVED: 'DISPUTE_RESOLVED',
  LISTING_APPROVED: 'LISTING_APPROVED',
  LISTING_REJECTED: 'LISTING_REJECTED',
  VERIFICATION_COMPLETE: 'VERIFICATION_COMPLETE',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  UNREAD: 'UNREAD',
  READ: 'READ',
  ARCHIVED: 'ARCHIVED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const InsuranceStatus: {
  NOT_REQUIRED: 'NOT_REQUIRED',
  REQUIRED: 'REQUIRED',
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  EXPIRED: 'EXPIRED',
  REJECTED: 'REJECTED'
};

export type InsuranceStatus = (typeof InsuranceStatus)[keyof typeof InsuranceStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type VerificationStatus = $Enums.VerificationStatus

export const VerificationStatus: typeof $Enums.VerificationStatus

export type GovernmentIdType = $Enums.GovernmentIdType

export const GovernmentIdType: typeof $Enums.GovernmentIdType

export type OrganizationStatus = $Enums.OrganizationStatus

export const OrganizationStatus: typeof $Enums.OrganizationStatus

export type OrgRole = $Enums.OrgRole

export const OrgRole: typeof $Enums.OrgRole

export type BookingMode = $Enums.BookingMode

export const BookingMode: typeof $Enums.BookingMode

export type PricingMode = $Enums.PricingMode

export const PricingMode: typeof $Enums.PricingMode

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type ListingCondition = $Enums.ListingCondition

export const ListingCondition: typeof $Enums.ListingCondition

export type DepositType = $Enums.DepositType

export const DepositType: typeof $Enums.DepositType

export type CancellationPolicyType = $Enums.CancellationPolicyType

export const CancellationPolicyType: typeof $Enums.CancellationPolicyType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type LedgerSide = $Enums.LedgerSide

export const LedgerSide: typeof $Enums.LedgerSide

export type LedgerEntryStatus = $Enums.LedgerEntryStatus

export const LedgerEntryStatus: typeof $Enums.LedgerEntryStatus

export type DepositStatus = $Enums.DepositStatus

export const DepositStatus: typeof $Enums.DepositStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type RefundStatus = $Enums.RefundStatus

export const RefundStatus: typeof $Enums.RefundStatus

export type PayoutStatus = $Enums.PayoutStatus

export const PayoutStatus: typeof $Enums.PayoutStatus

export type ReviewType = $Enums.ReviewType

export const ReviewType: typeof $Enums.ReviewType

export type ReviewStatus = $Enums.ReviewStatus

export const ReviewStatus: typeof $Enums.ReviewStatus

export type ConversationType = $Enums.ConversationType

export const ConversationType: typeof $Enums.ConversationType

export type ConversationStatus = $Enums.ConversationStatus

export const ConversationStatus: typeof $Enums.ConversationStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type MessageStatus = $Enums.MessageStatus

export const MessageStatus: typeof $Enums.MessageStatus

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type DisputeType = $Enums.DisputeType

export const DisputeType: typeof $Enums.DisputeType

export type DisputeStatus = $Enums.DisputeStatus

export const DisputeStatus: typeof $Enums.DisputeStatus

export type DisputePriority = $Enums.DisputePriority

export const DisputePriority: typeof $Enums.DisputePriority

export type EvidenceType = $Enums.EvidenceType

export const EvidenceType: typeof $Enums.EvidenceType

export type ResolutionOutcome = $Enums.ResolutionOutcome

export const ResolutionOutcome: typeof $Enums.ResolutionOutcome

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type InsuranceStatus = $Enums.InsuranceStatus

export const InsuranceStatus: typeof $Enums.InsuranceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.organizationMember`: Exposes CRUD operations for the **OrganizationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganizationMembers
    * const organizationMembers = await prisma.organizationMember.findMany()
    * ```
    */
  get organizationMember(): Prisma.OrganizationMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listings
    * const listings = await prisma.listing.findMany()
    * ```
    */
  get listing(): Prisma.ListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellationPolicy`: Exposes CRUD operations for the **CancellationPolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CancellationPolicies
    * const cancellationPolicies = await prisma.cancellationPolicy.findMany()
    * ```
    */
  get cancellationPolicy(): Prisma.CancellationPolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.availability`: Exposes CRUD operations for the **Availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Availabilities
    * const availabilities = await prisma.availability.findMany()
    * ```
    */
  get availability(): Prisma.AvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favoriteListing`: Exposes CRUD operations for the **FavoriteListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteListings
    * const favoriteListings = await prisma.favoriteListing.findMany()
    * ```
    */
  get favoriteListing(): Prisma.FavoriteListingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookingStateHistory`: Exposes CRUD operations for the **BookingStateHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BookingStateHistories
    * const bookingStateHistories = await prisma.bookingStateHistory.findMany()
    * ```
    */
  get bookingStateHistory(): Prisma.BookingStateHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ledgerEntry`: Exposes CRUD operations for the **LedgerEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LedgerEntries
    * const ledgerEntries = await prisma.ledgerEntry.findMany()
    * ```
    */
  get ledgerEntry(): Prisma.LedgerEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.depositHold`: Exposes CRUD operations for the **DepositHold** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DepositHolds
    * const depositHolds = await prisma.depositHold.findMany()
    * ```
    */
  get depositHold(): Prisma.DepositHoldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refund`: Exposes CRUD operations for the **Refund** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Refunds
    * const refunds = await prisma.refund.findMany()
    * ```
    */
  get refund(): Prisma.RefundDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payout`: Exposes CRUD operations for the **Payout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payout.findMany()
    * ```
    */
  get payout(): Prisma.PayoutDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageReadReceipt`: Exposes CRUD operations for the **MessageReadReceipt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReadReceipts
    * const messageReadReceipts = await prisma.messageReadReceipt.findMany()
    * ```
    */
  get messageReadReceipt(): Prisma.MessageReadReceiptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conditionReport`: Exposes CRUD operations for the **ConditionReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConditionReports
    * const conditionReports = await prisma.conditionReport.findMany()
    * ```
    */
  get conditionReport(): Prisma.ConditionReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportPhoto`: Exposes CRUD operations for the **ReportPhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportPhotos
    * const reportPhotos = await prisma.reportPhoto.findMany()
    * ```
    */
  get reportPhoto(): Prisma.ReportPhotoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dispute`: Exposes CRUD operations for the **Dispute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disputes
    * const disputes = await prisma.dispute.findMany()
    * ```
    */
  get dispute(): Prisma.DisputeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disputeResponse`: Exposes CRUD operations for the **DisputeResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisputeResponses
    * const disputeResponses = await prisma.disputeResponse.findMany()
    * ```
    */
  get disputeResponse(): Prisma.DisputeResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disputeEvidence`: Exposes CRUD operations for the **DisputeEvidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisputeEvidences
    * const disputeEvidences = await prisma.disputeEvidence.findMany()
    * ```
    */
  get disputeEvidence(): Prisma.DisputeEvidenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disputeTimelineEvent`: Exposes CRUD operations for the **DisputeTimelineEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisputeTimelineEvents
    * const disputeTimelineEvents = await prisma.disputeTimelineEvent.findMany()
    * ```
    */
  get disputeTimelineEvent(): Prisma.DisputeTimelineEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disputeResolution`: Exposes CRUD operations for the **DisputeResolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisputeResolutions
    * const disputeResolutions = await prisma.disputeResolution.findMany()
    * ```
    */
  get disputeResolution(): Prisma.DisputeResolutionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insurancePolicy`: Exposes CRUD operations for the **InsurancePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsurancePolicies
    * const insurancePolicies = await prisma.insurancePolicy.findMany()
    * ```
    */
  get insurancePolicy(): Prisma.InsurancePolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceToken`: Exposes CRUD operations for the **DeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTokens
    * const deviceTokens = await prisma.deviceToken.findMany()
    * ```
    */
  get deviceToken(): Prisma.DeviceTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Organization: 'Organization',
    OrganizationMember: 'OrganizationMember',
    Category: 'Category',
    Listing: 'Listing',
    CancellationPolicy: 'CancellationPolicy',
    Availability: 'Availability',
    FavoriteListing: 'FavoriteListing',
    Booking: 'Booking',
    BookingStateHistory: 'BookingStateHistory',
    LedgerEntry: 'LedgerEntry',
    DepositHold: 'DepositHold',
    Payment: 'Payment',
    Refund: 'Refund',
    Payout: 'Payout',
    Review: 'Review',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    MessageReadReceipt: 'MessageReadReceipt',
    ConditionReport: 'ConditionReport',
    ReportPhoto: 'ReportPhoto',
    Dispute: 'Dispute',
    DisputeResponse: 'DisputeResponse',
    DisputeEvidence: 'DisputeEvidence',
    DisputeTimelineEvent: 'DisputeTimelineEvent',
    DisputeResolution: 'DisputeResolution',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    InsurancePolicy: 'InsurancePolicy',
    DeviceToken: 'DeviceToken',
    UserPreferences: 'UserPreferences'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "organization" | "organizationMember" | "category" | "listing" | "cancellationPolicy" | "availability" | "favoriteListing" | "booking" | "bookingStateHistory" | "ledgerEntry" | "depositHold" | "payment" | "refund" | "payout" | "review" | "conversation" | "conversationParticipant" | "message" | "messageReadReceipt" | "conditionReport" | "reportPhoto" | "dispute" | "disputeResponse" | "disputeEvidence" | "disputeTimelineEvent" | "disputeResolution" | "notification" | "auditLog" | "insurancePolicy" | "deviceToken" | "userPreferences"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      OrganizationMember: {
        payload: Prisma.$OrganizationMemberPayload<ExtArgs>
        fields: Prisma.OrganizationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganizationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganizationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganizationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganizationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          delete: {
            args: Prisma.OrganizationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          update: {
            args: Prisma.OrganizationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganizationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganizationMember>
          }
          groupBy: {
            args: Prisma.OrganizationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationMemberCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Listing: {
        payload: Prisma.$ListingPayload<ExtArgs>
        fields: Prisma.ListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findFirst: {
            args: Prisma.ListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findMany: {
            args: Prisma.ListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          create: {
            args: Prisma.ListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          createMany: {
            args: Prisma.ListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          delete: {
            args: Prisma.ListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          update: {
            args: Prisma.ListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          deleteMany: {
            args: Prisma.ListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          upsert: {
            args: Prisma.ListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          aggregate: {
            args: Prisma.ListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateListing>
          }
          groupBy: {
            args: Prisma.ListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ListingCountArgs<ExtArgs>
            result: $Utils.Optional<ListingCountAggregateOutputType> | number
          }
        }
      }
      CancellationPolicy: {
        payload: Prisma.$CancellationPolicyPayload<ExtArgs>
        fields: Prisma.CancellationPolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationPolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationPolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          findFirst: {
            args: Prisma.CancellationPolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationPolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          findMany: {
            args: Prisma.CancellationPolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          create: {
            args: Prisma.CancellationPolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          createMany: {
            args: Prisma.CancellationPolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationPolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          delete: {
            args: Prisma.CancellationPolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          update: {
            args: Prisma.CancellationPolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          deleteMany: {
            args: Prisma.CancellationPolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationPolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationPolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>[]
          }
          upsert: {
            args: Prisma.CancellationPolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPolicyPayload>
          }
          aggregate: {
            args: Prisma.CancellationPolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellationPolicy>
          }
          groupBy: {
            args: Prisma.CancellationPolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationPolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationPolicyCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationPolicyCountAggregateOutputType> | number
          }
        }
      }
      Availability: {
        payload: Prisma.$AvailabilityPayload<ExtArgs>
        fields: Prisma.AvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findFirst: {
            args: Prisma.AvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          findMany: {
            args: Prisma.AvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          create: {
            args: Prisma.AvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          createMany: {
            args: Prisma.AvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          delete: {
            args: Prisma.AvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          update: {
            args: Prisma.AvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.AvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.AvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AvailabilityPayload>
          }
          aggregate: {
            args: Prisma.AvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAvailability>
          }
          groupBy: {
            args: Prisma.AvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<AvailabilityCountAggregateOutputType> | number
          }
        }
      }
      FavoriteListing: {
        payload: Prisma.$FavoriteListingPayload<ExtArgs>
        fields: Prisma.FavoriteListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteListingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteListingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          findFirst: {
            args: Prisma.FavoriteListingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteListingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          findMany: {
            args: Prisma.FavoriteListingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>[]
          }
          create: {
            args: Prisma.FavoriteListingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          createMany: {
            args: Prisma.FavoriteListingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteListingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>[]
          }
          delete: {
            args: Prisma.FavoriteListingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          update: {
            args: Prisma.FavoriteListingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          deleteMany: {
            args: Prisma.FavoriteListingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteListingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteListingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>[]
          }
          upsert: {
            args: Prisma.FavoriteListingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteListingPayload>
          }
          aggregate: {
            args: Prisma.FavoriteListingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteListing>
          }
          groupBy: {
            args: Prisma.FavoriteListingGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteListingGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteListingCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteListingCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      BookingStateHistory: {
        payload: Prisma.$BookingStateHistoryPayload<ExtArgs>
        fields: Prisma.BookingStateHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingStateHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingStateHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          findFirst: {
            args: Prisma.BookingStateHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingStateHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          findMany: {
            args: Prisma.BookingStateHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>[]
          }
          create: {
            args: Prisma.BookingStateHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          createMany: {
            args: Prisma.BookingStateHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingStateHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>[]
          }
          delete: {
            args: Prisma.BookingStateHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          update: {
            args: Prisma.BookingStateHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          deleteMany: {
            args: Prisma.BookingStateHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingStateHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingStateHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>[]
          }
          upsert: {
            args: Prisma.BookingStateHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingStateHistoryPayload>
          }
          aggregate: {
            args: Prisma.BookingStateHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookingStateHistory>
          }
          groupBy: {
            args: Prisma.BookingStateHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingStateHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingStateHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<BookingStateHistoryCountAggregateOutputType> | number
          }
        }
      }
      LedgerEntry: {
        payload: Prisma.$LedgerEntryPayload<ExtArgs>
        fields: Prisma.LedgerEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LedgerEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LedgerEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findFirst: {
            args: Prisma.LedgerEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LedgerEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          findMany: {
            args: Prisma.LedgerEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          create: {
            args: Prisma.LedgerEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          createMany: {
            args: Prisma.LedgerEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LedgerEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          delete: {
            args: Prisma.LedgerEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          update: {
            args: Prisma.LedgerEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          deleteMany: {
            args: Prisma.LedgerEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LedgerEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LedgerEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>[]
          }
          upsert: {
            args: Prisma.LedgerEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LedgerEntryPayload>
          }
          aggregate: {
            args: Prisma.LedgerEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLedgerEntry>
          }
          groupBy: {
            args: Prisma.LedgerEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LedgerEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LedgerEntryCountAggregateOutputType> | number
          }
        }
      }
      DepositHold: {
        payload: Prisma.$DepositHoldPayload<ExtArgs>
        fields: Prisma.DepositHoldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepositHoldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepositHoldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          findFirst: {
            args: Prisma.DepositHoldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepositHoldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          findMany: {
            args: Prisma.DepositHoldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>[]
          }
          create: {
            args: Prisma.DepositHoldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          createMany: {
            args: Prisma.DepositHoldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepositHoldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>[]
          }
          delete: {
            args: Prisma.DepositHoldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          update: {
            args: Prisma.DepositHoldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          deleteMany: {
            args: Prisma.DepositHoldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepositHoldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepositHoldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>[]
          }
          upsert: {
            args: Prisma.DepositHoldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepositHoldPayload>
          }
          aggregate: {
            args: Prisma.DepositHoldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepositHold>
          }
          groupBy: {
            args: Prisma.DepositHoldGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepositHoldGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepositHoldCountArgs<ExtArgs>
            result: $Utils.Optional<DepositHoldCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Refund: {
        payload: Prisma.$RefundPayload<ExtArgs>
        fields: Prisma.RefundFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefundFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefundFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findFirst: {
            args: Prisma.RefundFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefundFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          findMany: {
            args: Prisma.RefundFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          create: {
            args: Prisma.RefundCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          createMany: {
            args: Prisma.RefundCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefundCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          delete: {
            args: Prisma.RefundDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          update: {
            args: Prisma.RefundUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          deleteMany: {
            args: Prisma.RefundDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefundUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefundUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>[]
          }
          upsert: {
            args: Prisma.RefundUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefundPayload>
          }
          aggregate: {
            args: Prisma.RefundAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefund>
          }
          groupBy: {
            args: Prisma.RefundGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefundGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefundCountArgs<ExtArgs>
            result: $Utils.Optional<RefundCountAggregateOutputType> | number
          }
        }
      }
      Payout: {
        payload: Prisma.$PayoutPayload<ExtArgs>
        fields: Prisma.PayoutFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findFirst: {
            args: Prisma.PayoutFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          findMany: {
            args: Prisma.PayoutFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          create: {
            args: Prisma.PayoutCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          createMany: {
            args: Prisma.PayoutCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayoutCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          delete: {
            args: Prisma.PayoutDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          update: {
            args: Prisma.PayoutUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          deleteMany: {
            args: Prisma.PayoutDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayoutUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>[]
          }
          upsert: {
            args: Prisma.PayoutUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutPayload>
          }
          aggregate: {
            args: Prisma.PayoutAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayout>
          }
          groupBy: {
            args: Prisma.PayoutGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageReadReceipt: {
        payload: Prisma.$MessageReadReceiptPayload<ExtArgs>
        fields: Prisma.MessageReadReceiptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadReceiptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          findFirst: {
            args: Prisma.MessageReadReceiptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadReceiptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          findMany: {
            args: Prisma.MessageReadReceiptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>[]
          }
          create: {
            args: Prisma.MessageReadReceiptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          createMany: {
            args: Prisma.MessageReadReceiptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadReceiptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>[]
          }
          delete: {
            args: Prisma.MessageReadReceiptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          update: {
            args: Prisma.MessageReadReceiptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadReceiptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadReceiptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageReadReceiptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>[]
          }
          upsert: {
            args: Prisma.MessageReadReceiptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadReceiptPayload>
          }
          aggregate: {
            args: Prisma.MessageReadReceiptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageReadReceipt>
          }
          groupBy: {
            args: Prisma.MessageReadReceiptGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadReceiptGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadReceiptCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadReceiptCountAggregateOutputType> | number
          }
        }
      }
      ConditionReport: {
        payload: Prisma.$ConditionReportPayload<ExtArgs>
        fields: Prisma.ConditionReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          findFirst: {
            args: Prisma.ConditionReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          findMany: {
            args: Prisma.ConditionReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>[]
          }
          create: {
            args: Prisma.ConditionReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          createMany: {
            args: Prisma.ConditionReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConditionReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>[]
          }
          delete: {
            args: Prisma.ConditionReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          update: {
            args: Prisma.ConditionReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          deleteMany: {
            args: Prisma.ConditionReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConditionReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>[]
          }
          upsert: {
            args: Prisma.ConditionReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConditionReportPayload>
          }
          aggregate: {
            args: Prisma.ConditionReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConditionReport>
          }
          groupBy: {
            args: Prisma.ConditionReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConditionReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConditionReportCountArgs<ExtArgs>
            result: $Utils.Optional<ConditionReportCountAggregateOutputType> | number
          }
        }
      }
      ReportPhoto: {
        payload: Prisma.$ReportPhotoPayload<ExtArgs>
        fields: Prisma.ReportPhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportPhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportPhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          findFirst: {
            args: Prisma.ReportPhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportPhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          findMany: {
            args: Prisma.ReportPhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>[]
          }
          create: {
            args: Prisma.ReportPhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          createMany: {
            args: Prisma.ReportPhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportPhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>[]
          }
          delete: {
            args: Prisma.ReportPhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          update: {
            args: Prisma.ReportPhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          deleteMany: {
            args: Prisma.ReportPhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportPhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportPhotoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>[]
          }
          upsert: {
            args: Prisma.ReportPhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPhotoPayload>
          }
          aggregate: {
            args: Prisma.ReportPhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportPhoto>
          }
          groupBy: {
            args: Prisma.ReportPhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportPhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportPhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ReportPhotoCountAggregateOutputType> | number
          }
        }
      }
      Dispute: {
        payload: Prisma.$DisputePayload<ExtArgs>
        fields: Prisma.DisputeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findFirst: {
            args: Prisma.DisputeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          findMany: {
            args: Prisma.DisputeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          create: {
            args: Prisma.DisputeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          createMany: {
            args: Prisma.DisputeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          delete: {
            args: Prisma.DisputeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          update: {
            args: Prisma.DisputeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          deleteMany: {
            args: Prisma.DisputeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>[]
          }
          upsert: {
            args: Prisma.DisputeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputePayload>
          }
          aggregate: {
            args: Prisma.DisputeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDispute>
          }
          groupBy: {
            args: Prisma.DisputeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeCountAggregateOutputType> | number
          }
        }
      }
      DisputeResponse: {
        payload: Prisma.$DisputeResponsePayload<ExtArgs>
        fields: Prisma.DisputeResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          findFirst: {
            args: Prisma.DisputeResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          findMany: {
            args: Prisma.DisputeResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>[]
          }
          create: {
            args: Prisma.DisputeResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          createMany: {
            args: Prisma.DisputeResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>[]
          }
          delete: {
            args: Prisma.DisputeResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          update: {
            args: Prisma.DisputeResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          deleteMany: {
            args: Prisma.DisputeResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>[]
          }
          upsert: {
            args: Prisma.DisputeResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResponsePayload>
          }
          aggregate: {
            args: Prisma.DisputeResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisputeResponse>
          }
          groupBy: {
            args: Prisma.DisputeResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeResponseCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeResponseCountAggregateOutputType> | number
          }
        }
      }
      DisputeEvidence: {
        payload: Prisma.$DisputeEvidencePayload<ExtArgs>
        fields: Prisma.DisputeEvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeEvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeEvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          findFirst: {
            args: Prisma.DisputeEvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeEvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          findMany: {
            args: Prisma.DisputeEvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
          }
          create: {
            args: Prisma.DisputeEvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          createMany: {
            args: Prisma.DisputeEvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeEvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
          }
          delete: {
            args: Prisma.DisputeEvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          update: {
            args: Prisma.DisputeEvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          deleteMany: {
            args: Prisma.DisputeEvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeEvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeEvidenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>[]
          }
          upsert: {
            args: Prisma.DisputeEvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeEvidencePayload>
          }
          aggregate: {
            args: Prisma.DisputeEvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisputeEvidence>
          }
          groupBy: {
            args: Prisma.DisputeEvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeEvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeEvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeEvidenceCountAggregateOutputType> | number
          }
        }
      }
      DisputeTimelineEvent: {
        payload: Prisma.$DisputeTimelineEventPayload<ExtArgs>
        fields: Prisma.DisputeTimelineEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeTimelineEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeTimelineEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          findFirst: {
            args: Prisma.DisputeTimelineEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeTimelineEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          findMany: {
            args: Prisma.DisputeTimelineEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>[]
          }
          create: {
            args: Prisma.DisputeTimelineEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          createMany: {
            args: Prisma.DisputeTimelineEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeTimelineEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>[]
          }
          delete: {
            args: Prisma.DisputeTimelineEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          update: {
            args: Prisma.DisputeTimelineEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          deleteMany: {
            args: Prisma.DisputeTimelineEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeTimelineEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeTimelineEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>[]
          }
          upsert: {
            args: Prisma.DisputeTimelineEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeTimelineEventPayload>
          }
          aggregate: {
            args: Prisma.DisputeTimelineEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisputeTimelineEvent>
          }
          groupBy: {
            args: Prisma.DisputeTimelineEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeTimelineEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeTimelineEventCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeTimelineEventCountAggregateOutputType> | number
          }
        }
      }
      DisputeResolution: {
        payload: Prisma.$DisputeResolutionPayload<ExtArgs>
        fields: Prisma.DisputeResolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisputeResolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisputeResolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          findFirst: {
            args: Prisma.DisputeResolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisputeResolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          findMany: {
            args: Prisma.DisputeResolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>[]
          }
          create: {
            args: Prisma.DisputeResolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          createMany: {
            args: Prisma.DisputeResolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisputeResolutionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>[]
          }
          delete: {
            args: Prisma.DisputeResolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          update: {
            args: Prisma.DisputeResolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          deleteMany: {
            args: Prisma.DisputeResolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisputeResolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisputeResolutionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>[]
          }
          upsert: {
            args: Prisma.DisputeResolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisputeResolutionPayload>
          }
          aggregate: {
            args: Prisma.DisputeResolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisputeResolution>
          }
          groupBy: {
            args: Prisma.DisputeResolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisputeResolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisputeResolutionCountArgs<ExtArgs>
            result: $Utils.Optional<DisputeResolutionCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      InsurancePolicy: {
        payload: Prisma.$InsurancePolicyPayload<ExtArgs>
        fields: Prisma.InsurancePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsurancePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsurancePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          findFirst: {
            args: Prisma.InsurancePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsurancePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          findMany: {
            args: Prisma.InsurancePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>[]
          }
          create: {
            args: Prisma.InsurancePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          createMany: {
            args: Prisma.InsurancePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsurancePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>[]
          }
          delete: {
            args: Prisma.InsurancePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          update: {
            args: Prisma.InsurancePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          deleteMany: {
            args: Prisma.InsurancePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsurancePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsurancePolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>[]
          }
          upsert: {
            args: Prisma.InsurancePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsurancePolicyPayload>
          }
          aggregate: {
            args: Prisma.InsurancePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsurancePolicy>
          }
          groupBy: {
            args: Prisma.InsurancePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsurancePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsurancePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<InsurancePolicyCountAggregateOutputType> | number
          }
        }
      }
      DeviceToken: {
        payload: Prisma.$DeviceTokenPayload<ExtArgs>
        fields: Prisma.DeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findMany: {
            args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          create: {
            args: Prisma.DeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          createMany: {
            args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          update: {
            args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceToken>
          }
          groupBy: {
            args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    organization?: OrganizationOmit
    organizationMember?: OrganizationMemberOmit
    category?: CategoryOmit
    listing?: ListingOmit
    cancellationPolicy?: CancellationPolicyOmit
    availability?: AvailabilityOmit
    favoriteListing?: FavoriteListingOmit
    booking?: BookingOmit
    bookingStateHistory?: BookingStateHistoryOmit
    ledgerEntry?: LedgerEntryOmit
    depositHold?: DepositHoldOmit
    payment?: PaymentOmit
    refund?: RefundOmit
    payout?: PayoutOmit
    review?: ReviewOmit
    conversation?: ConversationOmit
    conversationParticipant?: ConversationParticipantOmit
    message?: MessageOmit
    messageReadReceipt?: MessageReadReceiptOmit
    conditionReport?: ConditionReportOmit
    reportPhoto?: ReportPhotoOmit
    dispute?: DisputeOmit
    disputeResponse?: DisputeResponseOmit
    disputeEvidence?: DisputeEvidenceOmit
    disputeTimelineEvent?: DisputeTimelineEventOmit
    disputeResolution?: DisputeResolutionOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    insurancePolicy?: InsurancePolicyOmit
    deviceToken?: DeviceTokenOmit
    userPreferences?: UserPreferencesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    listings: number
    bookingsAsRenter: number
    bookingsAsOwner: number
    reviewsGiven: number
    reviewsReceived: number
    conversationParticipants: number
    messages: number
    auditLogs: number
    disputesInitiated: number
    disputesDefended: number
    disputeResponses: number
    organizations: number
    favoriteListings: number
    notifications: number
    insurancePolicies: number
    deviceTokens: number
    conditionReportsReported: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    listings?: boolean | UserCountOutputTypeCountListingsArgs
    bookingsAsRenter?: boolean | UserCountOutputTypeCountBookingsAsRenterArgs
    bookingsAsOwner?: boolean | UserCountOutputTypeCountBookingsAsOwnerArgs
    reviewsGiven?: boolean | UserCountOutputTypeCountReviewsGivenArgs
    reviewsReceived?: boolean | UserCountOutputTypeCountReviewsReceivedArgs
    conversationParticipants?: boolean | UserCountOutputTypeCountConversationParticipantsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    disputesInitiated?: boolean | UserCountOutputTypeCountDisputesInitiatedArgs
    disputesDefended?: boolean | UserCountOutputTypeCountDisputesDefendedArgs
    disputeResponses?: boolean | UserCountOutputTypeCountDisputeResponsesArgs
    organizations?: boolean | UserCountOutputTypeCountOrganizationsArgs
    favoriteListings?: boolean | UserCountOutputTypeCountFavoriteListingsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    insurancePolicies?: boolean | UserCountOutputTypeCountInsurancePoliciesArgs
    deviceTokens?: boolean | UserCountOutputTypeCountDeviceTokensArgs
    conditionReportsReported?: boolean | UserCountOutputTypeCountConditionReportsReportedArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsAsRenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsAsOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisputesInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisputesDefendedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDisputeResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrganizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoriteListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteListingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsurancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurancePolicyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConditionReportsReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionReportWhereInput
  }


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    members: number
    listings: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganizationCountOutputTypeCountMembersArgs
    listings?: boolean | OrganizationCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    listings: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | CategoryCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type ListingCountOutputType
   */

  export type ListingCountOutputType = {
    availability: number
    bookings: number
    reviews: number
    favorites: number
    insurancePolicies: number
  }

  export type ListingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availability?: boolean | ListingCountOutputTypeCountAvailabilityArgs
    bookings?: boolean | ListingCountOutputTypeCountBookingsArgs
    reviews?: boolean | ListingCountOutputTypeCountReviewsArgs
    favorites?: boolean | ListingCountOutputTypeCountFavoritesArgs
    insurancePolicies?: boolean | ListingCountOutputTypeCountInsurancePoliciesArgs
  }

  // Custom InputTypes
  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingCountOutputType
     */
    select?: ListingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteListingWhereInput
  }

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountInsurancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurancePolicyWhereInput
  }


  /**
   * Count Type CancellationPolicyCountOutputType
   */

  export type CancellationPolicyCountOutputType = {
    listings: number
  }

  export type CancellationPolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | CancellationPolicyCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes
  /**
   * CancellationPolicyCountOutputType without action
   */
  export type CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicyCountOutputType
     */
    select?: CancellationPolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CancellationPolicyCountOutputType without action
   */
  export type CancellationPolicyCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    stateHistory: number
    ledgerEntries: number
    payments: number
    conditionReports: number
    reviews: number
    disputes: number
    conversations: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stateHistory?: boolean | BookingCountOutputTypeCountStateHistoryArgs
    ledgerEntries?: boolean | BookingCountOutputTypeCountLedgerEntriesArgs
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    conditionReports?: boolean | BookingCountOutputTypeCountConditionReportsArgs
    reviews?: boolean | BookingCountOutputTypeCountReviewsArgs
    disputes?: boolean | BookingCountOutputTypeCountDisputesArgs
    conversations?: boolean | BookingCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountStateHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStateHistoryWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountLedgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountConditionReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionReportWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountDisputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type DepositHoldCountOutputType
   */

  export type DepositHoldCountOutputType = {
    bookings: number
  }

  export type DepositHoldCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | DepositHoldCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * DepositHoldCountOutputType without action
   */
  export type DepositHoldCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHoldCountOutputType
     */
    select?: DepositHoldCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepositHoldCountOutputType without action
   */
  export type DepositHoldCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    readReceipts: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    readReceipts?: boolean | MessageCountOutputTypeCountReadReceiptsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadReceiptWhereInput
  }


  /**
   * Count Type ConditionReportCountOutputType
   */

  export type ConditionReportCountOutputType = {
    photos: number
  }

  export type ConditionReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ConditionReportCountOutputTypeCountPhotosArgs
  }

  // Custom InputTypes
  /**
   * ConditionReportCountOutputType without action
   */
  export type ConditionReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReportCountOutputType
     */
    select?: ConditionReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConditionReportCountOutputType without action
   */
  export type ConditionReportCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportPhotoWhereInput
  }


  /**
   * Count Type DisputeCountOutputType
   */

  export type DisputeCountOutputType = {
    responses: number
    evidence: number
    timeline: number
  }

  export type DisputeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | DisputeCountOutputTypeCountResponsesArgs
    evidence?: boolean | DisputeCountOutputTypeCountEvidenceArgs
    timeline?: boolean | DisputeCountOutputTypeCountTimelineArgs
  }

  // Custom InputTypes
  /**
   * DisputeCountOutputType without action
   */
  export type DisputeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeCountOutputType
     */
    select?: DisputeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisputeCountOutputType without action
   */
  export type DisputeCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeResponseWhereInput
  }

  /**
   * DisputeCountOutputType without action
   */
  export type DisputeCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeEvidenceWhereInput
  }

  /**
   * DisputeCountOutputType without action
   */
  export type DisputeCountOutputTypeCountTimelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeTimelineEventWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    averageRating: number | null
    totalReviews: number | null
    responseRate: number | null
    responseTime: number | null
  }

  export type UserSumAggregateOutputType = {
    averageRating: number | null
    totalReviews: number | null
    responseRate: number | null
    responseTime: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    emailVerificationToken: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    phone: string | null
    phoneVerified: boolean | null
    dateOfBirth: Date | null
    profilePhotoUrl: string | null
    bio: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    idVerificationStatus: $Enums.VerificationStatus | null
    idVerificationUrl: string | null
    governmentIdUrl: string | null
    governmentIdType: $Enums.GovernmentIdType | null
    governmentIdNumber: string | null
    stripeCustomerId: string | null
    stripeConnectId: string | null
    stripeOnboardingComplete: boolean | null
    stripeChargesEnabled: boolean | null
    stripePayoutsEnabled: boolean | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    preferredLanguage: string | null
    preferredCurrency: string | null
    timezone: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    averageRating: number | null
    totalReviews: number | null
    responseRate: number | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    emailVerified: boolean | null
    emailVerificationToken: string | null
    passwordHash: string | null
    firstName: string | null
    lastName: string | null
    phoneNumber: string | null
    phone: string | null
    phoneVerified: boolean | null
    dateOfBirth: Date | null
    profilePhotoUrl: string | null
    bio: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    idVerificationStatus: $Enums.VerificationStatus | null
    idVerificationUrl: string | null
    governmentIdUrl: string | null
    governmentIdType: $Enums.GovernmentIdType | null
    governmentIdNumber: string | null
    stripeCustomerId: string | null
    stripeConnectId: string | null
    stripeOnboardingComplete: boolean | null
    stripeChargesEnabled: boolean | null
    stripePayoutsEnabled: boolean | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    preferredLanguage: string | null
    preferredCurrency: string | null
    timezone: string | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    averageRating: number | null
    totalReviews: number | null
    responseRate: number | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    emailVerified: number
    emailVerificationToken: number
    passwordHash: number
    firstName: number
    lastName: number
    phoneNumber: number
    phone: number
    phoneVerified: number
    dateOfBirth: number
    profilePhotoUrl: number
    bio: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    idVerificationStatus: number
    idVerificationUrl: number
    governmentIdUrl: number
    governmentIdType: number
    governmentIdNumber: number
    stripeCustomerId: number
    stripeConnectId: number
    stripeOnboardingComplete: number
    stripeChargesEnabled: number
    stripePayoutsEnabled: number
    role: number
    status: number
    preferredLanguage: number
    preferredCurrency: number
    timezone: number
    mfaEnabled: number
    mfaSecret: number
    passwordResetToken: number
    passwordResetExpires: number
    lastLoginAt: number
    lastLoginIp: number
    averageRating: number
    totalReviews: number
    responseRate: number
    responseTime: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    averageRating?: true
    totalReviews?: true
    responseRate?: true
    responseTime?: true
  }

  export type UserSumAggregateInputType = {
    averageRating?: true
    totalReviews?: true
    responseRate?: true
    responseTime?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    phone?: true
    phoneVerified?: true
    dateOfBirth?: true
    profilePhotoUrl?: true
    bio?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    idVerificationStatus?: true
    idVerificationUrl?: true
    governmentIdUrl?: true
    governmentIdType?: true
    governmentIdNumber?: true
    stripeCustomerId?: true
    stripeConnectId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    role?: true
    status?: true
    preferredLanguage?: true
    preferredCurrency?: true
    timezone?: true
    mfaEnabled?: true
    mfaSecret?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    lastLoginIp?: true
    averageRating?: true
    totalReviews?: true
    responseRate?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    phone?: true
    phoneVerified?: true
    dateOfBirth?: true
    profilePhotoUrl?: true
    bio?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    idVerificationStatus?: true
    idVerificationUrl?: true
    governmentIdUrl?: true
    governmentIdType?: true
    governmentIdNumber?: true
    stripeCustomerId?: true
    stripeConnectId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    role?: true
    status?: true
    preferredLanguage?: true
    preferredCurrency?: true
    timezone?: true
    mfaEnabled?: true
    mfaSecret?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    lastLoginIp?: true
    averageRating?: true
    totalReviews?: true
    responseRate?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    emailVerified?: true
    emailVerificationToken?: true
    passwordHash?: true
    firstName?: true
    lastName?: true
    phoneNumber?: true
    phone?: true
    phoneVerified?: true
    dateOfBirth?: true
    profilePhotoUrl?: true
    bio?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    idVerificationStatus?: true
    idVerificationUrl?: true
    governmentIdUrl?: true
    governmentIdType?: true
    governmentIdNumber?: true
    stripeCustomerId?: true
    stripeConnectId?: true
    stripeOnboardingComplete?: true
    stripeChargesEnabled?: true
    stripePayoutsEnabled?: true
    role?: true
    status?: true
    preferredLanguage?: true
    preferredCurrency?: true
    timezone?: true
    mfaEnabled?: true
    mfaSecret?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    lastLoginIp?: true
    averageRating?: true
    totalReviews?: true
    responseRate?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    emailVerified: boolean
    emailVerificationToken: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber: string | null
    phone: string | null
    phoneVerified: boolean
    dateOfBirth: Date | null
    profilePhotoUrl: string | null
    bio: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    idVerificationStatus: $Enums.VerificationStatus
    idVerificationUrl: string | null
    governmentIdUrl: string | null
    governmentIdType: $Enums.GovernmentIdType | null
    governmentIdNumber: string | null
    stripeCustomerId: string | null
    stripeConnectId: string | null
    stripeOnboardingComplete: boolean
    stripeChargesEnabled: boolean
    stripePayoutsEnabled: boolean
    role: $Enums.UserRole
    status: $Enums.UserStatus
    preferredLanguage: string
    preferredCurrency: string
    timezone: string
    mfaEnabled: boolean
    mfaSecret: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    lastLoginIp: string | null
    averageRating: number
    totalReviews: number
    responseRate: number
    responseTime: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    phone?: boolean
    phoneVerified?: boolean
    dateOfBirth?: boolean
    profilePhotoUrl?: boolean
    bio?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    idVerificationStatus?: boolean
    idVerificationUrl?: boolean
    governmentIdUrl?: boolean
    governmentIdType?: boolean
    governmentIdNumber?: boolean
    stripeCustomerId?: boolean
    stripeConnectId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: boolean
    status?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    timezone?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    responseRate?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    bookingsAsRenter?: boolean | User$bookingsAsRenterArgs<ExtArgs>
    bookingsAsOwner?: boolean | User$bookingsAsOwnerArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    conversationParticipants?: boolean | User$conversationParticipantsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    disputesInitiated?: boolean | User$disputesInitiatedArgs<ExtArgs>
    disputesDefended?: boolean | User$disputesDefendedArgs<ExtArgs>
    disputeResponses?: boolean | User$disputeResponsesArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    favoriteListings?: boolean | User$favoriteListingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    insurancePolicies?: boolean | User$insurancePoliciesArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
    conditionReportsReported?: boolean | User$conditionReportsReportedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    phone?: boolean
    phoneVerified?: boolean
    dateOfBirth?: boolean
    profilePhotoUrl?: boolean
    bio?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    idVerificationStatus?: boolean
    idVerificationUrl?: boolean
    governmentIdUrl?: boolean
    governmentIdType?: boolean
    governmentIdNumber?: boolean
    stripeCustomerId?: boolean
    stripeConnectId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: boolean
    status?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    timezone?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    responseRate?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    phone?: boolean
    phoneVerified?: boolean
    dateOfBirth?: boolean
    profilePhotoUrl?: boolean
    bio?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    idVerificationStatus?: boolean
    idVerificationUrl?: boolean
    governmentIdUrl?: boolean
    governmentIdType?: boolean
    governmentIdNumber?: boolean
    stripeCustomerId?: boolean
    stripeConnectId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: boolean
    status?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    timezone?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    responseRate?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    emailVerified?: boolean
    emailVerificationToken?: boolean
    passwordHash?: boolean
    firstName?: boolean
    lastName?: boolean
    phoneNumber?: boolean
    phone?: boolean
    phoneVerified?: boolean
    dateOfBirth?: boolean
    profilePhotoUrl?: boolean
    bio?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    idVerificationStatus?: boolean
    idVerificationUrl?: boolean
    governmentIdUrl?: boolean
    governmentIdType?: boolean
    governmentIdNumber?: boolean
    stripeCustomerId?: boolean
    stripeConnectId?: boolean
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: boolean
    status?: boolean
    preferredLanguage?: boolean
    preferredCurrency?: boolean
    timezone?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    lastLoginIp?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    responseRate?: boolean
    responseTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "emailVerified" | "emailVerificationToken" | "passwordHash" | "firstName" | "lastName" | "phoneNumber" | "phone" | "phoneVerified" | "dateOfBirth" | "profilePhotoUrl" | "bio" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "idVerificationStatus" | "idVerificationUrl" | "governmentIdUrl" | "governmentIdType" | "governmentIdNumber" | "stripeCustomerId" | "stripeConnectId" | "stripeOnboardingComplete" | "stripeChargesEnabled" | "stripePayoutsEnabled" | "role" | "status" | "preferredLanguage" | "preferredCurrency" | "timezone" | "mfaEnabled" | "mfaSecret" | "passwordResetToken" | "passwordResetExpires" | "lastLoginAt" | "lastLoginIp" | "averageRating" | "totalReviews" | "responseRate" | "responseTime" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    bookingsAsRenter?: boolean | User$bookingsAsRenterArgs<ExtArgs>
    bookingsAsOwner?: boolean | User$bookingsAsOwnerArgs<ExtArgs>
    reviewsGiven?: boolean | User$reviewsGivenArgs<ExtArgs>
    reviewsReceived?: boolean | User$reviewsReceivedArgs<ExtArgs>
    conversationParticipants?: boolean | User$conversationParticipantsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    disputesInitiated?: boolean | User$disputesInitiatedArgs<ExtArgs>
    disputesDefended?: boolean | User$disputesDefendedArgs<ExtArgs>
    disputeResponses?: boolean | User$disputeResponsesArgs<ExtArgs>
    organizations?: boolean | User$organizationsArgs<ExtArgs>
    favoriteListings?: boolean | User$favoriteListingsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    insurancePolicies?: boolean | User$insurancePoliciesArgs<ExtArgs>
    deviceTokens?: boolean | User$deviceTokensArgs<ExtArgs>
    userPreferences?: boolean | User$userPreferencesArgs<ExtArgs>
    conditionReportsReported?: boolean | User$conditionReportsReportedArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
      bookingsAsRenter: Prisma.$BookingPayload<ExtArgs>[]
      bookingsAsOwner: Prisma.$BookingPayload<ExtArgs>[]
      reviewsGiven: Prisma.$ReviewPayload<ExtArgs>[]
      reviewsReceived: Prisma.$ReviewPayload<ExtArgs>[]
      conversationParticipants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      disputesInitiated: Prisma.$DisputePayload<ExtArgs>[]
      disputesDefended: Prisma.$DisputePayload<ExtArgs>[]
      disputeResponses: Prisma.$DisputeResponsePayload<ExtArgs>[]
      organizations: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      favoriteListings: Prisma.$FavoriteListingPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      insurancePolicies: Prisma.$InsurancePolicyPayload<ExtArgs>[]
      deviceTokens: Prisma.$DeviceTokenPayload<ExtArgs>[]
      userPreferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      conditionReportsReported: Prisma.$ConditionReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      emailVerified: boolean
      emailVerificationToken: string | null
      passwordHash: string
      firstName: string
      lastName: string
      phoneNumber: string | null
      phone: string | null
      phoneVerified: boolean
      dateOfBirth: Date | null
      profilePhotoUrl: string | null
      bio: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      idVerificationStatus: $Enums.VerificationStatus
      idVerificationUrl: string | null
      governmentIdUrl: string | null
      governmentIdType: $Enums.GovernmentIdType | null
      governmentIdNumber: string | null
      stripeCustomerId: string | null
      stripeConnectId: string | null
      stripeOnboardingComplete: boolean
      stripeChargesEnabled: boolean
      stripePayoutsEnabled: boolean
      role: $Enums.UserRole
      status: $Enums.UserStatus
      preferredLanguage: string
      preferredCurrency: string
      timezone: string
      mfaEnabled: boolean
      mfaSecret: string | null
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      lastLoginAt: Date | null
      lastLoginIp: string | null
      averageRating: number
      totalReviews: number
      responseRate: number
      responseTime: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listings<T extends User$listingsArgs<ExtArgs> = {}>(args?: Subset<T, User$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingsAsRenter<T extends User$bookingsAsRenterArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsAsRenterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingsAsOwner<T extends User$bookingsAsOwnerArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsAsOwnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsGiven<T extends User$reviewsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewsReceived<T extends User$reviewsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationParticipants<T extends User$conversationParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputesInitiated<T extends User$disputesInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$disputesInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputesDefended<T extends User$disputesDefendedArgs<ExtArgs> = {}>(args?: Subset<T, User$disputesDefendedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputeResponses<T extends User$disputeResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$disputeResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    organizations<T extends User$organizationsArgs<ExtArgs> = {}>(args?: Subset<T, User$organizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favoriteListings<T extends User$favoriteListingsArgs<ExtArgs> = {}>(args?: Subset<T, User$favoriteListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insurancePolicies<T extends User$insurancePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, User$insurancePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceTokens<T extends User$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPreferences<T extends User$userPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPreferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conditionReportsReported<T extends User$conditionReportsReportedArgs<ExtArgs> = {}>(args?: Subset<T, User$conditionReportsReportedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly profilePhotoUrl: FieldRef<"User", 'String'>
    readonly bio: FieldRef<"User", 'String'>
    readonly addressLine1: FieldRef<"User", 'String'>
    readonly addressLine2: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly postalCode: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly idVerificationStatus: FieldRef<"User", 'VerificationStatus'>
    readonly idVerificationUrl: FieldRef<"User", 'String'>
    readonly governmentIdUrl: FieldRef<"User", 'String'>
    readonly governmentIdType: FieldRef<"User", 'GovernmentIdType'>
    readonly governmentIdNumber: FieldRef<"User", 'String'>
    readonly stripeCustomerId: FieldRef<"User", 'String'>
    readonly stripeConnectId: FieldRef<"User", 'String'>
    readonly stripeOnboardingComplete: FieldRef<"User", 'Boolean'>
    readonly stripeChargesEnabled: FieldRef<"User", 'Boolean'>
    readonly stripePayoutsEnabled: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly preferredCurrency: FieldRef<"User", 'String'>
    readonly timezone: FieldRef<"User", 'String'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginIp: FieldRef<"User", 'String'>
    readonly averageRating: FieldRef<"User", 'Float'>
    readonly totalReviews: FieldRef<"User", 'Int'>
    readonly responseRate: FieldRef<"User", 'Float'>
    readonly responseTime: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.listings
   */
  export type User$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * User.bookingsAsRenter
   */
  export type User$bookingsAsRenterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.bookingsAsOwner
   */
  export type User$bookingsAsOwnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.reviewsGiven
   */
  export type User$reviewsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewsReceived
   */
  export type User$reviewsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.conversationParticipants
   */
  export type User$conversationParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.disputesInitiated
   */
  export type User$disputesInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    cursor?: DisputeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * User.disputesDefended
   */
  export type User$disputesDefendedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    cursor?: DisputeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * User.disputeResponses
   */
  export type User$disputeResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    where?: DisputeResponseWhereInput
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    cursor?: DisputeResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeResponseScalarFieldEnum | DisputeResponseScalarFieldEnum[]
  }

  /**
   * User.organizations
   */
  export type User$organizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * User.favoriteListings
   */
  export type User$favoriteListingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    where?: FavoriteListingWhereInput
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    cursor?: FavoriteListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteListingScalarFieldEnum | FavoriteListingScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.insurancePolicies
   */
  export type User$insurancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    where?: InsurancePolicyWhereInput
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    cursor?: InsurancePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsurancePolicyScalarFieldEnum | InsurancePolicyScalarFieldEnum[]
  }

  /**
   * User.deviceTokens
   */
  export type User$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    cursor?: DeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * User.userPreferences
   */
  export type User$userPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.conditionReportsReported
   */
  export type User$conditionReportsReportedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    where?: ConditionReportWhereInput
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    cursor?: ConditionReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConditionReportScalarFieldEnum | ConditionReportScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    refreshToken: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "refreshToken" | "expiresAt" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      refreshToken: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    websiteUrl: string | null
    businessType: string | null
    taxId: string | null
    email: string | null
    phoneNumber: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    stripeConnectId: string | null
    status: $Enums.OrganizationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    logoUrl: string | null
    websiteUrl: string | null
    businessType: string | null
    taxId: string | null
    email: string | null
    phoneNumber: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    stripeConnectId: string | null
    status: $Enums.OrganizationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    logoUrl: number
    websiteUrl: number
    businessType: number
    taxId: number
    email: number
    phoneNumber: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    stripeConnectId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    websiteUrl?: true
    businessType?: true
    taxId?: true
    email?: true
    phoneNumber?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    stripeConnectId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    websiteUrl?: true
    businessType?: true
    taxId?: true
    email?: true
    phoneNumber?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    stripeConnectId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    logoUrl?: true
    websiteUrl?: true
    businessType?: true
    taxId?: true
    email?: true
    phoneNumber?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    stripeConnectId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    logoUrl: string | null
    websiteUrl: string | null
    businessType: string | null
    taxId: string | null
    email: string
    phoneNumber: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    stripeConnectId: string | null
    status: $Enums.OrganizationStatus
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    websiteUrl?: boolean
    businessType?: boolean
    taxId?: boolean
    email?: boolean
    phoneNumber?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    stripeConnectId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Organization$membersArgs<ExtArgs>
    listings?: boolean | Organization$listingsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    websiteUrl?: boolean
    businessType?: boolean
    taxId?: boolean
    email?: boolean
    phoneNumber?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    stripeConnectId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    websiteUrl?: boolean
    businessType?: boolean
    taxId?: boolean
    email?: boolean
    phoneNumber?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    stripeConnectId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    logoUrl?: boolean
    websiteUrl?: boolean
    businessType?: boolean
    taxId?: boolean
    email?: boolean
    phoneNumber?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    stripeConnectId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "logoUrl" | "websiteUrl" | "businessType" | "taxId" | "email" | "phoneNumber" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "stripeConnectId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organization$membersArgs<ExtArgs>
    listings?: boolean | Organization$listingsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      members: Prisma.$OrganizationMemberPayload<ExtArgs>[]
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      logoUrl: string | null
      websiteUrl: string | null
      businessType: string | null
      taxId: string | null
      email: string
      phoneNumber: string | null
      addressLine1: string | null
      addressLine2: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      stripeConnectId: string | null
      status: $Enums.OrganizationStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organization$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    listings<T extends Organization$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly description: FieldRef<"Organization", 'String'>
    readonly logoUrl: FieldRef<"Organization", 'String'>
    readonly websiteUrl: FieldRef<"Organization", 'String'>
    readonly businessType: FieldRef<"Organization", 'String'>
    readonly taxId: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly phoneNumber: FieldRef<"Organization", 'String'>
    readonly addressLine1: FieldRef<"Organization", 'String'>
    readonly addressLine2: FieldRef<"Organization", 'String'>
    readonly city: FieldRef<"Organization", 'String'>
    readonly state: FieldRef<"Organization", 'String'>
    readonly postalCode: FieldRef<"Organization", 'String'>
    readonly country: FieldRef<"Organization", 'String'>
    readonly stripeConnectId: FieldRef<"Organization", 'String'>
    readonly status: FieldRef<"Organization", 'OrganizationStatus'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.members
   */
  export type Organization$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    cursor?: OrganizationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * Organization.listings
   */
  export type Organization$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model OrganizationMember
   */

  export type AggregateOrganizationMember = {
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  export type OrganizationMemberMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: $Enums.OrgRole | null
    invitedBy: string | null
    joinedAt: Date | null
  }

  export type OrganizationMemberMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    userId: string | null
    role: $Enums.OrgRole | null
    invitedBy: string | null
    joinedAt: Date | null
  }

  export type OrganizationMemberCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    role: number
    permissions: number
    invitedBy: number
    joinedAt: number
    _all: number
  }


  export type OrganizationMemberMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    invitedBy?: true
    joinedAt?: true
  }

  export type OrganizationMemberMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    invitedBy?: true
    joinedAt?: true
  }

  export type OrganizationMemberCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    role?: true
    permissions?: true
    invitedBy?: true
    joinedAt?: true
    _all?: true
  }

  export type OrganizationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMember to aggregate.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganizationMembers
    **/
    _count?: true | OrganizationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type GetOrganizationMemberAggregateType<T extends OrganizationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganizationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganizationMember[P]>
      : GetScalarType<T[P], AggregateOrganizationMember[P]>
  }




  export type OrganizationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationMemberWhereInput
    orderBy?: OrganizationMemberOrderByWithAggregationInput | OrganizationMemberOrderByWithAggregationInput[]
    by: OrganizationMemberScalarFieldEnum[] | OrganizationMemberScalarFieldEnum
    having?: OrganizationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationMemberCountAggregateInputType | true
    _min?: OrganizationMemberMinAggregateInputType
    _max?: OrganizationMemberMaxAggregateInputType
  }

  export type OrganizationMemberGroupByOutputType = {
    id: string
    organizationId: string
    userId: string
    role: $Enums.OrgRole
    permissions: JsonValue
    invitedBy: string | null
    joinedAt: Date
    _count: OrganizationMemberCountAggregateOutputType | null
    _min: OrganizationMemberMinAggregateOutputType | null
    _max: OrganizationMemberMaxAggregateOutputType | null
  }

  type GetOrganizationMemberGroupByPayload<T extends OrganizationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organizationMember"]>

  export type OrganizationMemberSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    invitedBy?: boolean
    joinedAt?: boolean
  }

  export type OrganizationMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "role" | "permissions" | "invitedBy" | "joinedAt", ExtArgs["result"]["organizationMember"]>
  export type OrganizationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrganizationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganizationMember"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      userId: string
      role: $Enums.OrgRole
      permissions: Prisma.JsonValue
      invitedBy: string | null
      joinedAt: Date
    }, ExtArgs["result"]["organizationMember"]>
    composites: {}
  }

  type OrganizationMemberGetPayload<S extends boolean | null | undefined | OrganizationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganizationMemberPayload, S>

  type OrganizationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationMemberCountAggregateInputType | true
    }

  export interface OrganizationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganizationMember'], meta: { name: 'OrganizationMember' } }
    /**
     * Find zero or one OrganizationMember that matches the filter.
     * @param {OrganizationMemberFindUniqueArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationMemberFindUniqueArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrganizationMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationMemberFindFirstArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrganizationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganizationMember
     * @example
     * // Get one OrganizationMember
     * const organizationMember = await prisma.organizationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrganizationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany()
     * 
     * // Get first 10 OrganizationMembers
     * const organizationMembers = await prisma.organizationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationMemberFindManyArgs>(args?: SelectSubset<T, OrganizationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrganizationMember.
     * @param {OrganizationMemberCreateArgs} args - Arguments to create a OrganizationMember.
     * @example
     * // Create one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.create({
     *   data: {
     *     // ... data to create a OrganizationMember
     *   }
     * })
     * 
     */
    create<T extends OrganizationMemberCreateArgs>(args: SelectSubset<T, OrganizationMemberCreateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrganizationMembers.
     * @param {OrganizationMemberCreateManyArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationMemberCreateManyArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrganizationMembers and returns the data saved in the database.
     * @param {OrganizationMemberCreateManyAndReturnArgs} args - Arguments to create many OrganizationMembers.
     * @example
     * // Create many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrganizationMember.
     * @param {OrganizationMemberDeleteArgs} args - Arguments to delete one OrganizationMember.
     * @example
     * // Delete one OrganizationMember
     * const OrganizationMember = await prisma.organizationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganizationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganizationMemberDeleteArgs>(args: SelectSubset<T, OrganizationMemberDeleteArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrganizationMember.
     * @param {OrganizationMemberUpdateArgs} args - Arguments to update one OrganizationMember.
     * @example
     * // Update one OrganizationMember
     * const organizationMember = await prisma.organizationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationMemberUpdateArgs>(args: SelectSubset<T, OrganizationMemberUpdateArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrganizationMembers.
     * @param {OrganizationMemberDeleteManyArgs} args - Arguments to filter OrganizationMembers to delete.
     * @example
     * // Delete a few OrganizationMembers
     * const { count } = await prisma.organizationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganizationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationMemberUpdateManyArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganizationMembers and returns the data updated in the database.
     * @param {OrganizationMemberUpdateManyAndReturnArgs} args - Arguments to update many OrganizationMembers.
     * @example
     * // Update many OrganizationMembers
     * const organizationMember = await prisma.organizationMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrganizationMembers and only return the `id`
     * const organizationMemberWithIdOnly = await prisma.organizationMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrganizationMember.
     * @param {OrganizationMemberUpsertArgs} args - Arguments to update or create a OrganizationMember.
     * @example
     * // Update or create a OrganizationMember
     * const organizationMember = await prisma.organizationMember.upsert({
     *   create: {
     *     // ... data to create a OrganizationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganizationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationMemberUpsertArgs>(args: SelectSubset<T, OrganizationMemberUpsertArgs<ExtArgs>>): Prisma__OrganizationMemberClient<$Result.GetResult<Prisma.$OrganizationMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrganizationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberCountArgs} args - Arguments to filter OrganizationMembers to count.
     * @example
     * // Count the number of OrganizationMembers
     * const count = await prisma.organizationMember.count({
     *   where: {
     *     // ... the filter for the OrganizationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganizationMemberCountArgs>(
      args?: Subset<T, OrganizationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationMemberAggregateArgs>(args: Subset<T, OrganizationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganizationMemberAggregateType<T>>

    /**
     * Group by OrganizationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganizationMember model
   */
  readonly fields: OrganizationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganizationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganizationMember model
   */
  interface OrganizationMemberFieldRefs {
    readonly id: FieldRef<"OrganizationMember", 'String'>
    readonly organizationId: FieldRef<"OrganizationMember", 'String'>
    readonly userId: FieldRef<"OrganizationMember", 'String'>
    readonly role: FieldRef<"OrganizationMember", 'OrgRole'>
    readonly permissions: FieldRef<"OrganizationMember", 'Json'>
    readonly invitedBy: FieldRef<"OrganizationMember", 'String'>
    readonly joinedAt: FieldRef<"OrganizationMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrganizationMember findUnique
   */
  export type OrganizationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findUniqueOrThrow
   */
  export type OrganizationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember findFirst
   */
  export type OrganizationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findFirstOrThrow
   */
  export type OrganizationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMember to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganizationMembers.
     */
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember findMany
   */
  export type OrganizationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganizationMembers to fetch.
     */
    where?: OrganizationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganizationMembers to fetch.
     */
    orderBy?: OrganizationMemberOrderByWithRelationInput | OrganizationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganizationMembers.
     */
    cursor?: OrganizationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganizationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganizationMembers.
     */
    skip?: number
    distinct?: OrganizationMemberScalarFieldEnum | OrganizationMemberScalarFieldEnum[]
  }

  /**
   * OrganizationMember create
   */
  export type OrganizationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganizationMember.
     */
    data: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
  }

  /**
   * OrganizationMember createMany
   */
  export type OrganizationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganizationMember createManyAndReturn
   */
  export type OrganizationMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to create many OrganizationMembers.
     */
    data: OrganizationMemberCreateManyInput | OrganizationMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember update
   */
  export type OrganizationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganizationMember.
     */
    data: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganizationMember to update.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember updateMany
   */
  export type OrganizationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
  }

  /**
   * OrganizationMember updateManyAndReturn
   */
  export type OrganizationMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * The data used to update OrganizationMembers.
     */
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganizationMembers to update
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrganizationMember upsert
   */
  export type OrganizationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganizationMember to update in case it exists.
     */
    where: OrganizationMemberWhereUniqueInput
    /**
     * In case the OrganizationMember found by the `where` argument doesn't exist, create a new OrganizationMember with this data.
     */
    create: XOR<OrganizationMemberCreateInput, OrganizationMemberUncheckedCreateInput>
    /**
     * In case the OrganizationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationMemberUpdateInput, OrganizationMemberUncheckedUpdateInput>
  }

  /**
   * OrganizationMember delete
   */
  export type OrganizationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganizationMember to delete.
     */
    where: OrganizationMemberWhereUniqueInput
  }

  /**
   * OrganizationMember deleteMany
   */
  export type OrganizationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganizationMembers to delete
     */
    where?: OrganizationMemberWhereInput
    /**
     * Limit how many OrganizationMembers to delete.
     */
    limit?: number
  }

  /**
   * OrganizationMember without action
   */
  export type OrganizationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationMember
     */
    select?: OrganizationMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrganizationMember
     */
    omit?: OrganizationMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationMemberInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    order: number | null
    defaultDepositPercentage: number | null
    minimumInsuranceAmount: number | null
  }

  export type CategorySumAggregateOutputType = {
    order: number | null
    defaultDepositPercentage: number | null
    minimumInsuranceAmount: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    iconUrl: string | null
    order: number | null
    active: boolean | null
    defaultPricingMode: $Enums.PricingMode | null
    allowInstantBook: boolean | null
    requiresDepositDefault: boolean | null
    defaultDepositPercentage: number | null
    insuranceRequired: boolean | null
    minimumInsuranceAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    iconUrl: string | null
    order: number | null
    active: boolean | null
    defaultPricingMode: $Enums.PricingMode | null
    allowInstantBook: boolean | null
    requiresDepositDefault: boolean | null
    defaultDepositPercentage: number | null
    insuranceRequired: boolean | null
    minimumInsuranceAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    iconUrl: number
    order: number
    active: number
    templateSchema: number
    searchableFields: number
    requiredFields: number
    defaultPricingMode: number
    allowInstantBook: number
    requiresDepositDefault: number
    defaultDepositPercentage: number
    insuranceRequired: number
    minimumInsuranceAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    order?: true
    defaultDepositPercentage?: true
    minimumInsuranceAmount?: true
  }

  export type CategorySumAggregateInputType = {
    order?: true
    defaultDepositPercentage?: true
    minimumInsuranceAmount?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    iconUrl?: true
    order?: true
    active?: true
    defaultPricingMode?: true
    allowInstantBook?: true
    requiresDepositDefault?: true
    defaultDepositPercentage?: true
    insuranceRequired?: true
    minimumInsuranceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    iconUrl?: true
    order?: true
    active?: true
    defaultPricingMode?: true
    allowInstantBook?: true
    requiresDepositDefault?: true
    defaultDepositPercentage?: true
    insuranceRequired?: true
    minimumInsuranceAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    iconUrl?: true
    order?: true
    active?: true
    templateSchema?: true
    searchableFields?: true
    requiredFields?: true
    defaultPricingMode?: true
    allowInstantBook?: true
    requiresDepositDefault?: true
    defaultDepositPercentage?: true
    insuranceRequired?: true
    minimumInsuranceAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    iconUrl: string | null
    order: number
    active: boolean
    templateSchema: JsonValue
    searchableFields: JsonValue
    requiredFields: JsonValue
    defaultPricingMode: $Enums.PricingMode
    allowInstantBook: boolean
    requiresDepositDefault: boolean
    defaultDepositPercentage: number
    insuranceRequired: boolean
    minimumInsuranceAmount: number | null
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    iconUrl?: boolean
    order?: boolean
    active?: boolean
    templateSchema?: boolean
    searchableFields?: boolean
    requiredFields?: boolean
    defaultPricingMode?: boolean
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: boolean
    insuranceRequired?: boolean
    minimumInsuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listings?: boolean | Category$listingsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    iconUrl?: boolean
    order?: boolean
    active?: boolean
    templateSchema?: boolean
    searchableFields?: boolean
    requiredFields?: boolean
    defaultPricingMode?: boolean
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: boolean
    insuranceRequired?: boolean
    minimumInsuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    iconUrl?: boolean
    order?: boolean
    active?: boolean
    templateSchema?: boolean
    searchableFields?: boolean
    requiredFields?: boolean
    defaultPricingMode?: boolean
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: boolean
    insuranceRequired?: boolean
    minimumInsuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    iconUrl?: boolean
    order?: boolean
    active?: boolean
    templateSchema?: boolean
    searchableFields?: boolean
    requiredFields?: boolean
    defaultPricingMode?: boolean
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: boolean
    insuranceRequired?: boolean
    minimumInsuranceAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "iconUrl" | "order" | "active" | "templateSchema" | "searchableFields" | "requiredFields" | "defaultPricingMode" | "allowInstantBook" | "requiresDepositDefault" | "defaultDepositPercentage" | "insuranceRequired" | "minimumInsuranceAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | Category$listingsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      iconUrl: string | null
      order: number
      active: boolean
      templateSchema: Prisma.JsonValue
      searchableFields: Prisma.JsonValue
      requiredFields: Prisma.JsonValue
      defaultPricingMode: $Enums.PricingMode
      allowInstantBook: boolean
      requiresDepositDefault: boolean
      defaultDepositPercentage: number
      insuranceRequired: boolean
      minimumInsuranceAmount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends Category$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Category$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
    readonly iconUrl: FieldRef<"Category", 'String'>
    readonly order: FieldRef<"Category", 'Int'>
    readonly active: FieldRef<"Category", 'Boolean'>
    readonly templateSchema: FieldRef<"Category", 'Json'>
    readonly searchableFields: FieldRef<"Category", 'Json'>
    readonly requiredFields: FieldRef<"Category", 'Json'>
    readonly defaultPricingMode: FieldRef<"Category", 'PricingMode'>
    readonly allowInstantBook: FieldRef<"Category", 'Boolean'>
    readonly requiresDepositDefault: FieldRef<"Category", 'Boolean'>
    readonly defaultDepositPercentage: FieldRef<"Category", 'Float'>
    readonly insuranceRequired: FieldRef<"Category", 'Boolean'>
    readonly minimumInsuranceAmount: FieldRef<"Category", 'Float'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.listings
   */
  export type Category$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Listing
   */

  export type AggregateListing = {
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  export type ListingAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    basePrice: number | null
    hourlyPrice: number | null
    dailyPrice: number | null
    weeklyPrice: number | null
    monthlyPrice: number | null
    depositAmount: number | null
    minBookingHours: number | null
    maxBookingDays: number | null
    leadTime: number | null
    advanceNotice: number | null
    capacity: number | null
    viewCount: number | null
    bookingCount: number | null
    favoriteCount: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type ListingSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    basePrice: number | null
    hourlyPrice: number | null
    dailyPrice: number | null
    weeklyPrice: number | null
    monthlyPrice: number | null
    depositAmount: number | null
    minBookingHours: number | null
    maxBookingDays: number | null
    leadTime: number | null
    advanceNotice: number | null
    capacity: number | null
    viewCount: number | null
    bookingCount: number | null
    favoriteCount: number | null
    averageRating: number | null
    totalReviews: number | null
  }

  export type ListingMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    organizationId: string | null
    categoryId: string | null
    title: string | null
    description: string | null
    slug: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    pricingMode: $Enums.PricingMode | null
    basePrice: number | null
    hourlyPrice: number | null
    dailyPrice: number | null
    weeklyPrice: number | null
    monthlyPrice: number | null
    currency: string | null
    requiresDeposit: boolean | null
    depositAmount: number | null
    depositType: $Enums.DepositType | null
    bookingMode: $Enums.BookingMode | null
    minBookingHours: number | null
    maxBookingDays: number | null
    leadTime: number | null
    advanceNotice: number | null
    capacity: number | null
    condition: $Enums.ListingCondition | null
    cancellationPolicyId: string | null
    insurancePolicyId: string | null
    insuranceVerified: boolean | null
    insuranceVerifiedAt: Date | null
    insuranceExpiresAt: Date | null
    status: $Enums.ListingStatus | null
    verificationStatus: $Enums.VerificationStatus | null
    rejectionReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    viewCount: number | null
    bookingCount: number | null
    favoriteCount: number | null
    averageRating: number | null
    totalReviews: number | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    deletedAt: Date | null
  }

  export type ListingMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    organizationId: string | null
    categoryId: string | null
    title: string | null
    description: string | null
    slug: string | null
    addressLine1: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    pricingMode: $Enums.PricingMode | null
    basePrice: number | null
    hourlyPrice: number | null
    dailyPrice: number | null
    weeklyPrice: number | null
    monthlyPrice: number | null
    currency: string | null
    requiresDeposit: boolean | null
    depositAmount: number | null
    depositType: $Enums.DepositType | null
    bookingMode: $Enums.BookingMode | null
    minBookingHours: number | null
    maxBookingDays: number | null
    leadTime: number | null
    advanceNotice: number | null
    capacity: number | null
    condition: $Enums.ListingCondition | null
    cancellationPolicyId: string | null
    insurancePolicyId: string | null
    insuranceVerified: boolean | null
    insuranceVerifiedAt: Date | null
    insuranceExpiresAt: Date | null
    status: $Enums.ListingStatus | null
    verificationStatus: $Enums.VerificationStatus | null
    rejectionReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    viewCount: number | null
    bookingCount: number | null
    favoriteCount: number | null
    averageRating: number | null
    totalReviews: number | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    deletedAt: Date | null
  }

  export type ListingCountAggregateOutputType = {
    id: number
    ownerId: number
    organizationId: number
    categoryId: number
    title: number
    description: number
    slug: number
    addressLine1: number
    addressLine2: number
    city: number
    state: number
    postalCode: number
    country: number
    latitude: number
    longitude: number
    photos: number
    videos: number
    documents: number
    pricingMode: number
    basePrice: number
    hourlyPrice: number
    dailyPrice: number
    weeklyPrice: number
    monthlyPrice: number
    currency: number
    requiresDeposit: number
    depositAmount: number
    depositType: number
    bookingMode: number
    minBookingHours: number
    maxBookingDays: number
    leadTime: number
    advanceNotice: number
    capacity: number
    categorySpecificData: number
    condition: number
    features: number
    amenities: number
    cancellationPolicyId: number
    rules: number
    insurancePolicyId: number
    insuranceVerified: number
    insuranceVerifiedAt: number
    insuranceExpiresAt: number
    status: number
    verificationStatus: number
    rejectionReason: number
    moderatedBy: number
    moderatedAt: number
    viewCount: number
    bookingCount: number
    favoriteCount: number
    averageRating: number
    totalReviews: number
    metaTitle: number
    metaDescription: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    deletedAt: number
    _all: number
  }


  export type ListingAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    basePrice?: true
    hourlyPrice?: true
    dailyPrice?: true
    weeklyPrice?: true
    monthlyPrice?: true
    depositAmount?: true
    minBookingHours?: true
    maxBookingDays?: true
    leadTime?: true
    advanceNotice?: true
    capacity?: true
    viewCount?: true
    bookingCount?: true
    favoriteCount?: true
    averageRating?: true
    totalReviews?: true
  }

  export type ListingSumAggregateInputType = {
    latitude?: true
    longitude?: true
    basePrice?: true
    hourlyPrice?: true
    dailyPrice?: true
    weeklyPrice?: true
    monthlyPrice?: true
    depositAmount?: true
    minBookingHours?: true
    maxBookingDays?: true
    leadTime?: true
    advanceNotice?: true
    capacity?: true
    viewCount?: true
    bookingCount?: true
    favoriteCount?: true
    averageRating?: true
    totalReviews?: true
  }

  export type ListingMinAggregateInputType = {
    id?: true
    ownerId?: true
    organizationId?: true
    categoryId?: true
    title?: true
    description?: true
    slug?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    latitude?: true
    longitude?: true
    pricingMode?: true
    basePrice?: true
    hourlyPrice?: true
    dailyPrice?: true
    weeklyPrice?: true
    monthlyPrice?: true
    currency?: true
    requiresDeposit?: true
    depositAmount?: true
    depositType?: true
    bookingMode?: true
    minBookingHours?: true
    maxBookingDays?: true
    leadTime?: true
    advanceNotice?: true
    capacity?: true
    condition?: true
    cancellationPolicyId?: true
    insurancePolicyId?: true
    insuranceVerified?: true
    insuranceVerifiedAt?: true
    insuranceExpiresAt?: true
    status?: true
    verificationStatus?: true
    rejectionReason?: true
    moderatedBy?: true
    moderatedAt?: true
    viewCount?: true
    bookingCount?: true
    favoriteCount?: true
    averageRating?: true
    totalReviews?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
  }

  export type ListingMaxAggregateInputType = {
    id?: true
    ownerId?: true
    organizationId?: true
    categoryId?: true
    title?: true
    description?: true
    slug?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    latitude?: true
    longitude?: true
    pricingMode?: true
    basePrice?: true
    hourlyPrice?: true
    dailyPrice?: true
    weeklyPrice?: true
    monthlyPrice?: true
    currency?: true
    requiresDeposit?: true
    depositAmount?: true
    depositType?: true
    bookingMode?: true
    minBookingHours?: true
    maxBookingDays?: true
    leadTime?: true
    advanceNotice?: true
    capacity?: true
    condition?: true
    cancellationPolicyId?: true
    insurancePolicyId?: true
    insuranceVerified?: true
    insuranceVerifiedAt?: true
    insuranceExpiresAt?: true
    status?: true
    verificationStatus?: true
    rejectionReason?: true
    moderatedBy?: true
    moderatedAt?: true
    viewCount?: true
    bookingCount?: true
    favoriteCount?: true
    averageRating?: true
    totalReviews?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
  }

  export type ListingCountAggregateInputType = {
    id?: true
    ownerId?: true
    organizationId?: true
    categoryId?: true
    title?: true
    description?: true
    slug?: true
    addressLine1?: true
    addressLine2?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    latitude?: true
    longitude?: true
    photos?: true
    videos?: true
    documents?: true
    pricingMode?: true
    basePrice?: true
    hourlyPrice?: true
    dailyPrice?: true
    weeklyPrice?: true
    monthlyPrice?: true
    currency?: true
    requiresDeposit?: true
    depositAmount?: true
    depositType?: true
    bookingMode?: true
    minBookingHours?: true
    maxBookingDays?: true
    leadTime?: true
    advanceNotice?: true
    capacity?: true
    categorySpecificData?: true
    condition?: true
    features?: true
    amenities?: true
    cancellationPolicyId?: true
    rules?: true
    insurancePolicyId?: true
    insuranceVerified?: true
    insuranceVerifiedAt?: true
    insuranceExpiresAt?: true
    status?: true
    verificationStatus?: true
    rejectionReason?: true
    moderatedBy?: true
    moderatedAt?: true
    viewCount?: true
    bookingCount?: true
    favoriteCount?: true
    averageRating?: true
    totalReviews?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listing to aggregate.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Listings
    **/
    _count?: true | ListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingMaxAggregateInputType
  }

  export type GetListingAggregateType<T extends ListingAggregateArgs> = {
        [P in keyof T & keyof AggregateListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing[P]>
      : GetScalarType<T[P], AggregateListing[P]>
  }




  export type ListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithAggregationInput | ListingOrderByWithAggregationInput[]
    by: ListingScalarFieldEnum[] | ListingScalarFieldEnum
    having?: ListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingCountAggregateInputType | true
    _avg?: ListingAvgAggregateInputType
    _sum?: ListingSumAggregateInputType
    _min?: ListingMinAggregateInputType
    _max?: ListingMaxAggregateInputType
  }

  export type ListingGroupByOutputType = {
    id: string
    ownerId: string
    organizationId: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1: string | null
    addressLine2: string | null
    city: string
    state: string
    postalCode: string | null
    country: string
    latitude: number
    longitude: number
    photos: JsonValue
    videos: JsonValue
    documents: JsonValue
    pricingMode: $Enums.PricingMode
    basePrice: number
    hourlyPrice: number | null
    dailyPrice: number | null
    weeklyPrice: number | null
    monthlyPrice: number | null
    currency: string
    requiresDeposit: boolean
    depositAmount: number | null
    depositType: $Enums.DepositType | null
    bookingMode: $Enums.BookingMode
    minBookingHours: number | null
    maxBookingDays: number | null
    leadTime: number
    advanceNotice: number
    capacity: number | null
    categorySpecificData: JsonValue
    condition: $Enums.ListingCondition | null
    features: JsonValue
    amenities: JsonValue
    cancellationPolicyId: string | null
    rules: JsonValue
    insurancePolicyId: string | null
    insuranceVerified: boolean
    insuranceVerifiedAt: Date | null
    insuranceExpiresAt: Date | null
    status: $Enums.ListingStatus
    verificationStatus: $Enums.VerificationStatus
    rejectionReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    viewCount: number
    bookingCount: number
    favoriteCount: number
    averageRating: number
    totalReviews: number
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    deletedAt: Date | null
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  type GetListingGroupByPayload<T extends ListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingGroupByOutputType[P]>
            : GetScalarType<T[P], ListingGroupByOutputType[P]>
        }
      >
    >


  export type ListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    organizationId?: boolean
    categoryId?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    photos?: boolean
    videos?: boolean
    documents?: boolean
    pricingMode?: boolean
    basePrice?: boolean
    hourlyPrice?: boolean
    dailyPrice?: boolean
    weeklyPrice?: boolean
    monthlyPrice?: boolean
    currency?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    depositType?: boolean
    bookingMode?: boolean
    minBookingHours?: boolean
    maxBookingDays?: boolean
    leadTime?: boolean
    advanceNotice?: boolean
    capacity?: boolean
    categorySpecificData?: boolean
    condition?: boolean
    features?: boolean
    amenities?: boolean
    cancellationPolicyId?: boolean
    rules?: boolean
    insurancePolicyId?: boolean
    insuranceVerified?: boolean
    insuranceVerifiedAt?: boolean
    insuranceExpiresAt?: boolean
    status?: boolean
    verificationStatus?: boolean
    rejectionReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    viewCount?: boolean
    bookingCount?: boolean
    favoriteCount?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
    availability?: boolean | Listing$availabilityArgs<ExtArgs>
    bookings?: boolean | Listing$bookingsArgs<ExtArgs>
    reviews?: boolean | Listing$reviewsArgs<ExtArgs>
    favorites?: boolean | Listing$favoritesArgs<ExtArgs>
    insurancePolicies?: boolean | Listing$insurancePoliciesArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    organizationId?: boolean
    categoryId?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    photos?: boolean
    videos?: boolean
    documents?: boolean
    pricingMode?: boolean
    basePrice?: boolean
    hourlyPrice?: boolean
    dailyPrice?: boolean
    weeklyPrice?: boolean
    monthlyPrice?: boolean
    currency?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    depositType?: boolean
    bookingMode?: boolean
    minBookingHours?: boolean
    maxBookingDays?: boolean
    leadTime?: boolean
    advanceNotice?: boolean
    capacity?: boolean
    categorySpecificData?: boolean
    condition?: boolean
    features?: boolean
    amenities?: boolean
    cancellationPolicyId?: boolean
    rules?: boolean
    insurancePolicyId?: boolean
    insuranceVerified?: boolean
    insuranceVerifiedAt?: boolean
    insuranceExpiresAt?: boolean
    status?: boolean
    verificationStatus?: boolean
    rejectionReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    viewCount?: boolean
    bookingCount?: boolean
    favoriteCount?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    organizationId?: boolean
    categoryId?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    photos?: boolean
    videos?: boolean
    documents?: boolean
    pricingMode?: boolean
    basePrice?: boolean
    hourlyPrice?: boolean
    dailyPrice?: boolean
    weeklyPrice?: boolean
    monthlyPrice?: boolean
    currency?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    depositType?: boolean
    bookingMode?: boolean
    minBookingHours?: boolean
    maxBookingDays?: boolean
    leadTime?: boolean
    advanceNotice?: boolean
    capacity?: boolean
    categorySpecificData?: boolean
    condition?: boolean
    features?: boolean
    amenities?: boolean
    cancellationPolicyId?: boolean
    rules?: boolean
    insurancePolicyId?: boolean
    insuranceVerified?: boolean
    insuranceVerifiedAt?: boolean
    insuranceExpiresAt?: boolean
    status?: boolean
    verificationStatus?: boolean
    rejectionReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    viewCount?: boolean
    bookingCount?: boolean
    favoriteCount?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectScalar = {
    id?: boolean
    ownerId?: boolean
    organizationId?: boolean
    categoryId?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    addressLine1?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    photos?: boolean
    videos?: boolean
    documents?: boolean
    pricingMode?: boolean
    basePrice?: boolean
    hourlyPrice?: boolean
    dailyPrice?: boolean
    weeklyPrice?: boolean
    monthlyPrice?: boolean
    currency?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    depositType?: boolean
    bookingMode?: boolean
    minBookingHours?: boolean
    maxBookingDays?: boolean
    leadTime?: boolean
    advanceNotice?: boolean
    capacity?: boolean
    categorySpecificData?: boolean
    condition?: boolean
    features?: boolean
    amenities?: boolean
    cancellationPolicyId?: boolean
    rules?: boolean
    insurancePolicyId?: boolean
    insuranceVerified?: boolean
    insuranceVerifiedAt?: boolean
    insuranceExpiresAt?: boolean
    status?: boolean
    verificationStatus?: boolean
    rejectionReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    viewCount?: boolean
    bookingCount?: boolean
    favoriteCount?: boolean
    averageRating?: boolean
    totalReviews?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
  }

  export type ListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "organizationId" | "categoryId" | "title" | "description" | "slug" | "addressLine1" | "addressLine2" | "city" | "state" | "postalCode" | "country" | "latitude" | "longitude" | "photos" | "videos" | "documents" | "pricingMode" | "basePrice" | "hourlyPrice" | "dailyPrice" | "weeklyPrice" | "monthlyPrice" | "currency" | "requiresDeposit" | "depositAmount" | "depositType" | "bookingMode" | "minBookingHours" | "maxBookingDays" | "leadTime" | "advanceNotice" | "capacity" | "categorySpecificData" | "condition" | "features" | "amenities" | "cancellationPolicyId" | "rules" | "insurancePolicyId" | "insuranceVerified" | "insuranceVerifiedAt" | "insuranceExpiresAt" | "status" | "verificationStatus" | "rejectionReason" | "moderatedBy" | "moderatedAt" | "viewCount" | "bookingCount" | "favoriteCount" | "averageRating" | "totalReviews" | "metaTitle" | "metaDescription" | "createdAt" | "updatedAt" | "publishedAt" | "deletedAt", ExtArgs["result"]["listing"]>
  export type ListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
    availability?: boolean | Listing$availabilityArgs<ExtArgs>
    bookings?: boolean | Listing$bookingsArgs<ExtArgs>
    reviews?: boolean | Listing$reviewsArgs<ExtArgs>
    favorites?: boolean | Listing$favoritesArgs<ExtArgs>
    insurancePolicies?: boolean | Listing$insurancePoliciesArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
  }
  export type ListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | Listing$organizationArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    cancellationPolicy?: boolean | Listing$cancellationPolicyArgs<ExtArgs>
  }

  export type $ListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Listing"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
      category: Prisma.$CategoryPayload<ExtArgs>
      cancellationPolicy: Prisma.$CancellationPolicyPayload<ExtArgs> | null
      availability: Prisma.$AvailabilityPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      favorites: Prisma.$FavoriteListingPayload<ExtArgs>[]
      insurancePolicies: Prisma.$InsurancePolicyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      organizationId: string | null
      categoryId: string
      title: string
      description: string
      slug: string
      addressLine1: string | null
      addressLine2: string | null
      city: string
      state: string
      postalCode: string | null
      country: string
      latitude: number
      longitude: number
      photos: Prisma.JsonValue
      videos: Prisma.JsonValue
      documents: Prisma.JsonValue
      pricingMode: $Enums.PricingMode
      basePrice: number
      hourlyPrice: number | null
      dailyPrice: number | null
      weeklyPrice: number | null
      monthlyPrice: number | null
      currency: string
      requiresDeposit: boolean
      depositAmount: number | null
      depositType: $Enums.DepositType | null
      bookingMode: $Enums.BookingMode
      minBookingHours: number | null
      maxBookingDays: number | null
      leadTime: number
      advanceNotice: number
      capacity: number | null
      categorySpecificData: Prisma.JsonValue
      condition: $Enums.ListingCondition | null
      features: Prisma.JsonValue
      amenities: Prisma.JsonValue
      cancellationPolicyId: string | null
      rules: Prisma.JsonValue
      insurancePolicyId: string | null
      insuranceVerified: boolean
      insuranceVerifiedAt: Date | null
      insuranceExpiresAt: Date | null
      status: $Enums.ListingStatus
      verificationStatus: $Enums.VerificationStatus
      rejectionReason: string | null
      moderatedBy: string | null
      moderatedAt: Date | null
      viewCount: number
      bookingCount: number
      favoriteCount: number
      averageRating: number
      totalReviews: number
      metaTitle: string | null
      metaDescription: string | null
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["listing"]>
    composites: {}
  }

  type ListingGetPayload<S extends boolean | null | undefined | ListingDefaultArgs> = $Result.GetResult<Prisma.$ListingPayload, S>

  type ListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ListingCountAggregateInputType | true
    }

  export interface ListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Listing'], meta: { name: 'Listing' } }
    /**
     * Find zero or one Listing that matches the filter.
     * @param {ListingFindUniqueArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ListingFindUniqueArgs>(args: SelectSubset<T, ListingFindUniqueArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Listing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ListingFindUniqueOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ListingFindUniqueOrThrowArgs>(args: SelectSubset<T, ListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Listing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ListingFindFirstArgs>(args?: SelectSubset<T, ListingFindFirstArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Listing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ListingFindFirstOrThrowArgs>(args?: SelectSubset<T, ListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Listings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listings
     * const listings = await prisma.listing.findMany()
     * 
     * // Get first 10 Listings
     * const listings = await prisma.listing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingWithIdOnly = await prisma.listing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ListingFindManyArgs>(args?: SelectSubset<T, ListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Listing.
     * @param {ListingCreateArgs} args - Arguments to create a Listing.
     * @example
     * // Create one Listing
     * const Listing = await prisma.listing.create({
     *   data: {
     *     // ... data to create a Listing
     *   }
     * })
     * 
     */
    create<T extends ListingCreateArgs>(args: SelectSubset<T, ListingCreateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Listings.
     * @param {ListingCreateManyArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ListingCreateManyArgs>(args?: SelectSubset<T, ListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Listings and returns the data saved in the database.
     * @param {ListingCreateManyAndReturnArgs} args - Arguments to create many Listings.
     * @example
     * // Create many Listings
     * const listing = await prisma.listing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ListingCreateManyAndReturnArgs>(args?: SelectSubset<T, ListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Listing.
     * @param {ListingDeleteArgs} args - Arguments to delete one Listing.
     * @example
     * // Delete one Listing
     * const Listing = await prisma.listing.delete({
     *   where: {
     *     // ... filter to delete one Listing
     *   }
     * })
     * 
     */
    delete<T extends ListingDeleteArgs>(args: SelectSubset<T, ListingDeleteArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Listing.
     * @param {ListingUpdateArgs} args - Arguments to update one Listing.
     * @example
     * // Update one Listing
     * const listing = await prisma.listing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ListingUpdateArgs>(args: SelectSubset<T, ListingUpdateArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Listings.
     * @param {ListingDeleteManyArgs} args - Arguments to filter Listings to delete.
     * @example
     * // Delete a few Listings
     * const { count } = await prisma.listing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ListingDeleteManyArgs>(args?: SelectSubset<T, ListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ListingUpdateManyArgs>(args: SelectSubset<T, ListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings and returns the data updated in the database.
     * @param {ListingUpdateManyAndReturnArgs} args - Arguments to update many Listings.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Listings and only return the `id`
     * const listingWithIdOnly = await prisma.listing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ListingUpdateManyAndReturnArgs>(args: SelectSubset<T, ListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Listing.
     * @param {ListingUpsertArgs} args - Arguments to update or create a Listing.
     * @example
     * // Update or create a Listing
     * const listing = await prisma.listing.upsert({
     *   create: {
     *     // ... data to create a Listing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing we want to update
     *   }
     * })
     */
    upsert<T extends ListingUpsertArgs>(args: SelectSubset<T, ListingUpsertArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingCountArgs} args - Arguments to filter Listings to count.
     * @example
     * // Count the number of Listings
     * const count = await prisma.listing.count({
     *   where: {
     *     // ... the filter for the Listings we want to count
     *   }
     * })
    **/
    count<T extends ListingCountArgs>(
      args?: Subset<T, ListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingAggregateArgs>(args: Subset<T, ListingAggregateArgs>): Prisma.PrismaPromise<GetListingAggregateType<T>>

    /**
     * Group by Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingGroupByArgs['orderBy'] }
        : { orderBy?: ListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Listing model
   */
  readonly fields: ListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Listing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends Listing$organizationArgs<ExtArgs> = {}>(args?: Subset<T, Listing$organizationArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    cancellationPolicy<T extends Listing$cancellationPolicyArgs<ExtArgs> = {}>(args?: Subset<T, Listing$cancellationPolicyArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    availability<T extends Listing$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Listing$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Listing$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Listing$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    favorites<T extends Listing$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insurancePolicies<T extends Listing$insurancePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$insurancePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Listing model
   */
  interface ListingFieldRefs {
    readonly id: FieldRef<"Listing", 'String'>
    readonly ownerId: FieldRef<"Listing", 'String'>
    readonly organizationId: FieldRef<"Listing", 'String'>
    readonly categoryId: FieldRef<"Listing", 'String'>
    readonly title: FieldRef<"Listing", 'String'>
    readonly description: FieldRef<"Listing", 'String'>
    readonly slug: FieldRef<"Listing", 'String'>
    readonly addressLine1: FieldRef<"Listing", 'String'>
    readonly addressLine2: FieldRef<"Listing", 'String'>
    readonly city: FieldRef<"Listing", 'String'>
    readonly state: FieldRef<"Listing", 'String'>
    readonly postalCode: FieldRef<"Listing", 'String'>
    readonly country: FieldRef<"Listing", 'String'>
    readonly latitude: FieldRef<"Listing", 'Float'>
    readonly longitude: FieldRef<"Listing", 'Float'>
    readonly photos: FieldRef<"Listing", 'Json'>
    readonly videos: FieldRef<"Listing", 'Json'>
    readonly documents: FieldRef<"Listing", 'Json'>
    readonly pricingMode: FieldRef<"Listing", 'PricingMode'>
    readonly basePrice: FieldRef<"Listing", 'Float'>
    readonly hourlyPrice: FieldRef<"Listing", 'Float'>
    readonly dailyPrice: FieldRef<"Listing", 'Float'>
    readonly weeklyPrice: FieldRef<"Listing", 'Float'>
    readonly monthlyPrice: FieldRef<"Listing", 'Float'>
    readonly currency: FieldRef<"Listing", 'String'>
    readonly requiresDeposit: FieldRef<"Listing", 'Boolean'>
    readonly depositAmount: FieldRef<"Listing", 'Float'>
    readonly depositType: FieldRef<"Listing", 'DepositType'>
    readonly bookingMode: FieldRef<"Listing", 'BookingMode'>
    readonly minBookingHours: FieldRef<"Listing", 'Int'>
    readonly maxBookingDays: FieldRef<"Listing", 'Int'>
    readonly leadTime: FieldRef<"Listing", 'Int'>
    readonly advanceNotice: FieldRef<"Listing", 'Int'>
    readonly capacity: FieldRef<"Listing", 'Int'>
    readonly categorySpecificData: FieldRef<"Listing", 'Json'>
    readonly condition: FieldRef<"Listing", 'ListingCondition'>
    readonly features: FieldRef<"Listing", 'Json'>
    readonly amenities: FieldRef<"Listing", 'Json'>
    readonly cancellationPolicyId: FieldRef<"Listing", 'String'>
    readonly rules: FieldRef<"Listing", 'Json'>
    readonly insurancePolicyId: FieldRef<"Listing", 'String'>
    readonly insuranceVerified: FieldRef<"Listing", 'Boolean'>
    readonly insuranceVerifiedAt: FieldRef<"Listing", 'DateTime'>
    readonly insuranceExpiresAt: FieldRef<"Listing", 'DateTime'>
    readonly status: FieldRef<"Listing", 'ListingStatus'>
    readonly verificationStatus: FieldRef<"Listing", 'VerificationStatus'>
    readonly rejectionReason: FieldRef<"Listing", 'String'>
    readonly moderatedBy: FieldRef<"Listing", 'String'>
    readonly moderatedAt: FieldRef<"Listing", 'DateTime'>
    readonly viewCount: FieldRef<"Listing", 'Int'>
    readonly bookingCount: FieldRef<"Listing", 'Int'>
    readonly favoriteCount: FieldRef<"Listing", 'Int'>
    readonly averageRating: FieldRef<"Listing", 'Float'>
    readonly totalReviews: FieldRef<"Listing", 'Int'>
    readonly metaTitle: FieldRef<"Listing", 'String'>
    readonly metaDescription: FieldRef<"Listing", 'String'>
    readonly createdAt: FieldRef<"Listing", 'DateTime'>
    readonly updatedAt: FieldRef<"Listing", 'DateTime'>
    readonly publishedAt: FieldRef<"Listing", 'DateTime'>
    readonly deletedAt: FieldRef<"Listing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Listing findUnique
   */
  export type ListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findUniqueOrThrow
   */
  export type ListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing findFirst
   */
  export type ListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findFirstOrThrow
   */
  export type ListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing findMany
   */
  export type ListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listings to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * Listing create
   */
  export type ListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to create a Listing.
     */
    data: XOR<ListingCreateInput, ListingUncheckedCreateInput>
  }

  /**
   * Listing createMany
   */
  export type ListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Listing createManyAndReturn
   */
  export type ListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing update
   */
  export type ListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to update a Listing.
     */
    data: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
    /**
     * Choose, which Listing to update.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing updateMany
   */
  export type ListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to update.
     */
    limit?: number
  }

  /**
   * Listing updateManyAndReturn
   */
  export type ListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Listing upsert
   */
  export type ListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The filter to search for the Listing to update in case it exists.
     */
    where: ListingWhereUniqueInput
    /**
     * In case the Listing found by the `where` argument doesn't exist, create a new Listing with this data.
     */
    create: XOR<ListingCreateInput, ListingUncheckedCreateInput>
    /**
     * In case the Listing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
  }

  /**
   * Listing delete
   */
  export type ListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter which Listing to delete.
     */
    where: ListingWhereUniqueInput
  }

  /**
   * Listing deleteMany
   */
  export type ListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listings to delete
     */
    where?: ListingWhereInput
    /**
     * Limit how many Listings to delete.
     */
    limit?: number
  }

  /**
   * Listing.organization
   */
  export type Listing$organizationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    where?: OrganizationWhereInput
  }

  /**
   * Listing.cancellationPolicy
   */
  export type Listing$cancellationPolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    where?: CancellationPolicyWhereInput
  }

  /**
   * Listing.availability
   */
  export type Listing$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    cursor?: AvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Listing.bookings
   */
  export type Listing$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Listing.reviews
   */
  export type Listing$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Listing.favorites
   */
  export type Listing$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    where?: FavoriteListingWhereInput
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    cursor?: FavoriteListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteListingScalarFieldEnum | FavoriteListingScalarFieldEnum[]
  }

  /**
   * Listing.insurancePolicies
   */
  export type Listing$insurancePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    where?: InsurancePolicyWhereInput
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    cursor?: InsurancePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsurancePolicyScalarFieldEnum | InsurancePolicyScalarFieldEnum[]
  }

  /**
   * Listing without action
   */
  export type ListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
  }


  /**
   * Model CancellationPolicy
   */

  export type AggregateCancellationPolicy = {
    _count: CancellationPolicyCountAggregateOutputType | null
    _min: CancellationPolicyMinAggregateOutputType | null
    _max: CancellationPolicyMaxAggregateOutputType | null
  }

  export type CancellationPolicyMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CancellationPolicyType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationPolicyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.CancellationPolicyType | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationPolicyCountAggregateOutputType = {
    id: number
    name: number
    type: number
    description: number
    rules: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CancellationPolicyMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationPolicyMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationPolicyCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    description?: true
    rules?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CancellationPolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationPolicy to aggregate.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CancellationPolicies
    **/
    _count?: true | CancellationPolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationPolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationPolicyMaxAggregateInputType
  }

  export type GetCancellationPolicyAggregateType<T extends CancellationPolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellationPolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellationPolicy[P]>
      : GetScalarType<T[P], AggregateCancellationPolicy[P]>
  }




  export type CancellationPolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationPolicyWhereInput
    orderBy?: CancellationPolicyOrderByWithAggregationInput | CancellationPolicyOrderByWithAggregationInput[]
    by: CancellationPolicyScalarFieldEnum[] | CancellationPolicyScalarFieldEnum
    having?: CancellationPolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationPolicyCountAggregateInputType | true
    _min?: CancellationPolicyMinAggregateInputType
    _max?: CancellationPolicyMaxAggregateInputType
  }

  export type CancellationPolicyGroupByOutputType = {
    id: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CancellationPolicyCountAggregateOutputType | null
    _min: CancellationPolicyMinAggregateOutputType | null
    _max: CancellationPolicyMaxAggregateOutputType | null
  }

  type GetCancellationPolicyGroupByPayload<T extends CancellationPolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationPolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationPolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationPolicyGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationPolicyGroupByOutputType[P]>
        }
      >
    >


  export type CancellationPolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    listings?: boolean | CancellationPolicy$listingsArgs<ExtArgs>
    _count?: boolean | CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cancellationPolicy"]>

  export type CancellationPolicySelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    description?: boolean
    rules?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CancellationPolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "description" | "rules" | "createdAt" | "updatedAt", ExtArgs["result"]["cancellationPolicy"]>
  export type CancellationPolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listings?: boolean | CancellationPolicy$listingsArgs<ExtArgs>
    _count?: boolean | CancellationPolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CancellationPolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CancellationPolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CancellationPolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CancellationPolicy"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.CancellationPolicyType
      description: string
      rules: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cancellationPolicy"]>
    composites: {}
  }

  type CancellationPolicyGetPayload<S extends boolean | null | undefined | CancellationPolicyDefaultArgs> = $Result.GetResult<Prisma.$CancellationPolicyPayload, S>

  type CancellationPolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationPolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationPolicyCountAggregateInputType | true
    }

  export interface CancellationPolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CancellationPolicy'], meta: { name: 'CancellationPolicy' } }
    /**
     * Find zero or one CancellationPolicy that matches the filter.
     * @param {CancellationPolicyFindUniqueArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationPolicyFindUniqueArgs>(args: SelectSubset<T, CancellationPolicyFindUniqueArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CancellationPolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationPolicyFindUniqueOrThrowArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationPolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationPolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationPolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindFirstArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationPolicyFindFirstArgs>(args?: SelectSubset<T, CancellationPolicyFindFirstArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CancellationPolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindFirstOrThrowArgs} args - Arguments to find a CancellationPolicy
     * @example
     * // Get one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationPolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationPolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CancellationPolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CancellationPolicies
     * const cancellationPolicies = await prisma.cancellationPolicy.findMany()
     * 
     * // Get first 10 CancellationPolicies
     * const cancellationPolicies = await prisma.cancellationPolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationPolicyFindManyArgs>(args?: SelectSubset<T, CancellationPolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CancellationPolicy.
     * @param {CancellationPolicyCreateArgs} args - Arguments to create a CancellationPolicy.
     * @example
     * // Create one CancellationPolicy
     * const CancellationPolicy = await prisma.cancellationPolicy.create({
     *   data: {
     *     // ... data to create a CancellationPolicy
     *   }
     * })
     * 
     */
    create<T extends CancellationPolicyCreateArgs>(args: SelectSubset<T, CancellationPolicyCreateArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CancellationPolicies.
     * @param {CancellationPolicyCreateManyArgs} args - Arguments to create many CancellationPolicies.
     * @example
     * // Create many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationPolicyCreateManyArgs>(args?: SelectSubset<T, CancellationPolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CancellationPolicies and returns the data saved in the database.
     * @param {CancellationPolicyCreateManyAndReturnArgs} args - Arguments to create many CancellationPolicies.
     * @example
     * // Create many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CancellationPolicies and only return the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationPolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationPolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CancellationPolicy.
     * @param {CancellationPolicyDeleteArgs} args - Arguments to delete one CancellationPolicy.
     * @example
     * // Delete one CancellationPolicy
     * const CancellationPolicy = await prisma.cancellationPolicy.delete({
     *   where: {
     *     // ... filter to delete one CancellationPolicy
     *   }
     * })
     * 
     */
    delete<T extends CancellationPolicyDeleteArgs>(args: SelectSubset<T, CancellationPolicyDeleteArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CancellationPolicy.
     * @param {CancellationPolicyUpdateArgs} args - Arguments to update one CancellationPolicy.
     * @example
     * // Update one CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationPolicyUpdateArgs>(args: SelectSubset<T, CancellationPolicyUpdateArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CancellationPolicies.
     * @param {CancellationPolicyDeleteManyArgs} args - Arguments to filter CancellationPolicies to delete.
     * @example
     * // Delete a few CancellationPolicies
     * const { count } = await prisma.cancellationPolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationPolicyDeleteManyArgs>(args?: SelectSubset<T, CancellationPolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationPolicyUpdateManyArgs>(args: SelectSubset<T, CancellationPolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CancellationPolicies and returns the data updated in the database.
     * @param {CancellationPolicyUpdateManyAndReturnArgs} args - Arguments to update many CancellationPolicies.
     * @example
     * // Update many CancellationPolicies
     * const cancellationPolicy = await prisma.cancellationPolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CancellationPolicies and only return the `id`
     * const cancellationPolicyWithIdOnly = await prisma.cancellationPolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationPolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationPolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CancellationPolicy.
     * @param {CancellationPolicyUpsertArgs} args - Arguments to update or create a CancellationPolicy.
     * @example
     * // Update or create a CancellationPolicy
     * const cancellationPolicy = await prisma.cancellationPolicy.upsert({
     *   create: {
     *     // ... data to create a CancellationPolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CancellationPolicy we want to update
     *   }
     * })
     */
    upsert<T extends CancellationPolicyUpsertArgs>(args: SelectSubset<T, CancellationPolicyUpsertArgs<ExtArgs>>): Prisma__CancellationPolicyClient<$Result.GetResult<Prisma.$CancellationPolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CancellationPolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyCountArgs} args - Arguments to filter CancellationPolicies to count.
     * @example
     * // Count the number of CancellationPolicies
     * const count = await prisma.cancellationPolicy.count({
     *   where: {
     *     // ... the filter for the CancellationPolicies we want to count
     *   }
     * })
    **/
    count<T extends CancellationPolicyCountArgs>(
      args?: Subset<T, CancellationPolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationPolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CancellationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationPolicyAggregateArgs>(args: Subset<T, CancellationPolicyAggregateArgs>): Prisma.PrismaPromise<GetCancellationPolicyAggregateType<T>>

    /**
     * Group by CancellationPolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationPolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationPolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationPolicyGroupByArgs['orderBy'] }
        : { orderBy?: CancellationPolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationPolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationPolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CancellationPolicy model
   */
  readonly fields: CancellationPolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CancellationPolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationPolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listings<T extends CancellationPolicy$listingsArgs<ExtArgs> = {}>(args?: Subset<T, CancellationPolicy$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CancellationPolicy model
   */
  interface CancellationPolicyFieldRefs {
    readonly id: FieldRef<"CancellationPolicy", 'String'>
    readonly name: FieldRef<"CancellationPolicy", 'String'>
    readonly type: FieldRef<"CancellationPolicy", 'CancellationPolicyType'>
    readonly description: FieldRef<"CancellationPolicy", 'String'>
    readonly rules: FieldRef<"CancellationPolicy", 'Json'>
    readonly createdAt: FieldRef<"CancellationPolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"CancellationPolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CancellationPolicy findUnique
   */
  export type CancellationPolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy findUniqueOrThrow
   */
  export type CancellationPolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy findFirst
   */
  export type CancellationPolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationPolicies.
     */
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy findFirstOrThrow
   */
  export type CancellationPolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicy to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CancellationPolicies.
     */
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy findMany
   */
  export type CancellationPolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter, which CancellationPolicies to fetch.
     */
    where?: CancellationPolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CancellationPolicies to fetch.
     */
    orderBy?: CancellationPolicyOrderByWithRelationInput | CancellationPolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CancellationPolicies.
     */
    cursor?: CancellationPolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CancellationPolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CancellationPolicies.
     */
    skip?: number
    distinct?: CancellationPolicyScalarFieldEnum | CancellationPolicyScalarFieldEnum[]
  }

  /**
   * CancellationPolicy create
   */
  export type CancellationPolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a CancellationPolicy.
     */
    data: XOR<CancellationPolicyCreateInput, CancellationPolicyUncheckedCreateInput>
  }

  /**
   * CancellationPolicy createMany
   */
  export type CancellationPolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CancellationPolicies.
     */
    data: CancellationPolicyCreateManyInput | CancellationPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CancellationPolicy createManyAndReturn
   */
  export type CancellationPolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * The data used to create many CancellationPolicies.
     */
    data: CancellationPolicyCreateManyInput | CancellationPolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CancellationPolicy update
   */
  export type CancellationPolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a CancellationPolicy.
     */
    data: XOR<CancellationPolicyUpdateInput, CancellationPolicyUncheckedUpdateInput>
    /**
     * Choose, which CancellationPolicy to update.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy updateMany
   */
  export type CancellationPolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CancellationPolicies.
     */
    data: XOR<CancellationPolicyUpdateManyMutationInput, CancellationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which CancellationPolicies to update
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to update.
     */
    limit?: number
  }

  /**
   * CancellationPolicy updateManyAndReturn
   */
  export type CancellationPolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * The data used to update CancellationPolicies.
     */
    data: XOR<CancellationPolicyUpdateManyMutationInput, CancellationPolicyUncheckedUpdateManyInput>
    /**
     * Filter which CancellationPolicies to update
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to update.
     */
    limit?: number
  }

  /**
   * CancellationPolicy upsert
   */
  export type CancellationPolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the CancellationPolicy to update in case it exists.
     */
    where: CancellationPolicyWhereUniqueInput
    /**
     * In case the CancellationPolicy found by the `where` argument doesn't exist, create a new CancellationPolicy with this data.
     */
    create: XOR<CancellationPolicyCreateInput, CancellationPolicyUncheckedCreateInput>
    /**
     * In case the CancellationPolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationPolicyUpdateInput, CancellationPolicyUncheckedUpdateInput>
  }

  /**
   * CancellationPolicy delete
   */
  export type CancellationPolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
    /**
     * Filter which CancellationPolicy to delete.
     */
    where: CancellationPolicyWhereUniqueInput
  }

  /**
   * CancellationPolicy deleteMany
   */
  export type CancellationPolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CancellationPolicies to delete
     */
    where?: CancellationPolicyWhereInput
    /**
     * Limit how many CancellationPolicies to delete.
     */
    limit?: number
  }

  /**
   * CancellationPolicy.listings
   */
  export type CancellationPolicy$listingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }

  /**
   * CancellationPolicy without action
   */
  export type CancellationPolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CancellationPolicy
     */
    select?: CancellationPolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CancellationPolicy
     */
    omit?: CancellationPolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationPolicyInclude<ExtArgs> | null
  }


  /**
   * Model Availability
   */

  export type AggregateAvailability = {
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  export type AvailabilityAvgAggregateOutputType = {
    price: number | null
    minStay: number | null
  }

  export type AvailabilitySumAggregateOutputType = {
    price: number | null
    minStay: number | null
  }

  export type AvailabilityMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    startDate: Date | null
    endDate: Date | null
    available: boolean | null
    price: number | null
    minStay: number | null
    createdAt: Date | null
  }

  export type AvailabilityMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    startDate: Date | null
    endDate: Date | null
    available: boolean | null
    price: number | null
    minStay: number | null
    createdAt: Date | null
  }

  export type AvailabilityCountAggregateOutputType = {
    id: number
    listingId: number
    startDate: number
    endDate: number
    available: number
    price: number
    minStay: number
    createdAt: number
    _all: number
  }


  export type AvailabilityAvgAggregateInputType = {
    price?: true
    minStay?: true
  }

  export type AvailabilitySumAggregateInputType = {
    price?: true
    minStay?: true
  }

  export type AvailabilityMinAggregateInputType = {
    id?: true
    listingId?: true
    startDate?: true
    endDate?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
  }

  export type AvailabilityMaxAggregateInputType = {
    id?: true
    listingId?: true
    startDate?: true
    endDate?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
  }

  export type AvailabilityCountAggregateInputType = {
    id?: true
    listingId?: true
    startDate?: true
    endDate?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
    _all?: true
  }

  export type AvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availability to aggregate.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Availabilities
    **/
    _count?: true | AvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AvailabilityMaxAggregateInputType
  }

  export type GetAvailabilityAggregateType<T extends AvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAvailability[P]>
      : GetScalarType<T[P], AggregateAvailability[P]>
  }




  export type AvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AvailabilityWhereInput
    orderBy?: AvailabilityOrderByWithAggregationInput | AvailabilityOrderByWithAggregationInput[]
    by: AvailabilityScalarFieldEnum[] | AvailabilityScalarFieldEnum
    having?: AvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AvailabilityCountAggregateInputType | true
    _avg?: AvailabilityAvgAggregateInputType
    _sum?: AvailabilitySumAggregateInputType
    _min?: AvailabilityMinAggregateInputType
    _max?: AvailabilityMaxAggregateInputType
  }

  export type AvailabilityGroupByOutputType = {
    id: string
    listingId: string
    startDate: Date
    endDate: Date
    available: boolean
    price: number | null
    minStay: number | null
    createdAt: Date
    _count: AvailabilityCountAggregateOutputType | null
    _avg: AvailabilityAvgAggregateOutputType | null
    _sum: AvailabilitySumAggregateOutputType | null
    _min: AvailabilityMinAggregateOutputType | null
    _max: AvailabilityMaxAggregateOutputType | null
  }

  type GetAvailabilityGroupByPayload<T extends AvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], AvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type AvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    startDate?: boolean
    endDate?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    startDate?: boolean
    endDate?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    startDate?: boolean
    endDate?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["availability"]>

  export type AvailabilitySelectScalar = {
    id?: boolean
    listingId?: boolean
    startDate?: boolean
    endDate?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
  }

  export type AvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "startDate" | "endDate" | "available" | "price" | "minStay" | "createdAt", ExtArgs["result"]["availability"]>
  export type AvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type AvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }

  export type $AvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Availability"
    objects: {
      listing: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      startDate: Date
      endDate: Date
      available: boolean
      price: number | null
      minStay: number | null
      createdAt: Date
    }, ExtArgs["result"]["availability"]>
    composites: {}
  }

  type AvailabilityGetPayload<S extends boolean | null | undefined | AvailabilityDefaultArgs> = $Result.GetResult<Prisma.$AvailabilityPayload, S>

  type AvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AvailabilityCountAggregateInputType | true
    }

  export interface AvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Availability'], meta: { name: 'Availability' } }
    /**
     * Find zero or one Availability that matches the filter.
     * @param {AvailabilityFindUniqueArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AvailabilityFindUniqueArgs>(args: SelectSubset<T, AvailabilityFindUniqueArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AvailabilityFindUniqueOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, AvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AvailabilityFindFirstArgs>(args?: SelectSubset<T, AvailabilityFindFirstArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindFirstOrThrowArgs} args - Arguments to find a Availability
     * @example
     * // Get one Availability
     * const availability = await prisma.availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, AvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Availabilities
     * const availabilities = await prisma.availability.findMany()
     * 
     * // Get first 10 Availabilities
     * const availabilities = await prisma.availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const availabilityWithIdOnly = await prisma.availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AvailabilityFindManyArgs>(args?: SelectSubset<T, AvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Availability.
     * @param {AvailabilityCreateArgs} args - Arguments to create a Availability.
     * @example
     * // Create one Availability
     * const Availability = await prisma.availability.create({
     *   data: {
     *     // ... data to create a Availability
     *   }
     * })
     * 
     */
    create<T extends AvailabilityCreateArgs>(args: SelectSubset<T, AvailabilityCreateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Availabilities.
     * @param {AvailabilityCreateManyArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AvailabilityCreateManyArgs>(args?: SelectSubset<T, AvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Availabilities and returns the data saved in the database.
     * @param {AvailabilityCreateManyAndReturnArgs} args - Arguments to create many Availabilities.
     * @example
     * // Create many Availabilities
     * const availability = await prisma.availability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, AvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Availability.
     * @param {AvailabilityDeleteArgs} args - Arguments to delete one Availability.
     * @example
     * // Delete one Availability
     * const Availability = await prisma.availability.delete({
     *   where: {
     *     // ... filter to delete one Availability
     *   }
     * })
     * 
     */
    delete<T extends AvailabilityDeleteArgs>(args: SelectSubset<T, AvailabilityDeleteArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Availability.
     * @param {AvailabilityUpdateArgs} args - Arguments to update one Availability.
     * @example
     * // Update one Availability
     * const availability = await prisma.availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AvailabilityUpdateArgs>(args: SelectSubset<T, AvailabilityUpdateArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Availabilities.
     * @param {AvailabilityDeleteManyArgs} args - Arguments to filter Availabilities to delete.
     * @example
     * // Delete a few Availabilities
     * const { count } = await prisma.availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AvailabilityDeleteManyArgs>(args?: SelectSubset<T, AvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AvailabilityUpdateManyArgs>(args: SelectSubset<T, AvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Availabilities and returns the data updated in the database.
     * @param {AvailabilityUpdateManyAndReturnArgs} args - Arguments to update many Availabilities.
     * @example
     * // Update many Availabilities
     * const availability = await prisma.availability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Availabilities and only return the `id`
     * const availabilityWithIdOnly = await prisma.availability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, AvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Availability.
     * @param {AvailabilityUpsertArgs} args - Arguments to update or create a Availability.
     * @example
     * // Update or create a Availability
     * const availability = await prisma.availability.upsert({
     *   create: {
     *     // ... data to create a Availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Availability we want to update
     *   }
     * })
     */
    upsert<T extends AvailabilityUpsertArgs>(args: SelectSubset<T, AvailabilityUpsertArgs<ExtArgs>>): Prisma__AvailabilityClient<$Result.GetResult<Prisma.$AvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityCountArgs} args - Arguments to filter Availabilities to count.
     * @example
     * // Count the number of Availabilities
     * const count = await prisma.availability.count({
     *   where: {
     *     // ... the filter for the Availabilities we want to count
     *   }
     * })
    **/
    count<T extends AvailabilityCountArgs>(
      args?: Subset<T, AvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AvailabilityAggregateArgs>(args: Subset<T, AvailabilityAggregateArgs>): Prisma.PrismaPromise<GetAvailabilityAggregateType<T>>

    /**
     * Group by Availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: AvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Availability model
   */
  readonly fields: AvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Availability model
   */
  interface AvailabilityFieldRefs {
    readonly id: FieldRef<"Availability", 'String'>
    readonly listingId: FieldRef<"Availability", 'String'>
    readonly startDate: FieldRef<"Availability", 'DateTime'>
    readonly endDate: FieldRef<"Availability", 'DateTime'>
    readonly available: FieldRef<"Availability", 'Boolean'>
    readonly price: FieldRef<"Availability", 'Float'>
    readonly minStay: FieldRef<"Availability", 'Int'>
    readonly createdAt: FieldRef<"Availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Availability findUnique
   */
  export type AvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findUniqueOrThrow
   */
  export type AvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability findFirst
   */
  export type AvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findFirstOrThrow
   */
  export type AvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availability to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Availabilities.
     */
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability findMany
   */
  export type AvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which Availabilities to fetch.
     */
    where?: AvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Availabilities to fetch.
     */
    orderBy?: AvailabilityOrderByWithRelationInput | AvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Availabilities.
     */
    cursor?: AvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Availabilities.
     */
    skip?: number
    distinct?: AvailabilityScalarFieldEnum | AvailabilityScalarFieldEnum[]
  }

  /**
   * Availability create
   */
  export type AvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Availability.
     */
    data: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
  }

  /**
   * Availability createMany
   */
  export type AvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Availability createManyAndReturn
   */
  export type AvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many Availabilities.
     */
    data: AvailabilityCreateManyInput | AvailabilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability update
   */
  export type AvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Availability.
     */
    data: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
    /**
     * Choose, which Availability to update.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability updateMany
   */
  export type AvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
  }

  /**
   * Availability updateManyAndReturn
   */
  export type AvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update Availabilities.
     */
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which Availabilities to update
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Availability upsert
   */
  export type AvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Availability to update in case it exists.
     */
    where: AvailabilityWhereUniqueInput
    /**
     * In case the Availability found by the `where` argument doesn't exist, create a new Availability with this data.
     */
    create: XOR<AvailabilityCreateInput, AvailabilityUncheckedCreateInput>
    /**
     * In case the Availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AvailabilityUpdateInput, AvailabilityUncheckedUpdateInput>
  }

  /**
   * Availability delete
   */
  export type AvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
    /**
     * Filter which Availability to delete.
     */
    where: AvailabilityWhereUniqueInput
  }

  /**
   * Availability deleteMany
   */
  export type AvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Availabilities to delete
     */
    where?: AvailabilityWhereInput
    /**
     * Limit how many Availabilities to delete.
     */
    limit?: number
  }

  /**
   * Availability without action
   */
  export type AvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Availability
     */
    select?: AvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Availability
     */
    omit?: AvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteListing
   */

  export type AggregateFavoriteListing = {
    _count: FavoriteListingCountAggregateOutputType | null
    _min: FavoriteListingMinAggregateOutputType | null
    _max: FavoriteListingMaxAggregateOutputType | null
  }

  export type FavoriteListingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type FavoriteListingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type FavoriteListingCountAggregateOutputType = {
    id: number
    userId: number
    listingId: number
    createdAt: number
    _all: number
  }


  export type FavoriteListingMinAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
  }

  export type FavoriteListingMaxAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
  }

  export type FavoriteListingCountAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteListingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteListing to aggregate.
     */
    where?: FavoriteListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteListings to fetch.
     */
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteListings
    **/
    _count?: true | FavoriteListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteListingMaxAggregateInputType
  }

  export type GetFavoriteListingAggregateType<T extends FavoriteListingAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteListing[P]>
      : GetScalarType<T[P], AggregateFavoriteListing[P]>
  }




  export type FavoriteListingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteListingWhereInput
    orderBy?: FavoriteListingOrderByWithAggregationInput | FavoriteListingOrderByWithAggregationInput[]
    by: FavoriteListingScalarFieldEnum[] | FavoriteListingScalarFieldEnum
    having?: FavoriteListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteListingCountAggregateInputType | true
    _min?: FavoriteListingMinAggregateInputType
    _max?: FavoriteListingMaxAggregateInputType
  }

  export type FavoriteListingGroupByOutputType = {
    id: string
    userId: string
    listingId: string
    createdAt: Date
    _count: FavoriteListingCountAggregateOutputType | null
    _min: FavoriteListingMinAggregateOutputType | null
    _max: FavoriteListingMaxAggregateOutputType | null
  }

  type GetFavoriteListingGroupByPayload<T extends FavoriteListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteListingGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteListingGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteListingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteListing"]>

  export type FavoriteListingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteListing"]>

  export type FavoriteListingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteListing"]>

  export type FavoriteListingSelectScalar = {
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
  }

  export type FavoriteListingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "listingId" | "createdAt", ExtArgs["result"]["favoriteListing"]>
  export type FavoriteListingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type FavoriteListingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }
  export type FavoriteListingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }

  export type $FavoriteListingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteListing"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      listingId: string
      createdAt: Date
    }, ExtArgs["result"]["favoriteListing"]>
    composites: {}
  }

  type FavoriteListingGetPayload<S extends boolean | null | undefined | FavoriteListingDefaultArgs> = $Result.GetResult<Prisma.$FavoriteListingPayload, S>

  type FavoriteListingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteListingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteListingCountAggregateInputType | true
    }

  export interface FavoriteListingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteListing'], meta: { name: 'FavoriteListing' } }
    /**
     * Find zero or one FavoriteListing that matches the filter.
     * @param {FavoriteListingFindUniqueArgs} args - Arguments to find a FavoriteListing
     * @example
     * // Get one FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteListingFindUniqueArgs>(args: SelectSubset<T, FavoriteListingFindUniqueArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FavoriteListing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteListingFindUniqueOrThrowArgs} args - Arguments to find a FavoriteListing
     * @example
     * // Get one FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteListingFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteListingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingFindFirstArgs} args - Arguments to find a FavoriteListing
     * @example
     * // Get one FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteListingFindFirstArgs>(args?: SelectSubset<T, FavoriteListingFindFirstArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FavoriteListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingFindFirstOrThrowArgs} args - Arguments to find a FavoriteListing
     * @example
     * // Get one FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteListingFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteListingFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FavoriteListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteListings
     * const favoriteListings = await prisma.favoriteListing.findMany()
     * 
     * // Get first 10 FavoriteListings
     * const favoriteListings = await prisma.favoriteListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteListingWithIdOnly = await prisma.favoriteListing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteListingFindManyArgs>(args?: SelectSubset<T, FavoriteListingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FavoriteListing.
     * @param {FavoriteListingCreateArgs} args - Arguments to create a FavoriteListing.
     * @example
     * // Create one FavoriteListing
     * const FavoriteListing = await prisma.favoriteListing.create({
     *   data: {
     *     // ... data to create a FavoriteListing
     *   }
     * })
     * 
     */
    create<T extends FavoriteListingCreateArgs>(args: SelectSubset<T, FavoriteListingCreateArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FavoriteListings.
     * @param {FavoriteListingCreateManyArgs} args - Arguments to create many FavoriteListings.
     * @example
     * // Create many FavoriteListings
     * const favoriteListing = await prisma.favoriteListing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteListingCreateManyArgs>(args?: SelectSubset<T, FavoriteListingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteListings and returns the data saved in the database.
     * @param {FavoriteListingCreateManyAndReturnArgs} args - Arguments to create many FavoriteListings.
     * @example
     * // Create many FavoriteListings
     * const favoriteListing = await prisma.favoriteListing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteListings and only return the `id`
     * const favoriteListingWithIdOnly = await prisma.favoriteListing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteListingCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteListingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FavoriteListing.
     * @param {FavoriteListingDeleteArgs} args - Arguments to delete one FavoriteListing.
     * @example
     * // Delete one FavoriteListing
     * const FavoriteListing = await prisma.favoriteListing.delete({
     *   where: {
     *     // ... filter to delete one FavoriteListing
     *   }
     * })
     * 
     */
    delete<T extends FavoriteListingDeleteArgs>(args: SelectSubset<T, FavoriteListingDeleteArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FavoriteListing.
     * @param {FavoriteListingUpdateArgs} args - Arguments to update one FavoriteListing.
     * @example
     * // Update one FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteListingUpdateArgs>(args: SelectSubset<T, FavoriteListingUpdateArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FavoriteListings.
     * @param {FavoriteListingDeleteManyArgs} args - Arguments to filter FavoriteListings to delete.
     * @example
     * // Delete a few FavoriteListings
     * const { count } = await prisma.favoriteListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteListingDeleteManyArgs>(args?: SelectSubset<T, FavoriteListingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteListings
     * const favoriteListing = await prisma.favoriteListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteListingUpdateManyArgs>(args: SelectSubset<T, FavoriteListingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteListings and returns the data updated in the database.
     * @param {FavoriteListingUpdateManyAndReturnArgs} args - Arguments to update many FavoriteListings.
     * @example
     * // Update many FavoriteListings
     * const favoriteListing = await prisma.favoriteListing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FavoriteListings and only return the `id`
     * const favoriteListingWithIdOnly = await prisma.favoriteListing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteListingUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteListingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FavoriteListing.
     * @param {FavoriteListingUpsertArgs} args - Arguments to update or create a FavoriteListing.
     * @example
     * // Update or create a FavoriteListing
     * const favoriteListing = await prisma.favoriteListing.upsert({
     *   create: {
     *     // ... data to create a FavoriteListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteListing we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteListingUpsertArgs>(args: SelectSubset<T, FavoriteListingUpsertArgs<ExtArgs>>): Prisma__FavoriteListingClient<$Result.GetResult<Prisma.$FavoriteListingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FavoriteListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingCountArgs} args - Arguments to filter FavoriteListings to count.
     * @example
     * // Count the number of FavoriteListings
     * const count = await prisma.favoriteListing.count({
     *   where: {
     *     // ... the filter for the FavoriteListings we want to count
     *   }
     * })
    **/
    count<T extends FavoriteListingCountArgs>(
      args?: Subset<T, FavoriteListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteListingAggregateArgs>(args: Subset<T, FavoriteListingAggregateArgs>): Prisma.PrismaPromise<GetFavoriteListingAggregateType<T>>

    /**
     * Group by FavoriteListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteListingGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteListing model
   */
  readonly fields: FavoriteListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteListingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteListing model
   */
  interface FavoriteListingFieldRefs {
    readonly id: FieldRef<"FavoriteListing", 'String'>
    readonly userId: FieldRef<"FavoriteListing", 'String'>
    readonly listingId: FieldRef<"FavoriteListing", 'String'>
    readonly createdAt: FieldRef<"FavoriteListing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteListing findUnique
   */
  export type FavoriteListingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteListing to fetch.
     */
    where: FavoriteListingWhereUniqueInput
  }

  /**
   * FavoriteListing findUniqueOrThrow
   */
  export type FavoriteListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteListing to fetch.
     */
    where: FavoriteListingWhereUniqueInput
  }

  /**
   * FavoriteListing findFirst
   */
  export type FavoriteListingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteListing to fetch.
     */
    where?: FavoriteListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteListings to fetch.
     */
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteListings.
     */
    cursor?: FavoriteListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteListings.
     */
    distinct?: FavoriteListingScalarFieldEnum | FavoriteListingScalarFieldEnum[]
  }

  /**
   * FavoriteListing findFirstOrThrow
   */
  export type FavoriteListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteListing to fetch.
     */
    where?: FavoriteListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteListings to fetch.
     */
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteListings.
     */
    cursor?: FavoriteListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteListings.
     */
    distinct?: FavoriteListingScalarFieldEnum | FavoriteListingScalarFieldEnum[]
  }

  /**
   * FavoriteListing findMany
   */
  export type FavoriteListingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteListings to fetch.
     */
    where?: FavoriteListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteListings to fetch.
     */
    orderBy?: FavoriteListingOrderByWithRelationInput | FavoriteListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteListings.
     */
    cursor?: FavoriteListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteListings.
     */
    skip?: number
    distinct?: FavoriteListingScalarFieldEnum | FavoriteListingScalarFieldEnum[]
  }

  /**
   * FavoriteListing create
   */
  export type FavoriteListingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteListing.
     */
    data: XOR<FavoriteListingCreateInput, FavoriteListingUncheckedCreateInput>
  }

  /**
   * FavoriteListing createMany
   */
  export type FavoriteListingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteListings.
     */
    data: FavoriteListingCreateManyInput | FavoriteListingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FavoriteListing createManyAndReturn
   */
  export type FavoriteListingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * The data used to create many FavoriteListings.
     */
    data: FavoriteListingCreateManyInput | FavoriteListingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteListing update
   */
  export type FavoriteListingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteListing.
     */
    data: XOR<FavoriteListingUpdateInput, FavoriteListingUncheckedUpdateInput>
    /**
     * Choose, which FavoriteListing to update.
     */
    where: FavoriteListingWhereUniqueInput
  }

  /**
   * FavoriteListing updateMany
   */
  export type FavoriteListingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteListings.
     */
    data: XOR<FavoriteListingUpdateManyMutationInput, FavoriteListingUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteListings to update
     */
    where?: FavoriteListingWhereInput
    /**
     * Limit how many FavoriteListings to update.
     */
    limit?: number
  }

  /**
   * FavoriteListing updateManyAndReturn
   */
  export type FavoriteListingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * The data used to update FavoriteListings.
     */
    data: XOR<FavoriteListingUpdateManyMutationInput, FavoriteListingUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteListings to update
     */
    where?: FavoriteListingWhereInput
    /**
     * Limit how many FavoriteListings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteListing upsert
   */
  export type FavoriteListingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteListing to update in case it exists.
     */
    where: FavoriteListingWhereUniqueInput
    /**
     * In case the FavoriteListing found by the `where` argument doesn't exist, create a new FavoriteListing with this data.
     */
    create: XOR<FavoriteListingCreateInput, FavoriteListingUncheckedCreateInput>
    /**
     * In case the FavoriteListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteListingUpdateInput, FavoriteListingUncheckedUpdateInput>
  }

  /**
   * FavoriteListing delete
   */
  export type FavoriteListingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
    /**
     * Filter which FavoriteListing to delete.
     */
    where: FavoriteListingWhereUniqueInput
  }

  /**
   * FavoriteListing deleteMany
   */
  export type FavoriteListingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteListings to delete
     */
    where?: FavoriteListingWhereInput
    /**
     * Limit how many FavoriteListings to delete.
     */
    limit?: number
  }

  /**
   * FavoriteListing without action
   */
  export type FavoriteListingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteListing
     */
    select?: FavoriteListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FavoriteListing
     */
    omit?: FavoriteListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteListingInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    duration: number | null
    guestCount: number | null
    basePrice: number | null
    serviceFee: number | null
    tax: number | null
    depositAmount: number | null
    discountAmount: number | null
    totalPrice: number | null
    totalAmount: number | null
    ownerEarnings: number | null
    platformFee: number | null
  }

  export type BookingSumAggregateOutputType = {
    duration: number | null
    guestCount: number | null
    basePrice: number | null
    serviceFee: number | null
    tax: number | null
    depositAmount: number | null
    discountAmount: number | null
    totalPrice: number | null
    totalAmount: number | null
    ownerEarnings: number | null
    platformFee: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    renterId: string | null
    ownerId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    guestCount: number | null
    basePrice: number | null
    serviceFee: number | null
    tax: number | null
    depositAmount: number | null
    discountAmount: number | null
    totalPrice: number | null
    totalAmount: number | null
    ownerEarnings: number | null
    platformFee: number | null
    currency: string | null
    renterMessage: string | null
    status: $Enums.BookingStatus | null
    cancellationReason: string | null
    cancelledBy: string | null
    cancelledAt: Date | null
    paymentIntentId: string | null
    depositHoldId: string | null
    depositReleased: boolean | null
    depositReleasedAt: Date | null
    checkInTime: Date | null
    checkOutTime: Date | null
    actualReturnTime: Date | null
    renterNotes: string | null
    ownerNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confirmedAt: Date | null
    completedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    renterId: string | null
    ownerId: string | null
    startDate: Date | null
    endDate: Date | null
    duration: number | null
    guestCount: number | null
    basePrice: number | null
    serviceFee: number | null
    tax: number | null
    depositAmount: number | null
    discountAmount: number | null
    totalPrice: number | null
    totalAmount: number | null
    ownerEarnings: number | null
    platformFee: number | null
    currency: string | null
    renterMessage: string | null
    status: $Enums.BookingStatus | null
    cancellationReason: string | null
    cancelledBy: string | null
    cancelledAt: Date | null
    paymentIntentId: string | null
    depositHoldId: string | null
    depositReleased: boolean | null
    depositReleasedAt: Date | null
    checkInTime: Date | null
    checkOutTime: Date | null
    actualReturnTime: Date | null
    renterNotes: string | null
    ownerNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    confirmedAt: Date | null
    completedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    listingId: number
    renterId: number
    ownerId: number
    startDate: number
    endDate: number
    duration: number
    guestCount: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount: number
    discountAmount: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency: number
    renterMessage: number
    status: number
    cancellationReason: number
    cancelledBy: number
    cancelledAt: number
    paymentIntentId: number
    depositHoldId: number
    depositReleased: number
    depositReleasedAt: number
    checkInTime: number
    checkOutTime: number
    actualReturnTime: number
    categoryData: number
    renterNotes: number
    ownerNotes: number
    createdAt: number
    updatedAt: number
    confirmedAt: number
    completedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    duration?: true
    guestCount?: true
    basePrice?: true
    serviceFee?: true
    tax?: true
    depositAmount?: true
    discountAmount?: true
    totalPrice?: true
    totalAmount?: true
    ownerEarnings?: true
    platformFee?: true
  }

  export type BookingSumAggregateInputType = {
    duration?: true
    guestCount?: true
    basePrice?: true
    serviceFee?: true
    tax?: true
    depositAmount?: true
    discountAmount?: true
    totalPrice?: true
    totalAmount?: true
    ownerEarnings?: true
    platformFee?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    listingId?: true
    renterId?: true
    ownerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    guestCount?: true
    basePrice?: true
    serviceFee?: true
    tax?: true
    depositAmount?: true
    discountAmount?: true
    totalPrice?: true
    totalAmount?: true
    ownerEarnings?: true
    platformFee?: true
    currency?: true
    renterMessage?: true
    status?: true
    cancellationReason?: true
    cancelledBy?: true
    cancelledAt?: true
    paymentIntentId?: true
    depositHoldId?: true
    depositReleased?: true
    depositReleasedAt?: true
    checkInTime?: true
    checkOutTime?: true
    actualReturnTime?: true
    renterNotes?: true
    ownerNotes?: true
    createdAt?: true
    updatedAt?: true
    confirmedAt?: true
    completedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    listingId?: true
    renterId?: true
    ownerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    guestCount?: true
    basePrice?: true
    serviceFee?: true
    tax?: true
    depositAmount?: true
    discountAmount?: true
    totalPrice?: true
    totalAmount?: true
    ownerEarnings?: true
    platformFee?: true
    currency?: true
    renterMessage?: true
    status?: true
    cancellationReason?: true
    cancelledBy?: true
    cancelledAt?: true
    paymentIntentId?: true
    depositHoldId?: true
    depositReleased?: true
    depositReleasedAt?: true
    checkInTime?: true
    checkOutTime?: true
    actualReturnTime?: true
    renterNotes?: true
    ownerNotes?: true
    createdAt?: true
    updatedAt?: true
    confirmedAt?: true
    completedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    listingId?: true
    renterId?: true
    ownerId?: true
    startDate?: true
    endDate?: true
    duration?: true
    guestCount?: true
    basePrice?: true
    serviceFee?: true
    tax?: true
    depositAmount?: true
    discountAmount?: true
    totalPrice?: true
    totalAmount?: true
    ownerEarnings?: true
    platformFee?: true
    currency?: true
    renterMessage?: true
    status?: true
    cancellationReason?: true
    cancelledBy?: true
    cancelledAt?: true
    paymentIntentId?: true
    depositHoldId?: true
    depositReleased?: true
    depositReleasedAt?: true
    checkInTime?: true
    checkOutTime?: true
    actualReturnTime?: true
    categoryData?: true
    renterNotes?: true
    ownerNotes?: true
    createdAt?: true
    updatedAt?: true
    confirmedAt?: true
    completedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date
    endDate: Date
    duration: number
    guestCount: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount: number
    discountAmount: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency: string
    renterMessage: string | null
    status: $Enums.BookingStatus
    cancellationReason: string | null
    cancelledBy: string | null
    cancelledAt: Date | null
    paymentIntentId: string | null
    depositHoldId: string | null
    depositReleased: boolean
    depositReleasedAt: Date | null
    checkInTime: Date | null
    checkOutTime: Date | null
    actualReturnTime: Date | null
    categoryData: JsonValue
    renterNotes: string | null
    ownerNotes: string | null
    createdAt: Date
    updatedAt: Date
    confirmedAt: Date | null
    completedAt: Date | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    renterId?: boolean
    ownerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    guestCount?: boolean
    basePrice?: boolean
    serviceFee?: boolean
    tax?: boolean
    depositAmount?: boolean
    discountAmount?: boolean
    totalPrice?: boolean
    totalAmount?: boolean
    ownerEarnings?: boolean
    platformFee?: boolean
    currency?: boolean
    renterMessage?: boolean
    status?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    cancelledAt?: boolean
    paymentIntentId?: boolean
    depositHoldId?: boolean
    depositReleased?: boolean
    depositReleasedAt?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    actualReturnTime?: boolean
    categoryData?: boolean
    renterNotes?: boolean
    ownerNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    stateHistory?: boolean | Booking$stateHistoryArgs<ExtArgs>
    ledgerEntries?: boolean | Booking$ledgerEntriesArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    conditionReports?: boolean | Booking$conditionReportsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    disputes?: boolean | Booking$disputesArgs<ExtArgs>
    conversations?: boolean | Booking$conversationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    renterId?: boolean
    ownerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    guestCount?: boolean
    basePrice?: boolean
    serviceFee?: boolean
    tax?: boolean
    depositAmount?: boolean
    discountAmount?: boolean
    totalPrice?: boolean
    totalAmount?: boolean
    ownerEarnings?: boolean
    platformFee?: boolean
    currency?: boolean
    renterMessage?: boolean
    status?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    cancelledAt?: boolean
    paymentIntentId?: boolean
    depositHoldId?: boolean
    depositReleased?: boolean
    depositReleasedAt?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    actualReturnTime?: boolean
    categoryData?: boolean
    renterNotes?: boolean
    ownerNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    renterId?: boolean
    ownerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    guestCount?: boolean
    basePrice?: boolean
    serviceFee?: boolean
    tax?: boolean
    depositAmount?: boolean
    discountAmount?: boolean
    totalPrice?: boolean
    totalAmount?: boolean
    ownerEarnings?: boolean
    platformFee?: boolean
    currency?: boolean
    renterMessage?: boolean
    status?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    cancelledAt?: boolean
    paymentIntentId?: boolean
    depositHoldId?: boolean
    depositReleased?: boolean
    depositReleasedAt?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    actualReturnTime?: boolean
    categoryData?: boolean
    renterNotes?: boolean
    ownerNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    listingId?: boolean
    renterId?: boolean
    ownerId?: boolean
    startDate?: boolean
    endDate?: boolean
    duration?: boolean
    guestCount?: boolean
    basePrice?: boolean
    serviceFee?: boolean
    tax?: boolean
    depositAmount?: boolean
    discountAmount?: boolean
    totalPrice?: boolean
    totalAmount?: boolean
    ownerEarnings?: boolean
    platformFee?: boolean
    currency?: boolean
    renterMessage?: boolean
    status?: boolean
    cancellationReason?: boolean
    cancelledBy?: boolean
    cancelledAt?: boolean
    paymentIntentId?: boolean
    depositHoldId?: boolean
    depositReleased?: boolean
    depositReleasedAt?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    actualReturnTime?: boolean
    categoryData?: boolean
    renterNotes?: boolean
    ownerNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    confirmedAt?: boolean
    completedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "listingId" | "renterId" | "ownerId" | "startDate" | "endDate" | "duration" | "guestCount" | "basePrice" | "serviceFee" | "tax" | "depositAmount" | "discountAmount" | "totalPrice" | "totalAmount" | "ownerEarnings" | "platformFee" | "currency" | "renterMessage" | "status" | "cancellationReason" | "cancelledBy" | "cancelledAt" | "paymentIntentId" | "depositHoldId" | "depositReleased" | "depositReleasedAt" | "checkInTime" | "checkOutTime" | "actualReturnTime" | "categoryData" | "renterNotes" | "ownerNotes" | "createdAt" | "updatedAt" | "confirmedAt" | "completedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    stateHistory?: boolean | Booking$stateHistoryArgs<ExtArgs>
    ledgerEntries?: boolean | Booking$ledgerEntriesArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    conditionReports?: boolean | Booking$conditionReportsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    disputes?: boolean | Booking$disputesArgs<ExtArgs>
    conversations?: boolean | Booking$conversationsArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    renter?: boolean | UserDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    depositHold?: boolean | Booking$depositHoldArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      listing: Prisma.$ListingPayload<ExtArgs>
      renter: Prisma.$UserPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      stateHistory: Prisma.$BookingStateHistoryPayload<ExtArgs>[]
      ledgerEntries: Prisma.$LedgerEntryPayload<ExtArgs>[]
      depositHold: Prisma.$DepositHoldPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      conditionReports: Prisma.$ConditionReportPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      disputes: Prisma.$DisputePayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      listingId: string
      renterId: string
      ownerId: string
      startDate: Date
      endDate: Date
      duration: number
      guestCount: number
      basePrice: number
      serviceFee: number
      tax: number
      depositAmount: number
      discountAmount: number
      totalPrice: number
      totalAmount: number
      ownerEarnings: number
      platformFee: number
      currency: string
      renterMessage: string | null
      status: $Enums.BookingStatus
      cancellationReason: string | null
      cancelledBy: string | null
      cancelledAt: Date | null
      paymentIntentId: string | null
      depositHoldId: string | null
      depositReleased: boolean
      depositReleasedAt: Date | null
      checkInTime: Date | null
      checkOutTime: Date | null
      actualReturnTime: Date | null
      categoryData: Prisma.JsonValue
      renterNotes: string | null
      ownerNotes: string | null
      createdAt: Date
      updatedAt: Date
      confirmedAt: Date | null
      completedAt: Date | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    renter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stateHistory<T extends Booking$stateHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Booking$stateHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ledgerEntries<T extends Booking$ledgerEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$ledgerEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    depositHold<T extends Booking$depositHoldArgs<ExtArgs> = {}>(args?: Subset<T, Booking$depositHoldArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conditionReports<T extends Booking$conditionReportsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$conditionReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Booking$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disputes<T extends Booking$disputesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$disputesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Booking$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly listingId: FieldRef<"Booking", 'String'>
    readonly renterId: FieldRef<"Booking", 'String'>
    readonly ownerId: FieldRef<"Booking", 'String'>
    readonly startDate: FieldRef<"Booking", 'DateTime'>
    readonly endDate: FieldRef<"Booking", 'DateTime'>
    readonly duration: FieldRef<"Booking", 'Int'>
    readonly guestCount: FieldRef<"Booking", 'Int'>
    readonly basePrice: FieldRef<"Booking", 'Float'>
    readonly serviceFee: FieldRef<"Booking", 'Float'>
    readonly tax: FieldRef<"Booking", 'Float'>
    readonly depositAmount: FieldRef<"Booking", 'Float'>
    readonly discountAmount: FieldRef<"Booking", 'Float'>
    readonly totalPrice: FieldRef<"Booking", 'Float'>
    readonly totalAmount: FieldRef<"Booking", 'Float'>
    readonly ownerEarnings: FieldRef<"Booking", 'Float'>
    readonly platformFee: FieldRef<"Booking", 'Float'>
    readonly currency: FieldRef<"Booking", 'String'>
    readonly renterMessage: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly cancellationReason: FieldRef<"Booking", 'String'>
    readonly cancelledBy: FieldRef<"Booking", 'String'>
    readonly cancelledAt: FieldRef<"Booking", 'DateTime'>
    readonly paymentIntentId: FieldRef<"Booking", 'String'>
    readonly depositHoldId: FieldRef<"Booking", 'String'>
    readonly depositReleased: FieldRef<"Booking", 'Boolean'>
    readonly depositReleasedAt: FieldRef<"Booking", 'DateTime'>
    readonly checkInTime: FieldRef<"Booking", 'DateTime'>
    readonly checkOutTime: FieldRef<"Booking", 'DateTime'>
    readonly actualReturnTime: FieldRef<"Booking", 'DateTime'>
    readonly categoryData: FieldRef<"Booking", 'Json'>
    readonly renterNotes: FieldRef<"Booking", 'String'>
    readonly ownerNotes: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly confirmedAt: FieldRef<"Booking", 'DateTime'>
    readonly completedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.stateHistory
   */
  export type Booking$stateHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    where?: BookingStateHistoryWhereInput
    orderBy?: BookingStateHistoryOrderByWithRelationInput | BookingStateHistoryOrderByWithRelationInput[]
    cursor?: BookingStateHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingStateHistoryScalarFieldEnum | BookingStateHistoryScalarFieldEnum[]
  }

  /**
   * Booking.ledgerEntries
   */
  export type Booking$ledgerEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    cursor?: LedgerEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * Booking.depositHold
   */
  export type Booking$depositHoldArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    where?: DepositHoldWhereInput
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.conditionReports
   */
  export type Booking$conditionReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    where?: ConditionReportWhereInput
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    cursor?: ConditionReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConditionReportScalarFieldEnum | ConditionReportScalarFieldEnum[]
  }

  /**
   * Booking.reviews
   */
  export type Booking$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Booking.disputes
   */
  export type Booking$disputesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    cursor?: DisputeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Booking.conversations
   */
  export type Booking$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model BookingStateHistory
   */

  export type AggregateBookingStateHistory = {
    _count: BookingStateHistoryCountAggregateOutputType | null
    _min: BookingStateHistoryMinAggregateOutputType | null
    _max: BookingStateHistoryMaxAggregateOutputType | null
  }

  export type BookingStateHistoryMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    fromState: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus | null
    reason: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type BookingStateHistoryMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    fromState: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus | null
    reason: string | null
    changedBy: string | null
    createdAt: Date | null
  }

  export type BookingStateHistoryCountAggregateOutputType = {
    id: number
    bookingId: number
    fromState: number
    toState: number
    reason: number
    metadata: number
    changedBy: number
    createdAt: number
    _all: number
  }


  export type BookingStateHistoryMinAggregateInputType = {
    id?: true
    bookingId?: true
    fromState?: true
    toState?: true
    reason?: true
    changedBy?: true
    createdAt?: true
  }

  export type BookingStateHistoryMaxAggregateInputType = {
    id?: true
    bookingId?: true
    fromState?: true
    toState?: true
    reason?: true
    changedBy?: true
    createdAt?: true
  }

  export type BookingStateHistoryCountAggregateInputType = {
    id?: true
    bookingId?: true
    fromState?: true
    toState?: true
    reason?: true
    metadata?: true
    changedBy?: true
    createdAt?: true
    _all?: true
  }

  export type BookingStateHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStateHistory to aggregate.
     */
    where?: BookingStateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStateHistories to fetch.
     */
    orderBy?: BookingStateHistoryOrderByWithRelationInput | BookingStateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingStateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BookingStateHistories
    **/
    _count?: true | BookingStateHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingStateHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingStateHistoryMaxAggregateInputType
  }

  export type GetBookingStateHistoryAggregateType<T extends BookingStateHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateBookingStateHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookingStateHistory[P]>
      : GetScalarType<T[P], AggregateBookingStateHistory[P]>
  }




  export type BookingStateHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingStateHistoryWhereInput
    orderBy?: BookingStateHistoryOrderByWithAggregationInput | BookingStateHistoryOrderByWithAggregationInput[]
    by: BookingStateHistoryScalarFieldEnum[] | BookingStateHistoryScalarFieldEnum
    having?: BookingStateHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingStateHistoryCountAggregateInputType | true
    _min?: BookingStateHistoryMinAggregateInputType
    _max?: BookingStateHistoryMaxAggregateInputType
  }

  export type BookingStateHistoryGroupByOutputType = {
    id: string
    bookingId: string
    fromState: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason: string | null
    metadata: JsonValue
    changedBy: string | null
    createdAt: Date
    _count: BookingStateHistoryCountAggregateOutputType | null
    _min: BookingStateHistoryMinAggregateOutputType | null
    _max: BookingStateHistoryMaxAggregateOutputType | null
  }

  type GetBookingStateHistoryGroupByPayload<T extends BookingStateHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingStateHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingStateHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingStateHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], BookingStateHistoryGroupByOutputType[P]>
        }
      >
    >


  export type BookingStateHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    fromState?: boolean
    toState?: boolean
    reason?: boolean
    metadata?: boolean
    changedBy?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStateHistory"]>

  export type BookingStateHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    fromState?: boolean
    toState?: boolean
    reason?: boolean
    metadata?: boolean
    changedBy?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStateHistory"]>

  export type BookingStateHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    fromState?: boolean
    toState?: boolean
    reason?: boolean
    metadata?: boolean
    changedBy?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookingStateHistory"]>

  export type BookingStateHistorySelectScalar = {
    id?: boolean
    bookingId?: boolean
    fromState?: boolean
    toState?: boolean
    reason?: boolean
    metadata?: boolean
    changedBy?: boolean
    createdAt?: boolean
  }

  export type BookingStateHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "fromState" | "toState" | "reason" | "metadata" | "changedBy" | "createdAt", ExtArgs["result"]["bookingStateHistory"]>
  export type BookingStateHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingStateHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type BookingStateHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $BookingStateHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BookingStateHistory"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      fromState: $Enums.BookingStatus | null
      toState: $Enums.BookingStatus
      reason: string | null
      metadata: Prisma.JsonValue
      changedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["bookingStateHistory"]>
    composites: {}
  }

  type BookingStateHistoryGetPayload<S extends boolean | null | undefined | BookingStateHistoryDefaultArgs> = $Result.GetResult<Prisma.$BookingStateHistoryPayload, S>

  type BookingStateHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingStateHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingStateHistoryCountAggregateInputType | true
    }

  export interface BookingStateHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BookingStateHistory'], meta: { name: 'BookingStateHistory' } }
    /**
     * Find zero or one BookingStateHistory that matches the filter.
     * @param {BookingStateHistoryFindUniqueArgs} args - Arguments to find a BookingStateHistory
     * @example
     * // Get one BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingStateHistoryFindUniqueArgs>(args: SelectSubset<T, BookingStateHistoryFindUniqueArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BookingStateHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingStateHistoryFindUniqueOrThrowArgs} args - Arguments to find a BookingStateHistory
     * @example
     * // Get one BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingStateHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingStateHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStateHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryFindFirstArgs} args - Arguments to find a BookingStateHistory
     * @example
     * // Get one BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingStateHistoryFindFirstArgs>(args?: SelectSubset<T, BookingStateHistoryFindFirstArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BookingStateHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryFindFirstOrThrowArgs} args - Arguments to find a BookingStateHistory
     * @example
     * // Get one BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingStateHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingStateHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BookingStateHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BookingStateHistories
     * const bookingStateHistories = await prisma.bookingStateHistory.findMany()
     * 
     * // Get first 10 BookingStateHistories
     * const bookingStateHistories = await prisma.bookingStateHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingStateHistoryWithIdOnly = await prisma.bookingStateHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingStateHistoryFindManyArgs>(args?: SelectSubset<T, BookingStateHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BookingStateHistory.
     * @param {BookingStateHistoryCreateArgs} args - Arguments to create a BookingStateHistory.
     * @example
     * // Create one BookingStateHistory
     * const BookingStateHistory = await prisma.bookingStateHistory.create({
     *   data: {
     *     // ... data to create a BookingStateHistory
     *   }
     * })
     * 
     */
    create<T extends BookingStateHistoryCreateArgs>(args: SelectSubset<T, BookingStateHistoryCreateArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BookingStateHistories.
     * @param {BookingStateHistoryCreateManyArgs} args - Arguments to create many BookingStateHistories.
     * @example
     * // Create many BookingStateHistories
     * const bookingStateHistory = await prisma.bookingStateHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingStateHistoryCreateManyArgs>(args?: SelectSubset<T, BookingStateHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BookingStateHistories and returns the data saved in the database.
     * @param {BookingStateHistoryCreateManyAndReturnArgs} args - Arguments to create many BookingStateHistories.
     * @example
     * // Create many BookingStateHistories
     * const bookingStateHistory = await prisma.bookingStateHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BookingStateHistories and only return the `id`
     * const bookingStateHistoryWithIdOnly = await prisma.bookingStateHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingStateHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingStateHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BookingStateHistory.
     * @param {BookingStateHistoryDeleteArgs} args - Arguments to delete one BookingStateHistory.
     * @example
     * // Delete one BookingStateHistory
     * const BookingStateHistory = await prisma.bookingStateHistory.delete({
     *   where: {
     *     // ... filter to delete one BookingStateHistory
     *   }
     * })
     * 
     */
    delete<T extends BookingStateHistoryDeleteArgs>(args: SelectSubset<T, BookingStateHistoryDeleteArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BookingStateHistory.
     * @param {BookingStateHistoryUpdateArgs} args - Arguments to update one BookingStateHistory.
     * @example
     * // Update one BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingStateHistoryUpdateArgs>(args: SelectSubset<T, BookingStateHistoryUpdateArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BookingStateHistories.
     * @param {BookingStateHistoryDeleteManyArgs} args - Arguments to filter BookingStateHistories to delete.
     * @example
     * // Delete a few BookingStateHistories
     * const { count } = await prisma.bookingStateHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingStateHistoryDeleteManyArgs>(args?: SelectSubset<T, BookingStateHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BookingStateHistories
     * const bookingStateHistory = await prisma.bookingStateHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingStateHistoryUpdateManyArgs>(args: SelectSubset<T, BookingStateHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BookingStateHistories and returns the data updated in the database.
     * @param {BookingStateHistoryUpdateManyAndReturnArgs} args - Arguments to update many BookingStateHistories.
     * @example
     * // Update many BookingStateHistories
     * const bookingStateHistory = await prisma.bookingStateHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BookingStateHistories and only return the `id`
     * const bookingStateHistoryWithIdOnly = await prisma.bookingStateHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingStateHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingStateHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BookingStateHistory.
     * @param {BookingStateHistoryUpsertArgs} args - Arguments to update or create a BookingStateHistory.
     * @example
     * // Update or create a BookingStateHistory
     * const bookingStateHistory = await prisma.bookingStateHistory.upsert({
     *   create: {
     *     // ... data to create a BookingStateHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BookingStateHistory we want to update
     *   }
     * })
     */
    upsert<T extends BookingStateHistoryUpsertArgs>(args: SelectSubset<T, BookingStateHistoryUpsertArgs<ExtArgs>>): Prisma__BookingStateHistoryClient<$Result.GetResult<Prisma.$BookingStateHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BookingStateHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryCountArgs} args - Arguments to filter BookingStateHistories to count.
     * @example
     * // Count the number of BookingStateHistories
     * const count = await prisma.bookingStateHistory.count({
     *   where: {
     *     // ... the filter for the BookingStateHistories we want to count
     *   }
     * })
    **/
    count<T extends BookingStateHistoryCountArgs>(
      args?: Subset<T, BookingStateHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingStateHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BookingStateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingStateHistoryAggregateArgs>(args: Subset<T, BookingStateHistoryAggregateArgs>): Prisma.PrismaPromise<GetBookingStateHistoryAggregateType<T>>

    /**
     * Group by BookingStateHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingStateHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingStateHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingStateHistoryGroupByArgs['orderBy'] }
        : { orderBy?: BookingStateHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingStateHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingStateHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BookingStateHistory model
   */
  readonly fields: BookingStateHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BookingStateHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingStateHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BookingStateHistory model
   */
  interface BookingStateHistoryFieldRefs {
    readonly id: FieldRef<"BookingStateHistory", 'String'>
    readonly bookingId: FieldRef<"BookingStateHistory", 'String'>
    readonly fromState: FieldRef<"BookingStateHistory", 'BookingStatus'>
    readonly toState: FieldRef<"BookingStateHistory", 'BookingStatus'>
    readonly reason: FieldRef<"BookingStateHistory", 'String'>
    readonly metadata: FieldRef<"BookingStateHistory", 'Json'>
    readonly changedBy: FieldRef<"BookingStateHistory", 'String'>
    readonly createdAt: FieldRef<"BookingStateHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BookingStateHistory findUnique
   */
  export type BookingStateHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStateHistory to fetch.
     */
    where: BookingStateHistoryWhereUniqueInput
  }

  /**
   * BookingStateHistory findUniqueOrThrow
   */
  export type BookingStateHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStateHistory to fetch.
     */
    where: BookingStateHistoryWhereUniqueInput
  }

  /**
   * BookingStateHistory findFirst
   */
  export type BookingStateHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStateHistory to fetch.
     */
    where?: BookingStateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStateHistories to fetch.
     */
    orderBy?: BookingStateHistoryOrderByWithRelationInput | BookingStateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStateHistories.
     */
    cursor?: BookingStateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStateHistories.
     */
    distinct?: BookingStateHistoryScalarFieldEnum | BookingStateHistoryScalarFieldEnum[]
  }

  /**
   * BookingStateHistory findFirstOrThrow
   */
  export type BookingStateHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStateHistory to fetch.
     */
    where?: BookingStateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStateHistories to fetch.
     */
    orderBy?: BookingStateHistoryOrderByWithRelationInput | BookingStateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BookingStateHistories.
     */
    cursor?: BookingStateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStateHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BookingStateHistories.
     */
    distinct?: BookingStateHistoryScalarFieldEnum | BookingStateHistoryScalarFieldEnum[]
  }

  /**
   * BookingStateHistory findMany
   */
  export type BookingStateHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter, which BookingStateHistories to fetch.
     */
    where?: BookingStateHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BookingStateHistories to fetch.
     */
    orderBy?: BookingStateHistoryOrderByWithRelationInput | BookingStateHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BookingStateHistories.
     */
    cursor?: BookingStateHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BookingStateHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BookingStateHistories.
     */
    skip?: number
    distinct?: BookingStateHistoryScalarFieldEnum | BookingStateHistoryScalarFieldEnum[]
  }

  /**
   * BookingStateHistory create
   */
  export type BookingStateHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a BookingStateHistory.
     */
    data: XOR<BookingStateHistoryCreateInput, BookingStateHistoryUncheckedCreateInput>
  }

  /**
   * BookingStateHistory createMany
   */
  export type BookingStateHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BookingStateHistories.
     */
    data: BookingStateHistoryCreateManyInput | BookingStateHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BookingStateHistory createManyAndReturn
   */
  export type BookingStateHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many BookingStateHistories.
     */
    data: BookingStateHistoryCreateManyInput | BookingStateHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingStateHistory update
   */
  export type BookingStateHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a BookingStateHistory.
     */
    data: XOR<BookingStateHistoryUpdateInput, BookingStateHistoryUncheckedUpdateInput>
    /**
     * Choose, which BookingStateHistory to update.
     */
    where: BookingStateHistoryWhereUniqueInput
  }

  /**
   * BookingStateHistory updateMany
   */
  export type BookingStateHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BookingStateHistories.
     */
    data: XOR<BookingStateHistoryUpdateManyMutationInput, BookingStateHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BookingStateHistories to update
     */
    where?: BookingStateHistoryWhereInput
    /**
     * Limit how many BookingStateHistories to update.
     */
    limit?: number
  }

  /**
   * BookingStateHistory updateManyAndReturn
   */
  export type BookingStateHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * The data used to update BookingStateHistories.
     */
    data: XOR<BookingStateHistoryUpdateManyMutationInput, BookingStateHistoryUncheckedUpdateManyInput>
    /**
     * Filter which BookingStateHistories to update
     */
    where?: BookingStateHistoryWhereInput
    /**
     * Limit how many BookingStateHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BookingStateHistory upsert
   */
  export type BookingStateHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the BookingStateHistory to update in case it exists.
     */
    where: BookingStateHistoryWhereUniqueInput
    /**
     * In case the BookingStateHistory found by the `where` argument doesn't exist, create a new BookingStateHistory with this data.
     */
    create: XOR<BookingStateHistoryCreateInput, BookingStateHistoryUncheckedCreateInput>
    /**
     * In case the BookingStateHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingStateHistoryUpdateInput, BookingStateHistoryUncheckedUpdateInput>
  }

  /**
   * BookingStateHistory delete
   */
  export type BookingStateHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
    /**
     * Filter which BookingStateHistory to delete.
     */
    where: BookingStateHistoryWhereUniqueInput
  }

  /**
   * BookingStateHistory deleteMany
   */
  export type BookingStateHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BookingStateHistories to delete
     */
    where?: BookingStateHistoryWhereInput
    /**
     * Limit how many BookingStateHistories to delete.
     */
    limit?: number
  }

  /**
   * BookingStateHistory without action
   */
  export type BookingStateHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingStateHistory
     */
    select?: BookingStateHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BookingStateHistory
     */
    omit?: BookingStateHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingStateHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LedgerEntry
   */

  export type AggregateLedgerEntry = {
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  export type LedgerEntryAvgAggregateOutputType = {
    amount: number | null
  }

  export type LedgerEntrySumAggregateOutputType = {
    amount: number | null
  }

  export type LedgerEntryMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    accountType: string | null
    side: $Enums.LedgerSide | null
    amount: number | null
    currency: string | null
    transactionType: string | null
    description: string | null
    referenceId: string | null
    status: $Enums.LedgerEntryStatus | null
    createdAt: Date | null
    settledAt: Date | null
  }

  export type LedgerEntryMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    accountType: string | null
    side: $Enums.LedgerSide | null
    amount: number | null
    currency: string | null
    transactionType: string | null
    description: string | null
    referenceId: string | null
    status: $Enums.LedgerEntryStatus | null
    createdAt: Date | null
    settledAt: Date | null
  }

  export type LedgerEntryCountAggregateOutputType = {
    id: number
    bookingId: number
    accountType: number
    side: number
    amount: number
    currency: number
    transactionType: number
    description: number
    referenceId: number
    status: number
    metadata: number
    createdAt: number
    settledAt: number
    _all: number
  }


  export type LedgerEntryAvgAggregateInputType = {
    amount?: true
  }

  export type LedgerEntrySumAggregateInputType = {
    amount?: true
  }

  export type LedgerEntryMinAggregateInputType = {
    id?: true
    bookingId?: true
    accountType?: true
    side?: true
    amount?: true
    currency?: true
    transactionType?: true
    description?: true
    referenceId?: true
    status?: true
    createdAt?: true
    settledAt?: true
  }

  export type LedgerEntryMaxAggregateInputType = {
    id?: true
    bookingId?: true
    accountType?: true
    side?: true
    amount?: true
    currency?: true
    transactionType?: true
    description?: true
    referenceId?: true
    status?: true
    createdAt?: true
    settledAt?: true
  }

  export type LedgerEntryCountAggregateInputType = {
    id?: true
    bookingId?: true
    accountType?: true
    side?: true
    amount?: true
    currency?: true
    transactionType?: true
    description?: true
    referenceId?: true
    status?: true
    metadata?: true
    createdAt?: true
    settledAt?: true
    _all?: true
  }

  export type LedgerEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntry to aggregate.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LedgerEntries
    **/
    _count?: true | LedgerEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LedgerEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LedgerEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LedgerEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type GetLedgerEntryAggregateType<T extends LedgerEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLedgerEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLedgerEntry[P]>
      : GetScalarType<T[P], AggregateLedgerEntry[P]>
  }




  export type LedgerEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LedgerEntryWhereInput
    orderBy?: LedgerEntryOrderByWithAggregationInput | LedgerEntryOrderByWithAggregationInput[]
    by: LedgerEntryScalarFieldEnum[] | LedgerEntryScalarFieldEnum
    having?: LedgerEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LedgerEntryCountAggregateInputType | true
    _avg?: LedgerEntryAvgAggregateInputType
    _sum?: LedgerEntrySumAggregateInputType
    _min?: LedgerEntryMinAggregateInputType
    _max?: LedgerEntryMaxAggregateInputType
  }

  export type LedgerEntryGroupByOutputType = {
    id: string
    bookingId: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency: string
    transactionType: string
    description: string
    referenceId: string | null
    status: $Enums.LedgerEntryStatus
    metadata: JsonValue
    createdAt: Date
    settledAt: Date | null
    _count: LedgerEntryCountAggregateOutputType | null
    _avg: LedgerEntryAvgAggregateOutputType | null
    _sum: LedgerEntrySumAggregateOutputType | null
    _min: LedgerEntryMinAggregateOutputType | null
    _max: LedgerEntryMaxAggregateOutputType | null
  }

  type GetLedgerEntryGroupByPayload<T extends LedgerEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LedgerEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LedgerEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LedgerEntryGroupByOutputType[P]>
        }
      >
    >


  export type LedgerEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    accountType?: boolean
    side?: boolean
    amount?: boolean
    currency?: boolean
    transactionType?: boolean
    description?: boolean
    referenceId?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    settledAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    accountType?: boolean
    side?: boolean
    amount?: boolean
    currency?: boolean
    transactionType?: boolean
    description?: boolean
    referenceId?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    settledAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    accountType?: boolean
    side?: boolean
    amount?: boolean
    currency?: boolean
    transactionType?: boolean
    description?: boolean
    referenceId?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    settledAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ledgerEntry"]>

  export type LedgerEntrySelectScalar = {
    id?: boolean
    bookingId?: boolean
    accountType?: boolean
    side?: boolean
    amount?: boolean
    currency?: boolean
    transactionType?: boolean
    description?: boolean
    referenceId?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    settledAt?: boolean
  }

  export type LedgerEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "accountType" | "side" | "amount" | "currency" | "transactionType" | "description" | "referenceId" | "status" | "metadata" | "createdAt" | "settledAt", ExtArgs["result"]["ledgerEntry"]>
  export type LedgerEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type LedgerEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $LedgerEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LedgerEntry"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      accountType: string
      side: $Enums.LedgerSide
      amount: number
      currency: string
      transactionType: string
      description: string
      referenceId: string | null
      status: $Enums.LedgerEntryStatus
      metadata: Prisma.JsonValue
      createdAt: Date
      settledAt: Date | null
    }, ExtArgs["result"]["ledgerEntry"]>
    composites: {}
  }

  type LedgerEntryGetPayload<S extends boolean | null | undefined | LedgerEntryDefaultArgs> = $Result.GetResult<Prisma.$LedgerEntryPayload, S>

  type LedgerEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LedgerEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LedgerEntryCountAggregateInputType | true
    }

  export interface LedgerEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LedgerEntry'], meta: { name: 'LedgerEntry' } }
    /**
     * Find zero or one LedgerEntry that matches the filter.
     * @param {LedgerEntryFindUniqueArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LedgerEntryFindUniqueArgs>(args: SelectSubset<T, LedgerEntryFindUniqueArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LedgerEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LedgerEntryFindUniqueOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LedgerEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LedgerEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LedgerEntryFindFirstArgs>(args?: SelectSubset<T, LedgerEntryFindFirstArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LedgerEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindFirstOrThrowArgs} args - Arguments to find a LedgerEntry
     * @example
     * // Get one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LedgerEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LedgerEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LedgerEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany()
     * 
     * // Get first 10 LedgerEntries
     * const ledgerEntries = await prisma.ledgerEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LedgerEntryFindManyArgs>(args?: SelectSubset<T, LedgerEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LedgerEntry.
     * @param {LedgerEntryCreateArgs} args - Arguments to create a LedgerEntry.
     * @example
     * // Create one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.create({
     *   data: {
     *     // ... data to create a LedgerEntry
     *   }
     * })
     * 
     */
    create<T extends LedgerEntryCreateArgs>(args: SelectSubset<T, LedgerEntryCreateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LedgerEntries.
     * @param {LedgerEntryCreateManyArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LedgerEntryCreateManyArgs>(args?: SelectSubset<T, LedgerEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LedgerEntries and returns the data saved in the database.
     * @param {LedgerEntryCreateManyAndReturnArgs} args - Arguments to create many LedgerEntries.
     * @example
     * // Create many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LedgerEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LedgerEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LedgerEntry.
     * @param {LedgerEntryDeleteArgs} args - Arguments to delete one LedgerEntry.
     * @example
     * // Delete one LedgerEntry
     * const LedgerEntry = await prisma.ledgerEntry.delete({
     *   where: {
     *     // ... filter to delete one LedgerEntry
     *   }
     * })
     * 
     */
    delete<T extends LedgerEntryDeleteArgs>(args: SelectSubset<T, LedgerEntryDeleteArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LedgerEntry.
     * @param {LedgerEntryUpdateArgs} args - Arguments to update one LedgerEntry.
     * @example
     * // Update one LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LedgerEntryUpdateArgs>(args: SelectSubset<T, LedgerEntryUpdateArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LedgerEntries.
     * @param {LedgerEntryDeleteManyArgs} args - Arguments to filter LedgerEntries to delete.
     * @example
     * // Delete a few LedgerEntries
     * const { count } = await prisma.ledgerEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LedgerEntryDeleteManyArgs>(args?: SelectSubset<T, LedgerEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LedgerEntryUpdateManyArgs>(args: SelectSubset<T, LedgerEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LedgerEntries and returns the data updated in the database.
     * @param {LedgerEntryUpdateManyAndReturnArgs} args - Arguments to update many LedgerEntries.
     * @example
     * // Update many LedgerEntries
     * const ledgerEntry = await prisma.ledgerEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LedgerEntries and only return the `id`
     * const ledgerEntryWithIdOnly = await prisma.ledgerEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LedgerEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, LedgerEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LedgerEntry.
     * @param {LedgerEntryUpsertArgs} args - Arguments to update or create a LedgerEntry.
     * @example
     * // Update or create a LedgerEntry
     * const ledgerEntry = await prisma.ledgerEntry.upsert({
     *   create: {
     *     // ... data to create a LedgerEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LedgerEntry we want to update
     *   }
     * })
     */
    upsert<T extends LedgerEntryUpsertArgs>(args: SelectSubset<T, LedgerEntryUpsertArgs<ExtArgs>>): Prisma__LedgerEntryClient<$Result.GetResult<Prisma.$LedgerEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LedgerEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryCountArgs} args - Arguments to filter LedgerEntries to count.
     * @example
     * // Count the number of LedgerEntries
     * const count = await prisma.ledgerEntry.count({
     *   where: {
     *     // ... the filter for the LedgerEntries we want to count
     *   }
     * })
    **/
    count<T extends LedgerEntryCountArgs>(
      args?: Subset<T, LedgerEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LedgerEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LedgerEntryAggregateArgs>(args: Subset<T, LedgerEntryAggregateArgs>): Prisma.PrismaPromise<GetLedgerEntryAggregateType<T>>

    /**
     * Group by LedgerEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LedgerEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LedgerEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LedgerEntryGroupByArgs['orderBy'] }
        : { orderBy?: LedgerEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LedgerEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLedgerEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LedgerEntry model
   */
  readonly fields: LedgerEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LedgerEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LedgerEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LedgerEntry model
   */
  interface LedgerEntryFieldRefs {
    readonly id: FieldRef<"LedgerEntry", 'String'>
    readonly bookingId: FieldRef<"LedgerEntry", 'String'>
    readonly accountType: FieldRef<"LedgerEntry", 'String'>
    readonly side: FieldRef<"LedgerEntry", 'LedgerSide'>
    readonly amount: FieldRef<"LedgerEntry", 'Float'>
    readonly currency: FieldRef<"LedgerEntry", 'String'>
    readonly transactionType: FieldRef<"LedgerEntry", 'String'>
    readonly description: FieldRef<"LedgerEntry", 'String'>
    readonly referenceId: FieldRef<"LedgerEntry", 'String'>
    readonly status: FieldRef<"LedgerEntry", 'LedgerEntryStatus'>
    readonly metadata: FieldRef<"LedgerEntry", 'Json'>
    readonly createdAt: FieldRef<"LedgerEntry", 'DateTime'>
    readonly settledAt: FieldRef<"LedgerEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LedgerEntry findUnique
   */
  export type LedgerEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findUniqueOrThrow
   */
  export type LedgerEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry findFirst
   */
  export type LedgerEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findFirstOrThrow
   */
  export type LedgerEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntry to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LedgerEntries.
     */
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry findMany
   */
  export type LedgerEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter, which LedgerEntries to fetch.
     */
    where?: LedgerEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LedgerEntries to fetch.
     */
    orderBy?: LedgerEntryOrderByWithRelationInput | LedgerEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LedgerEntries.
     */
    cursor?: LedgerEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LedgerEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LedgerEntries.
     */
    skip?: number
    distinct?: LedgerEntryScalarFieldEnum | LedgerEntryScalarFieldEnum[]
  }

  /**
   * LedgerEntry create
   */
  export type LedgerEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LedgerEntry.
     */
    data: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
  }

  /**
   * LedgerEntry createMany
   */
  export type LedgerEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LedgerEntry createManyAndReturn
   */
  export type LedgerEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to create many LedgerEntries.
     */
    data: LedgerEntryCreateManyInput | LedgerEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry update
   */
  export type LedgerEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LedgerEntry.
     */
    data: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
    /**
     * Choose, which LedgerEntry to update.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry updateMany
   */
  export type LedgerEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
  }

  /**
   * LedgerEntry updateManyAndReturn
   */
  export type LedgerEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * The data used to update LedgerEntries.
     */
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyInput>
    /**
     * Filter which LedgerEntries to update
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LedgerEntry upsert
   */
  export type LedgerEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LedgerEntry to update in case it exists.
     */
    where: LedgerEntryWhereUniqueInput
    /**
     * In case the LedgerEntry found by the `where` argument doesn't exist, create a new LedgerEntry with this data.
     */
    create: XOR<LedgerEntryCreateInput, LedgerEntryUncheckedCreateInput>
    /**
     * In case the LedgerEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LedgerEntryUpdateInput, LedgerEntryUncheckedUpdateInput>
  }

  /**
   * LedgerEntry delete
   */
  export type LedgerEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
    /**
     * Filter which LedgerEntry to delete.
     */
    where: LedgerEntryWhereUniqueInput
  }

  /**
   * LedgerEntry deleteMany
   */
  export type LedgerEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LedgerEntries to delete
     */
    where?: LedgerEntryWhereInput
    /**
     * Limit how many LedgerEntries to delete.
     */
    limit?: number
  }

  /**
   * LedgerEntry without action
   */
  export type LedgerEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LedgerEntry
     */
    select?: LedgerEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LedgerEntry
     */
    omit?: LedgerEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LedgerEntryInclude<ExtArgs> | null
  }


  /**
   * Model DepositHold
   */

  export type AggregateDepositHold = {
    _count: DepositHoldCountAggregateOutputType | null
    _avg: DepositHoldAvgAggregateOutputType | null
    _sum: DepositHoldSumAggregateOutputType | null
    _min: DepositHoldMinAggregateOutputType | null
    _max: DepositHoldMaxAggregateOutputType | null
  }

  export type DepositHoldAvgAggregateOutputType = {
    amount: number | null
    deductedAmount: number | null
  }

  export type DepositHoldSumAggregateOutputType = {
    amount: number | null
    deductedAmount: number | null
  }

  export type DepositHoldMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    paymentIntentId: string | null
    status: $Enums.DepositStatus | null
    authorizedAt: Date | null
    capturedAt: Date | null
    releasedAt: Date | null
    deductedAmount: number | null
    deductionReason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type DepositHoldMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    paymentIntentId: string | null
    status: $Enums.DepositStatus | null
    authorizedAt: Date | null
    capturedAt: Date | null
    releasedAt: Date | null
    deductedAmount: number | null
    deductionReason: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type DepositHoldCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    currency: number
    paymentIntentId: number
    status: number
    authorizedAt: number
    capturedAt: number
    releasedAt: number
    deductedAmount: number
    deductionReason: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type DepositHoldAvgAggregateInputType = {
    amount?: true
    deductedAmount?: true
  }

  export type DepositHoldSumAggregateInputType = {
    amount?: true
    deductedAmount?: true
  }

  export type DepositHoldMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentIntentId?: true
    status?: true
    authorizedAt?: true
    capturedAt?: true
    releasedAt?: true
    deductedAmount?: true
    deductionReason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type DepositHoldMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentIntentId?: true
    status?: true
    authorizedAt?: true
    capturedAt?: true
    releasedAt?: true
    deductedAmount?: true
    deductionReason?: true
    createdAt?: true
    expiresAt?: true
  }

  export type DepositHoldCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    paymentIntentId?: true
    status?: true
    authorizedAt?: true
    capturedAt?: true
    releasedAt?: true
    deductedAmount?: true
    deductionReason?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type DepositHoldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepositHold to aggregate.
     */
    where?: DepositHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositHolds to fetch.
     */
    orderBy?: DepositHoldOrderByWithRelationInput | DepositHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepositHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DepositHolds
    **/
    _count?: true | DepositHoldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepositHoldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepositHoldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepositHoldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepositHoldMaxAggregateInputType
  }

  export type GetDepositHoldAggregateType<T extends DepositHoldAggregateArgs> = {
        [P in keyof T & keyof AggregateDepositHold]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepositHold[P]>
      : GetScalarType<T[P], AggregateDepositHold[P]>
  }




  export type DepositHoldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepositHoldWhereInput
    orderBy?: DepositHoldOrderByWithAggregationInput | DepositHoldOrderByWithAggregationInput[]
    by: DepositHoldScalarFieldEnum[] | DepositHoldScalarFieldEnum
    having?: DepositHoldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepositHoldCountAggregateInputType | true
    _avg?: DepositHoldAvgAggregateInputType
    _sum?: DepositHoldSumAggregateInputType
    _min?: DepositHoldMinAggregateInputType
    _max?: DepositHoldMaxAggregateInputType
  }

  export type DepositHoldGroupByOutputType = {
    id: string
    bookingId: string | null
    amount: number
    currency: string
    paymentIntentId: string
    status: $Enums.DepositStatus
    authorizedAt: Date
    capturedAt: Date | null
    releasedAt: Date | null
    deductedAmount: number
    deductionReason: string | null
    createdAt: Date
    expiresAt: Date
    _count: DepositHoldCountAggregateOutputType | null
    _avg: DepositHoldAvgAggregateOutputType | null
    _sum: DepositHoldSumAggregateOutputType | null
    _min: DepositHoldMinAggregateOutputType | null
    _max: DepositHoldMaxAggregateOutputType | null
  }

  type GetDepositHoldGroupByPayload<T extends DepositHoldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepositHoldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepositHoldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepositHoldGroupByOutputType[P]>
            : GetScalarType<T[P], DepositHoldGroupByOutputType[P]>
        }
      >
    >


  export type DepositHoldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentIntentId?: boolean
    status?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    releasedAt?: boolean
    deductedAmount?: boolean
    deductionReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    bookings?: boolean | DepositHold$bookingsArgs<ExtArgs>
    _count?: boolean | DepositHoldCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["depositHold"]>

  export type DepositHoldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentIntentId?: boolean
    status?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    releasedAt?: boolean
    deductedAmount?: boolean
    deductionReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["depositHold"]>

  export type DepositHoldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentIntentId?: boolean
    status?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    releasedAt?: boolean
    deductedAmount?: boolean
    deductionReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["depositHold"]>

  export type DepositHoldSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    paymentIntentId?: boolean
    status?: boolean
    authorizedAt?: boolean
    capturedAt?: boolean
    releasedAt?: boolean
    deductedAmount?: boolean
    deductionReason?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type DepositHoldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "currency" | "paymentIntentId" | "status" | "authorizedAt" | "capturedAt" | "releasedAt" | "deductedAmount" | "deductionReason" | "createdAt" | "expiresAt", ExtArgs["result"]["depositHold"]>
  export type DepositHoldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | DepositHold$bookingsArgs<ExtArgs>
    _count?: boolean | DepositHoldCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepositHoldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DepositHoldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DepositHoldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DepositHold"
    objects: {
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string | null
      amount: number
      currency: string
      paymentIntentId: string
      status: $Enums.DepositStatus
      authorizedAt: Date
      capturedAt: Date | null
      releasedAt: Date | null
      deductedAmount: number
      deductionReason: string | null
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["depositHold"]>
    composites: {}
  }

  type DepositHoldGetPayload<S extends boolean | null | undefined | DepositHoldDefaultArgs> = $Result.GetResult<Prisma.$DepositHoldPayload, S>

  type DepositHoldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepositHoldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepositHoldCountAggregateInputType | true
    }

  export interface DepositHoldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DepositHold'], meta: { name: 'DepositHold' } }
    /**
     * Find zero or one DepositHold that matches the filter.
     * @param {DepositHoldFindUniqueArgs} args - Arguments to find a DepositHold
     * @example
     * // Get one DepositHold
     * const depositHold = await prisma.depositHold.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepositHoldFindUniqueArgs>(args: SelectSubset<T, DepositHoldFindUniqueArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DepositHold that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepositHoldFindUniqueOrThrowArgs} args - Arguments to find a DepositHold
     * @example
     * // Get one DepositHold
     * const depositHold = await prisma.depositHold.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepositHoldFindUniqueOrThrowArgs>(args: SelectSubset<T, DepositHoldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepositHold that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldFindFirstArgs} args - Arguments to find a DepositHold
     * @example
     * // Get one DepositHold
     * const depositHold = await prisma.depositHold.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepositHoldFindFirstArgs>(args?: SelectSubset<T, DepositHoldFindFirstArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DepositHold that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldFindFirstOrThrowArgs} args - Arguments to find a DepositHold
     * @example
     * // Get one DepositHold
     * const depositHold = await prisma.depositHold.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepositHoldFindFirstOrThrowArgs>(args?: SelectSubset<T, DepositHoldFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DepositHolds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DepositHolds
     * const depositHolds = await prisma.depositHold.findMany()
     * 
     * // Get first 10 DepositHolds
     * const depositHolds = await prisma.depositHold.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const depositHoldWithIdOnly = await prisma.depositHold.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepositHoldFindManyArgs>(args?: SelectSubset<T, DepositHoldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DepositHold.
     * @param {DepositHoldCreateArgs} args - Arguments to create a DepositHold.
     * @example
     * // Create one DepositHold
     * const DepositHold = await prisma.depositHold.create({
     *   data: {
     *     // ... data to create a DepositHold
     *   }
     * })
     * 
     */
    create<T extends DepositHoldCreateArgs>(args: SelectSubset<T, DepositHoldCreateArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DepositHolds.
     * @param {DepositHoldCreateManyArgs} args - Arguments to create many DepositHolds.
     * @example
     * // Create many DepositHolds
     * const depositHold = await prisma.depositHold.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepositHoldCreateManyArgs>(args?: SelectSubset<T, DepositHoldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DepositHolds and returns the data saved in the database.
     * @param {DepositHoldCreateManyAndReturnArgs} args - Arguments to create many DepositHolds.
     * @example
     * // Create many DepositHolds
     * const depositHold = await prisma.depositHold.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DepositHolds and only return the `id`
     * const depositHoldWithIdOnly = await prisma.depositHold.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepositHoldCreateManyAndReturnArgs>(args?: SelectSubset<T, DepositHoldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DepositHold.
     * @param {DepositHoldDeleteArgs} args - Arguments to delete one DepositHold.
     * @example
     * // Delete one DepositHold
     * const DepositHold = await prisma.depositHold.delete({
     *   where: {
     *     // ... filter to delete one DepositHold
     *   }
     * })
     * 
     */
    delete<T extends DepositHoldDeleteArgs>(args: SelectSubset<T, DepositHoldDeleteArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DepositHold.
     * @param {DepositHoldUpdateArgs} args - Arguments to update one DepositHold.
     * @example
     * // Update one DepositHold
     * const depositHold = await prisma.depositHold.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepositHoldUpdateArgs>(args: SelectSubset<T, DepositHoldUpdateArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DepositHolds.
     * @param {DepositHoldDeleteManyArgs} args - Arguments to filter DepositHolds to delete.
     * @example
     * // Delete a few DepositHolds
     * const { count } = await prisma.depositHold.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepositHoldDeleteManyArgs>(args?: SelectSubset<T, DepositHoldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepositHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DepositHolds
     * const depositHold = await prisma.depositHold.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepositHoldUpdateManyArgs>(args: SelectSubset<T, DepositHoldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DepositHolds and returns the data updated in the database.
     * @param {DepositHoldUpdateManyAndReturnArgs} args - Arguments to update many DepositHolds.
     * @example
     * // Update many DepositHolds
     * const depositHold = await prisma.depositHold.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DepositHolds and only return the `id`
     * const depositHoldWithIdOnly = await prisma.depositHold.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepositHoldUpdateManyAndReturnArgs>(args: SelectSubset<T, DepositHoldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DepositHold.
     * @param {DepositHoldUpsertArgs} args - Arguments to update or create a DepositHold.
     * @example
     * // Update or create a DepositHold
     * const depositHold = await prisma.depositHold.upsert({
     *   create: {
     *     // ... data to create a DepositHold
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DepositHold we want to update
     *   }
     * })
     */
    upsert<T extends DepositHoldUpsertArgs>(args: SelectSubset<T, DepositHoldUpsertArgs<ExtArgs>>): Prisma__DepositHoldClient<$Result.GetResult<Prisma.$DepositHoldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DepositHolds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldCountArgs} args - Arguments to filter DepositHolds to count.
     * @example
     * // Count the number of DepositHolds
     * const count = await prisma.depositHold.count({
     *   where: {
     *     // ... the filter for the DepositHolds we want to count
     *   }
     * })
    **/
    count<T extends DepositHoldCountArgs>(
      args?: Subset<T, DepositHoldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepositHoldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DepositHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepositHoldAggregateArgs>(args: Subset<T, DepositHoldAggregateArgs>): Prisma.PrismaPromise<GetDepositHoldAggregateType<T>>

    /**
     * Group by DepositHold.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepositHoldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepositHoldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepositHoldGroupByArgs['orderBy'] }
        : { orderBy?: DepositHoldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepositHoldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepositHoldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DepositHold model
   */
  readonly fields: DepositHoldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DepositHold.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepositHoldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends DepositHold$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, DepositHold$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DepositHold model
   */
  interface DepositHoldFieldRefs {
    readonly id: FieldRef<"DepositHold", 'String'>
    readonly bookingId: FieldRef<"DepositHold", 'String'>
    readonly amount: FieldRef<"DepositHold", 'Float'>
    readonly currency: FieldRef<"DepositHold", 'String'>
    readonly paymentIntentId: FieldRef<"DepositHold", 'String'>
    readonly status: FieldRef<"DepositHold", 'DepositStatus'>
    readonly authorizedAt: FieldRef<"DepositHold", 'DateTime'>
    readonly capturedAt: FieldRef<"DepositHold", 'DateTime'>
    readonly releasedAt: FieldRef<"DepositHold", 'DateTime'>
    readonly deductedAmount: FieldRef<"DepositHold", 'Float'>
    readonly deductionReason: FieldRef<"DepositHold", 'String'>
    readonly createdAt: FieldRef<"DepositHold", 'DateTime'>
    readonly expiresAt: FieldRef<"DepositHold", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DepositHold findUnique
   */
  export type DepositHoldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter, which DepositHold to fetch.
     */
    where: DepositHoldWhereUniqueInput
  }

  /**
   * DepositHold findUniqueOrThrow
   */
  export type DepositHoldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter, which DepositHold to fetch.
     */
    where: DepositHoldWhereUniqueInput
  }

  /**
   * DepositHold findFirst
   */
  export type DepositHoldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter, which DepositHold to fetch.
     */
    where?: DepositHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositHolds to fetch.
     */
    orderBy?: DepositHoldOrderByWithRelationInput | DepositHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepositHolds.
     */
    cursor?: DepositHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepositHolds.
     */
    distinct?: DepositHoldScalarFieldEnum | DepositHoldScalarFieldEnum[]
  }

  /**
   * DepositHold findFirstOrThrow
   */
  export type DepositHoldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter, which DepositHold to fetch.
     */
    where?: DepositHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositHolds to fetch.
     */
    orderBy?: DepositHoldOrderByWithRelationInput | DepositHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DepositHolds.
     */
    cursor?: DepositHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositHolds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DepositHolds.
     */
    distinct?: DepositHoldScalarFieldEnum | DepositHoldScalarFieldEnum[]
  }

  /**
   * DepositHold findMany
   */
  export type DepositHoldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter, which DepositHolds to fetch.
     */
    where?: DepositHoldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DepositHolds to fetch.
     */
    orderBy?: DepositHoldOrderByWithRelationInput | DepositHoldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DepositHolds.
     */
    cursor?: DepositHoldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DepositHolds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DepositHolds.
     */
    skip?: number
    distinct?: DepositHoldScalarFieldEnum | DepositHoldScalarFieldEnum[]
  }

  /**
   * DepositHold create
   */
  export type DepositHoldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * The data needed to create a DepositHold.
     */
    data: XOR<DepositHoldCreateInput, DepositHoldUncheckedCreateInput>
  }

  /**
   * DepositHold createMany
   */
  export type DepositHoldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DepositHolds.
     */
    data: DepositHoldCreateManyInput | DepositHoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepositHold createManyAndReturn
   */
  export type DepositHoldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * The data used to create many DepositHolds.
     */
    data: DepositHoldCreateManyInput | DepositHoldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DepositHold update
   */
  export type DepositHoldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * The data needed to update a DepositHold.
     */
    data: XOR<DepositHoldUpdateInput, DepositHoldUncheckedUpdateInput>
    /**
     * Choose, which DepositHold to update.
     */
    where: DepositHoldWhereUniqueInput
  }

  /**
   * DepositHold updateMany
   */
  export type DepositHoldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DepositHolds.
     */
    data: XOR<DepositHoldUpdateManyMutationInput, DepositHoldUncheckedUpdateManyInput>
    /**
     * Filter which DepositHolds to update
     */
    where?: DepositHoldWhereInput
    /**
     * Limit how many DepositHolds to update.
     */
    limit?: number
  }

  /**
   * DepositHold updateManyAndReturn
   */
  export type DepositHoldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * The data used to update DepositHolds.
     */
    data: XOR<DepositHoldUpdateManyMutationInput, DepositHoldUncheckedUpdateManyInput>
    /**
     * Filter which DepositHolds to update
     */
    where?: DepositHoldWhereInput
    /**
     * Limit how many DepositHolds to update.
     */
    limit?: number
  }

  /**
   * DepositHold upsert
   */
  export type DepositHoldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * The filter to search for the DepositHold to update in case it exists.
     */
    where: DepositHoldWhereUniqueInput
    /**
     * In case the DepositHold found by the `where` argument doesn't exist, create a new DepositHold with this data.
     */
    create: XOR<DepositHoldCreateInput, DepositHoldUncheckedCreateInput>
    /**
     * In case the DepositHold was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepositHoldUpdateInput, DepositHoldUncheckedUpdateInput>
  }

  /**
   * DepositHold delete
   */
  export type DepositHoldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
    /**
     * Filter which DepositHold to delete.
     */
    where: DepositHoldWhereUniqueInput
  }

  /**
   * DepositHold deleteMany
   */
  export type DepositHoldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DepositHolds to delete
     */
    where?: DepositHoldWhereInput
    /**
     * Limit how many DepositHolds to delete.
     */
    limit?: number
  }

  /**
   * DepositHold.bookings
   */
  export type DepositHold$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * DepositHold without action
   */
  export type DepositHoldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepositHold
     */
    select?: DepositHoldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DepositHold
     */
    omit?: DepositHoldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepositHoldInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    status: $Enums.PaymentStatus | null
    failureReason: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    status: $Enums.PaymentStatus | null
    failureReason: string | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    currency: number
    stripePaymentIntentId: number
    stripeChargeId: number
    status: number
    failureReason: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    status?: true
    failureReason?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    status?: true
    failureReason?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    status?: true
    failureReason?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    amount: number
    currency: string
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    status: $Enums.PaymentStatus
    failureReason: string | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    status?: boolean
    failureReason?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    status?: boolean
    failureReason?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    status?: boolean
    failureReason?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    status?: boolean
    failureReason?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "currency" | "stripePaymentIntentId" | "stripeChargeId" | "status" | "failureReason" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      amount: number
      currency: string
      stripePaymentIntentId: string | null
      stripeChargeId: string | null
      status: $Enums.PaymentStatus
      failureReason: string | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeChargeId: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly failureReason: FieldRef<"Payment", 'String'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Refund
   */

  export type AggregateRefund = {
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  export type RefundAvgAggregateOutputType = {
    amount: number | null
  }

  export type RefundSumAggregateOutputType = {
    amount: number | null
  }

  export type RefundMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    reason: string | null
    refundId: string | null
    status: $Enums.RefundStatus | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type RefundMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    amount: number | null
    currency: string | null
    reason: string | null
    refundId: string | null
    status: $Enums.RefundStatus | null
    processedAt: Date | null
    createdAt: Date | null
  }

  export type RefundCountAggregateOutputType = {
    id: number
    bookingId: number
    amount: number
    currency: number
    reason: number
    refundId: number
    status: number
    processedAt: number
    createdAt: number
    _all: number
  }


  export type RefundAvgAggregateInputType = {
    amount?: true
  }

  export type RefundSumAggregateInputType = {
    amount?: true
  }

  export type RefundMinAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    reason?: true
    refundId?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type RefundMaxAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    reason?: true
    refundId?: true
    status?: true
    processedAt?: true
    createdAt?: true
  }

  export type RefundCountAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
    currency?: true
    reason?: true
    refundId?: true
    status?: true
    processedAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefundAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refund to aggregate.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Refunds
    **/
    _count?: true | RefundCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefundAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefundSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefundMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefundMaxAggregateInputType
  }

  export type GetRefundAggregateType<T extends RefundAggregateArgs> = {
        [P in keyof T & keyof AggregateRefund]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefund[P]>
      : GetScalarType<T[P], AggregateRefund[P]>
  }




  export type RefundGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefundWhereInput
    orderBy?: RefundOrderByWithAggregationInput | RefundOrderByWithAggregationInput[]
    by: RefundScalarFieldEnum[] | RefundScalarFieldEnum
    having?: RefundScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefundCountAggregateInputType | true
    _avg?: RefundAvgAggregateInputType
    _sum?: RefundSumAggregateInputType
    _min?: RefundMinAggregateInputType
    _max?: RefundMaxAggregateInputType
  }

  export type RefundGroupByOutputType = {
    id: string
    bookingId: string
    amount: number
    currency: string
    reason: string
    refundId: string
    status: $Enums.RefundStatus
    processedAt: Date | null
    createdAt: Date
    _count: RefundCountAggregateOutputType | null
    _avg: RefundAvgAggregateOutputType | null
    _sum: RefundSumAggregateOutputType | null
    _min: RefundMinAggregateOutputType | null
    _max: RefundMaxAggregateOutputType | null
  }

  type GetRefundGroupByPayload<T extends RefundGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefundGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefundGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefundGroupByOutputType[P]>
            : GetScalarType<T[P], RefundGroupByOutputType[P]>
        }
      >
    >


  export type RefundSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    refundId?: boolean
    status?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    refundId?: boolean
    status?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    refundId?: boolean
    status?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["refund"]>

  export type RefundSelectScalar = {
    id?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    reason?: boolean
    refundId?: boolean
    status?: boolean
    processedAt?: boolean
    createdAt?: boolean
  }

  export type RefundOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "amount" | "currency" | "reason" | "refundId" | "status" | "processedAt" | "createdAt", ExtArgs["result"]["refund"]>

  export type $RefundPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Refund"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      amount: number
      currency: string
      reason: string
      refundId: string
      status: $Enums.RefundStatus
      processedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["refund"]>
    composites: {}
  }

  type RefundGetPayload<S extends boolean | null | undefined | RefundDefaultArgs> = $Result.GetResult<Prisma.$RefundPayload, S>

  type RefundCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefundFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefundCountAggregateInputType | true
    }

  export interface RefundDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Refund'], meta: { name: 'Refund' } }
    /**
     * Find zero or one Refund that matches the filter.
     * @param {RefundFindUniqueArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefundFindUniqueArgs>(args: SelectSubset<T, RefundFindUniqueArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Refund that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefundFindUniqueOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefundFindUniqueOrThrowArgs>(args: SelectSubset<T, RefundFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefundFindFirstArgs>(args?: SelectSubset<T, RefundFindFirstArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Refund that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindFirstOrThrowArgs} args - Arguments to find a Refund
     * @example
     * // Get one Refund
     * const refund = await prisma.refund.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefundFindFirstOrThrowArgs>(args?: SelectSubset<T, RefundFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Refunds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Refunds
     * const refunds = await prisma.refund.findMany()
     * 
     * // Get first 10 Refunds
     * const refunds = await prisma.refund.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refundWithIdOnly = await prisma.refund.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefundFindManyArgs>(args?: SelectSubset<T, RefundFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Refund.
     * @param {RefundCreateArgs} args - Arguments to create a Refund.
     * @example
     * // Create one Refund
     * const Refund = await prisma.refund.create({
     *   data: {
     *     // ... data to create a Refund
     *   }
     * })
     * 
     */
    create<T extends RefundCreateArgs>(args: SelectSubset<T, RefundCreateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Refunds.
     * @param {RefundCreateManyArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefundCreateManyArgs>(args?: SelectSubset<T, RefundCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Refunds and returns the data saved in the database.
     * @param {RefundCreateManyAndReturnArgs} args - Arguments to create many Refunds.
     * @example
     * // Create many Refunds
     * const refund = await prisma.refund.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefundCreateManyAndReturnArgs>(args?: SelectSubset<T, RefundCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Refund.
     * @param {RefundDeleteArgs} args - Arguments to delete one Refund.
     * @example
     * // Delete one Refund
     * const Refund = await prisma.refund.delete({
     *   where: {
     *     // ... filter to delete one Refund
     *   }
     * })
     * 
     */
    delete<T extends RefundDeleteArgs>(args: SelectSubset<T, RefundDeleteArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Refund.
     * @param {RefundUpdateArgs} args - Arguments to update one Refund.
     * @example
     * // Update one Refund
     * const refund = await prisma.refund.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefundUpdateArgs>(args: SelectSubset<T, RefundUpdateArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Refunds.
     * @param {RefundDeleteManyArgs} args - Arguments to filter Refunds to delete.
     * @example
     * // Delete a few Refunds
     * const { count } = await prisma.refund.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefundDeleteManyArgs>(args?: SelectSubset<T, RefundDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefundUpdateManyArgs>(args: SelectSubset<T, RefundUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Refunds and returns the data updated in the database.
     * @param {RefundUpdateManyAndReturnArgs} args - Arguments to update many Refunds.
     * @example
     * // Update many Refunds
     * const refund = await prisma.refund.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Refunds and only return the `id`
     * const refundWithIdOnly = await prisma.refund.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefundUpdateManyAndReturnArgs>(args: SelectSubset<T, RefundUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Refund.
     * @param {RefundUpsertArgs} args - Arguments to update or create a Refund.
     * @example
     * // Update or create a Refund
     * const refund = await prisma.refund.upsert({
     *   create: {
     *     // ... data to create a Refund
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Refund we want to update
     *   }
     * })
     */
    upsert<T extends RefundUpsertArgs>(args: SelectSubset<T, RefundUpsertArgs<ExtArgs>>): Prisma__RefundClient<$Result.GetResult<Prisma.$RefundPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Refunds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundCountArgs} args - Arguments to filter Refunds to count.
     * @example
     * // Count the number of Refunds
     * const count = await prisma.refund.count({
     *   where: {
     *     // ... the filter for the Refunds we want to count
     *   }
     * })
    **/
    count<T extends RefundCountArgs>(
      args?: Subset<T, RefundCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefundCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefundAggregateArgs>(args: Subset<T, RefundAggregateArgs>): Prisma.PrismaPromise<GetRefundAggregateType<T>>

    /**
     * Group by Refund.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefundGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefundGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefundGroupByArgs['orderBy'] }
        : { orderBy?: RefundGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefundGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefundGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Refund model
   */
  readonly fields: RefundFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Refund.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefundClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Refund model
   */
  interface RefundFieldRefs {
    readonly id: FieldRef<"Refund", 'String'>
    readonly bookingId: FieldRef<"Refund", 'String'>
    readonly amount: FieldRef<"Refund", 'Float'>
    readonly currency: FieldRef<"Refund", 'String'>
    readonly reason: FieldRef<"Refund", 'String'>
    readonly refundId: FieldRef<"Refund", 'String'>
    readonly status: FieldRef<"Refund", 'RefundStatus'>
    readonly processedAt: FieldRef<"Refund", 'DateTime'>
    readonly createdAt: FieldRef<"Refund", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Refund findUnique
   */
  export type RefundFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findUniqueOrThrow
   */
  export type RefundFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund findFirst
   */
  export type RefundFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findFirstOrThrow
   */
  export type RefundFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter, which Refund to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Refunds.
     */
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund findMany
   */
  export type RefundFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter, which Refunds to fetch.
     */
    where?: RefundWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Refunds to fetch.
     */
    orderBy?: RefundOrderByWithRelationInput | RefundOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Refunds.
     */
    cursor?: RefundWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Refunds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Refunds.
     */
    skip?: number
    distinct?: RefundScalarFieldEnum | RefundScalarFieldEnum[]
  }

  /**
   * Refund create
   */
  export type RefundCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data needed to create a Refund.
     */
    data: XOR<RefundCreateInput, RefundUncheckedCreateInput>
  }

  /**
   * Refund createMany
   */
  export type RefundCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund createManyAndReturn
   */
  export type RefundCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to create many Refunds.
     */
    data: RefundCreateManyInput | RefundCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Refund update
   */
  export type RefundUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data needed to update a Refund.
     */
    data: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
    /**
     * Choose, which Refund to update.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund updateMany
   */
  export type RefundUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
  }

  /**
   * Refund updateManyAndReturn
   */
  export type RefundUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The data used to update Refunds.
     */
    data: XOR<RefundUpdateManyMutationInput, RefundUncheckedUpdateManyInput>
    /**
     * Filter which Refunds to update
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to update.
     */
    limit?: number
  }

  /**
   * Refund upsert
   */
  export type RefundUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * The filter to search for the Refund to update in case it exists.
     */
    where: RefundWhereUniqueInput
    /**
     * In case the Refund found by the `where` argument doesn't exist, create a new Refund with this data.
     */
    create: XOR<RefundCreateInput, RefundUncheckedCreateInput>
    /**
     * In case the Refund was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefundUpdateInput, RefundUncheckedUpdateInput>
  }

  /**
   * Refund delete
   */
  export type RefundDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
    /**
     * Filter which Refund to delete.
     */
    where: RefundWhereUniqueInput
  }

  /**
   * Refund deleteMany
   */
  export type RefundDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Refunds to delete
     */
    where?: RefundWhereInput
    /**
     * Limit how many Refunds to delete.
     */
    limit?: number
  }

  /**
   * Refund without action
   */
  export type RefundDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Refund
     */
    select?: RefundSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Refund
     */
    omit?: RefundOmit<ExtArgs> | null
  }


  /**
   * Model Payout
   */

  export type AggregatePayout = {
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  export type PayoutAvgAggregateOutputType = {
    amount: number | null
  }

  export type PayoutSumAggregateOutputType = {
    amount: number | null
  }

  export type PayoutMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    amount: number | null
    currency: string | null
    transferId: string | null
    status: $Enums.PayoutStatus | null
    failureReason: string | null
    createdAt: Date | null
    processedAt: Date | null
    paidAt: Date | null
  }

  export type PayoutMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    amount: number | null
    currency: string | null
    transferId: string | null
    status: $Enums.PayoutStatus | null
    failureReason: string | null
    createdAt: Date | null
    processedAt: Date | null
    paidAt: Date | null
  }

  export type PayoutCountAggregateOutputType = {
    id: number
    ownerId: number
    amount: number
    currency: number
    transferId: number
    status: number
    failureReason: number
    createdAt: number
    processedAt: number
    paidAt: number
    _all: number
  }


  export type PayoutAvgAggregateInputType = {
    amount?: true
  }

  export type PayoutSumAggregateInputType = {
    amount?: true
  }

  export type PayoutMinAggregateInputType = {
    id?: true
    ownerId?: true
    amount?: true
    currency?: true
    transferId?: true
    status?: true
    failureReason?: true
    createdAt?: true
    processedAt?: true
    paidAt?: true
  }

  export type PayoutMaxAggregateInputType = {
    id?: true
    ownerId?: true
    amount?: true
    currency?: true
    transferId?: true
    status?: true
    failureReason?: true
    createdAt?: true
    processedAt?: true
    paidAt?: true
  }

  export type PayoutCountAggregateInputType = {
    id?: true
    ownerId?: true
    amount?: true
    currency?: true
    transferId?: true
    status?: true
    failureReason?: true
    createdAt?: true
    processedAt?: true
    paidAt?: true
    _all?: true
  }

  export type PayoutAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payout to aggregate.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutMaxAggregateInputType
  }

  export type GetPayoutAggregateType<T extends PayoutAggregateArgs> = {
        [P in keyof T & keyof AggregatePayout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayout[P]>
      : GetScalarType<T[P], AggregatePayout[P]>
  }




  export type PayoutGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutWhereInput
    orderBy?: PayoutOrderByWithAggregationInput | PayoutOrderByWithAggregationInput[]
    by: PayoutScalarFieldEnum[] | PayoutScalarFieldEnum
    having?: PayoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutCountAggregateInputType | true
    _avg?: PayoutAvgAggregateInputType
    _sum?: PayoutSumAggregateInputType
    _min?: PayoutMinAggregateInputType
    _max?: PayoutMaxAggregateInputType
  }

  export type PayoutGroupByOutputType = {
    id: string
    ownerId: string
    amount: number
    currency: string
    transferId: string | null
    status: $Enums.PayoutStatus
    failureReason: string | null
    createdAt: Date
    processedAt: Date | null
    paidAt: Date | null
    _count: PayoutCountAggregateOutputType | null
    _avg: PayoutAvgAggregateOutputType | null
    _sum: PayoutSumAggregateOutputType | null
    _min: PayoutMinAggregateOutputType | null
    _max: PayoutMaxAggregateOutputType | null
  }

  type GetPayoutGroupByPayload<T extends PayoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutGroupByOutputType[P]>
        }
      >
    >


  export type PayoutSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    amount?: boolean
    currency?: boolean
    transferId?: boolean
    status?: boolean
    failureReason?: boolean
    createdAt?: boolean
    processedAt?: boolean
    paidAt?: boolean
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    amount?: boolean
    currency?: boolean
    transferId?: boolean
    status?: boolean
    failureReason?: boolean
    createdAt?: boolean
    processedAt?: boolean
    paidAt?: boolean
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    amount?: boolean
    currency?: boolean
    transferId?: boolean
    status?: boolean
    failureReason?: boolean
    createdAt?: boolean
    processedAt?: boolean
    paidAt?: boolean
  }, ExtArgs["result"]["payout"]>

  export type PayoutSelectScalar = {
    id?: boolean
    ownerId?: boolean
    amount?: boolean
    currency?: boolean
    transferId?: boolean
    status?: boolean
    failureReason?: boolean
    createdAt?: boolean
    processedAt?: boolean
    paidAt?: boolean
  }

  export type PayoutOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "amount" | "currency" | "transferId" | "status" | "failureReason" | "createdAt" | "processedAt" | "paidAt", ExtArgs["result"]["payout"]>

  export type $PayoutPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payout"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      amount: number
      currency: string
      transferId: string | null
      status: $Enums.PayoutStatus
      failureReason: string | null
      createdAt: Date
      processedAt: Date | null
      paidAt: Date | null
    }, ExtArgs["result"]["payout"]>
    composites: {}
  }

  type PayoutGetPayload<S extends boolean | null | undefined | PayoutDefaultArgs> = $Result.GetResult<Prisma.$PayoutPayload, S>

  type PayoutCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayoutFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayoutCountAggregateInputType | true
    }

  export interface PayoutDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payout'], meta: { name: 'Payout' } }
    /**
     * Find zero or one Payout that matches the filter.
     * @param {PayoutFindUniqueArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayoutFindUniqueArgs>(args: SelectSubset<T, PayoutFindUniqueArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payout that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayoutFindUniqueOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayoutFindUniqueOrThrowArgs>(args: SelectSubset<T, PayoutFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayoutFindFirstArgs>(args?: SelectSubset<T, PayoutFindFirstArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payout that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindFirstOrThrowArgs} args - Arguments to find a Payout
     * @example
     * // Get one Payout
     * const payout = await prisma.payout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayoutFindFirstOrThrowArgs>(args?: SelectSubset<T, PayoutFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payout.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutWithIdOnly = await prisma.payout.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayoutFindManyArgs>(args?: SelectSubset<T, PayoutFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payout.
     * @param {PayoutCreateArgs} args - Arguments to create a Payout.
     * @example
     * // Create one Payout
     * const Payout = await prisma.payout.create({
     *   data: {
     *     // ... data to create a Payout
     *   }
     * })
     * 
     */
    create<T extends PayoutCreateArgs>(args: SelectSubset<T, PayoutCreateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payouts.
     * @param {PayoutCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayoutCreateManyArgs>(args?: SelectSubset<T, PayoutCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {PayoutCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payout = await prisma.payout.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayoutCreateManyAndReturnArgs>(args?: SelectSubset<T, PayoutCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payout.
     * @param {PayoutDeleteArgs} args - Arguments to delete one Payout.
     * @example
     * // Delete one Payout
     * const Payout = await prisma.payout.delete({
     *   where: {
     *     // ... filter to delete one Payout
     *   }
     * })
     * 
     */
    delete<T extends PayoutDeleteArgs>(args: SelectSubset<T, PayoutDeleteArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payout.
     * @param {PayoutUpdateArgs} args - Arguments to update one Payout.
     * @example
     * // Update one Payout
     * const payout = await prisma.payout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayoutUpdateArgs>(args: SelectSubset<T, PayoutUpdateArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayoutDeleteManyArgs>(args?: SelectSubset<T, PayoutDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayoutUpdateManyArgs>(args: SelectSubset<T, PayoutUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts and returns the data updated in the database.
     * @param {PayoutUpdateManyAndReturnArgs} args - Arguments to update many Payouts.
     * @example
     * // Update many Payouts
     * const payout = await prisma.payout.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payouts and only return the `id`
     * const payoutWithIdOnly = await prisma.payout.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayoutUpdateManyAndReturnArgs>(args: SelectSubset<T, PayoutUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payout.
     * @param {PayoutUpsertArgs} args - Arguments to update or create a Payout.
     * @example
     * // Update or create a Payout
     * const payout = await prisma.payout.upsert({
     *   create: {
     *     // ... data to create a Payout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payout we want to update
     *   }
     * })
     */
    upsert<T extends PayoutUpsertArgs>(args: SelectSubset<T, PayoutUpsertArgs<ExtArgs>>): Prisma__PayoutClient<$Result.GetResult<Prisma.$PayoutPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payout.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutCountArgs>(
      args?: Subset<T, PayoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutAggregateArgs>(args: Subset<T, PayoutAggregateArgs>): Prisma.PrismaPromise<GetPayoutAggregateType<T>>

    /**
     * Group by Payout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutGroupByArgs['orderBy'] }
        : { orderBy?: PayoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payout model
   */
  readonly fields: PayoutFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payout model
   */
  interface PayoutFieldRefs {
    readonly id: FieldRef<"Payout", 'String'>
    readonly ownerId: FieldRef<"Payout", 'String'>
    readonly amount: FieldRef<"Payout", 'Float'>
    readonly currency: FieldRef<"Payout", 'String'>
    readonly transferId: FieldRef<"Payout", 'String'>
    readonly status: FieldRef<"Payout", 'PayoutStatus'>
    readonly failureReason: FieldRef<"Payout", 'String'>
    readonly createdAt: FieldRef<"Payout", 'DateTime'>
    readonly processedAt: FieldRef<"Payout", 'DateTime'>
    readonly paidAt: FieldRef<"Payout", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payout findUnique
   */
  export type PayoutFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findUniqueOrThrow
   */
  export type PayoutFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout findFirst
   */
  export type PayoutFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findFirstOrThrow
   */
  export type PayoutFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter, which Payout to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout findMany
   */
  export type PayoutFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutOrderByWithRelationInput | PayoutOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutScalarFieldEnum | PayoutScalarFieldEnum[]
  }

  /**
   * Payout create
   */
  export type PayoutCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data needed to create a Payout.
     */
    data: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
  }

  /**
   * Payout createMany
   */
  export type PayoutCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payout createManyAndReturn
   */
  export type PayoutCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data used to create many Payouts.
     */
    data: PayoutCreateManyInput | PayoutCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payout update
   */
  export type PayoutUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data needed to update a Payout.
     */
    data: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
    /**
     * Choose, which Payout to update.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout updateMany
   */
  export type PayoutUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to update.
     */
    limit?: number
  }

  /**
   * Payout updateManyAndReturn
   */
  export type PayoutUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutUpdateManyMutationInput, PayoutUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to update.
     */
    limit?: number
  }

  /**
   * Payout upsert
   */
  export type PayoutUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * The filter to search for the Payout to update in case it exists.
     */
    where: PayoutWhereUniqueInput
    /**
     * In case the Payout found by the `where` argument doesn't exist, create a new Payout with this data.
     */
    create: XOR<PayoutCreateInput, PayoutUncheckedCreateInput>
    /**
     * In case the Payout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutUpdateInput, PayoutUncheckedUpdateInput>
  }

  /**
   * Payout delete
   */
  export type PayoutDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
    /**
     * Filter which Payout to delete.
     */
    where: PayoutWhereUniqueInput
  }

  /**
   * Payout deleteMany
   */
  export type PayoutDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutWhereInput
    /**
     * Limit how many Payouts to delete.
     */
    limit?: number
  }

  /**
   * Payout without action
   */
  export type PayoutDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payout
     */
    select?: PayoutSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payout
     */
    omit?: PayoutOmit<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    overallRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    cleanlinessRating: number | null
    valueRating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    overallRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    cleanlinessRating: number | null
    valueRating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    listingId: string | null
    reviewerId: string | null
    revieweeId: string | null
    type: $Enums.ReviewType | null
    overallRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    cleanlinessRating: number | null
    valueRating: number | null
    title: string | null
    content: string | null
    response: string | null
    respondedAt: Date | null
    status: $Enums.ReviewStatus | null
    flagged: boolean | null
    flagReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    listingId: string | null
    reviewerId: string | null
    revieweeId: string | null
    type: $Enums.ReviewType | null
    overallRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    cleanlinessRating: number | null
    valueRating: number | null
    title: string | null
    content: string | null
    response: string | null
    respondedAt: Date | null
    status: $Enums.ReviewStatus | null
    flagged: boolean | null
    flagReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    bookingId: number
    listingId: number
    reviewerId: number
    revieweeId: number
    type: number
    overallRating: number
    accuracyRating: number
    communicationRating: number
    cleanlinessRating: number
    valueRating: number
    title: number
    content: number
    response: number
    respondedAt: number
    status: number
    flagged: number
    flagReason: number
    moderatedBy: number
    moderatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    overallRating?: true
    accuracyRating?: true
    communicationRating?: true
    cleanlinessRating?: true
    valueRating?: true
  }

  export type ReviewSumAggregateInputType = {
    overallRating?: true
    accuracyRating?: true
    communicationRating?: true
    cleanlinessRating?: true
    valueRating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    reviewerId?: true
    revieweeId?: true
    type?: true
    overallRating?: true
    accuracyRating?: true
    communicationRating?: true
    cleanlinessRating?: true
    valueRating?: true
    title?: true
    content?: true
    response?: true
    respondedAt?: true
    status?: true
    flagged?: true
    flagReason?: true
    moderatedBy?: true
    moderatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    reviewerId?: true
    revieweeId?: true
    type?: true
    overallRating?: true
    accuracyRating?: true
    communicationRating?: true
    cleanlinessRating?: true
    valueRating?: true
    title?: true
    content?: true
    response?: true
    respondedAt?: true
    status?: true
    flagged?: true
    flagReason?: true
    moderatedBy?: true
    moderatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    reviewerId?: true
    revieweeId?: true
    type?: true
    overallRating?: true
    accuracyRating?: true
    communicationRating?: true
    cleanlinessRating?: true
    valueRating?: true
    title?: true
    content?: true
    response?: true
    respondedAt?: true
    status?: true
    flagged?: true
    flagReason?: true
    moderatedBy?: true
    moderatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    bookingId: string
    listingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating: number | null
    communicationRating: number | null
    cleanlinessRating: number | null
    valueRating: number | null
    title: string | null
    content: string
    response: string | null
    respondedAt: Date | null
    status: $Enums.ReviewStatus
    flagged: boolean
    flagReason: string | null
    moderatedBy: string | null
    moderatedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    type?: boolean
    overallRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    cleanlinessRating?: boolean
    valueRating?: boolean
    title?: boolean
    content?: boolean
    response?: boolean
    respondedAt?: boolean
    status?: boolean
    flagged?: boolean
    flagReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    type?: boolean
    overallRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    cleanlinessRating?: boolean
    valueRating?: boolean
    title?: boolean
    content?: boolean
    response?: boolean
    respondedAt?: boolean
    status?: boolean
    flagged?: boolean
    flagReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    type?: boolean
    overallRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    cleanlinessRating?: boolean
    valueRating?: boolean
    title?: boolean
    content?: boolean
    response?: boolean
    respondedAt?: boolean
    status?: boolean
    flagged?: boolean
    flagReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    reviewerId?: boolean
    revieweeId?: boolean
    type?: boolean
    overallRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    cleanlinessRating?: boolean
    valueRating?: boolean
    title?: boolean
    content?: boolean
    response?: boolean
    respondedAt?: boolean
    status?: boolean
    flagged?: boolean
    flagReason?: boolean
    moderatedBy?: boolean
    moderatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "listingId" | "reviewerId" | "revieweeId" | "type" | "overallRating" | "accuracyRating" | "communicationRating" | "cleanlinessRating" | "valueRating" | "title" | "content" | "response" | "respondedAt" | "status" | "flagged" | "flagReason" | "moderatedBy" | "moderatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reviewer?: boolean | UserDefaultArgs<ExtArgs>
    reviewee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs>
      reviewee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      listingId: string
      reviewerId: string
      revieweeId: string
      type: $Enums.ReviewType
      overallRating: number
      accuracyRating: number | null
      communicationRating: number | null
      cleanlinessRating: number | null
      valueRating: number | null
      title: string | null
      content: string
      response: string | null
      respondedAt: Date | null
      status: $Enums.ReviewStatus
      flagged: boolean
      flagReason: string | null
      moderatedBy: string | null
      moderatedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly bookingId: FieldRef<"Review", 'String'>
    readonly listingId: FieldRef<"Review", 'String'>
    readonly reviewerId: FieldRef<"Review", 'String'>
    readonly revieweeId: FieldRef<"Review", 'String'>
    readonly type: FieldRef<"Review", 'ReviewType'>
    readonly overallRating: FieldRef<"Review", 'Float'>
    readonly accuracyRating: FieldRef<"Review", 'Float'>
    readonly communicationRating: FieldRef<"Review", 'Float'>
    readonly cleanlinessRating: FieldRef<"Review", 'Float'>
    readonly valueRating: FieldRef<"Review", 'Float'>
    readonly title: FieldRef<"Review", 'String'>
    readonly content: FieldRef<"Review", 'String'>
    readonly response: FieldRef<"Review", 'String'>
    readonly respondedAt: FieldRef<"Review", 'DateTime'>
    readonly status: FieldRef<"Review", 'ReviewStatus'>
    readonly flagged: FieldRef<"Review", 'Boolean'>
    readonly flagReason: FieldRef<"Review", 'String'>
    readonly moderatedBy: FieldRef<"Review", 'String'>
    readonly moderatedAt: FieldRef<"Review", 'DateTime'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    listingId: string | null
    type: $Enums.ConversationType | null
    subject: string | null
    lastMessageAt: Date | null
    lastMessagePreview: string | null
    status: $Enums.ConversationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    listingId: string | null
    type: $Enums.ConversationType | null
    subject: string | null
    lastMessageAt: Date | null
    lastMessagePreview: string | null
    status: $Enums.ConversationStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    bookingId: number
    listingId: number
    type: number
    subject: number
    lastMessageAt: number
    lastMessagePreview: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    type?: true
    subject?: true
    lastMessageAt?: true
    lastMessagePreview?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    type?: true
    subject?: true
    lastMessageAt?: true
    lastMessagePreview?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    bookingId?: true
    listingId?: true
    type?: true
    subject?: true
    lastMessageAt?: true
    lastMessagePreview?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    bookingId: string | null
    listingId: string | null
    type: $Enums.ConversationType
    subject: string | null
    lastMessageAt: Date | null
    lastMessagePreview: string | null
    status: $Enums.ConversationStatus
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    type?: boolean
    subject?: boolean
    lastMessageAt?: boolean
    lastMessagePreview?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    type?: boolean
    subject?: boolean
    lastMessageAt?: boolean
    lastMessagePreview?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    type?: boolean
    subject?: boolean
    lastMessageAt?: boolean
    lastMessagePreview?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    bookingId?: boolean
    listingId?: boolean
    type?: boolean
    subject?: boolean
    lastMessageAt?: boolean
    lastMessagePreview?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "listingId" | "type" | "subject" | "lastMessageAt" | "lastMessagePreview" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | Conversation$bookingArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs> | null
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string | null
      listingId: string | null
      type: $Enums.ConversationType
      subject: string | null
      lastMessageAt: Date | null
      lastMessagePreview: string | null
      status: $Enums.ConversationStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends Conversation$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly bookingId: FieldRef<"Conversation", 'String'>
    readonly listingId: FieldRef<"Conversation", 'String'>
    readonly type: FieldRef<"Conversation", 'ConversationType'>
    readonly subject: FieldRef<"Conversation", 'String'>
    readonly lastMessageAt: FieldRef<"Conversation", 'DateTime'>
    readonly lastMessagePreview: FieldRef<"Conversation", 'String'>
    readonly status: FieldRef<"Conversation", 'ConversationStatus'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.booking
   */
  export type Conversation$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    muted: boolean | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    userId: string | null
    muted: boolean | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    userId: number
    muted: number
    lastReadAt: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    muted?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    muted?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
    muted?: true
    lastReadAt?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    userId: string
    muted: boolean
    lastReadAt: Date | null
    joinedAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    muted?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    muted?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    muted?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    userId?: boolean
    muted?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "userId" | "muted" | "lastReadAt" | "joinedAt", ExtArgs["result"]["conversationParticipant"]>
  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      userId: string
      muted: boolean
      lastReadAt: Date | null
      joinedAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants and returns the data updated in the database.
     * @param {ConversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many ConversationParticipants.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */
  interface ConversationParticipantFieldRefs {
    readonly id: FieldRef<"ConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly userId: FieldRef<"ConversationParticipant", 'String'>
    readonly muted: FieldRef<"ConversationParticipant", 'Boolean'>
    readonly lastReadAt: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
  }

  /**
   * ConversationParticipant updateManyAndReturn
   */
  export type ConversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    type: $Enums.MessageType | null
    content: string | null
    status: $Enums.MessageStatus | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    type: $Enums.MessageType | null
    content: string | null
    status: $Enums.MessageStatus | null
    createdAt: Date | null
    editedAt: Date | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    type: number
    content: number
    attachments: number
    metadata: number
    status: number
    createdAt: number
    editedAt: number
    deletedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    type?: true
    content?: true
    status?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    type?: true
    content?: true
    status?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    type?: true
    content?: true
    attachments?: true
    metadata?: true
    status?: true
    createdAt?: true
    editedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    type: $Enums.MessageType
    content: string
    attachments: JsonValue
    metadata: JsonValue
    status: $Enums.MessageStatus
    createdAt: Date
    editedAt: Date | null
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    readReceipts?: boolean | Message$readReceiptsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    type?: boolean
    content?: boolean
    attachments?: boolean
    metadata?: boolean
    status?: boolean
    createdAt?: boolean
    editedAt?: boolean
    deletedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "type" | "content" | "attachments" | "metadata" | "status" | "createdAt" | "editedAt" | "deletedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
    readReceipts?: boolean | Message$readReceiptsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
      readReceipts: Prisma.$MessageReadReceiptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      type: $Enums.MessageType
      content: string
      attachments: Prisma.JsonValue
      metadata: Prisma.JsonValue
      status: $Enums.MessageStatus
      createdAt: Date
      editedAt: Date | null
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    readReceipts<T extends Message$readReceiptsArgs<ExtArgs> = {}>(args?: Subset<T, Message$readReceiptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly content: FieldRef<"Message", 'String'>
    readonly attachments: FieldRef<"Message", 'Json'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly status: FieldRef<"Message", 'MessageStatus'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly editedAt: FieldRef<"Message", 'DateTime'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.readReceipts
   */
  export type Message$readReceiptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    where?: MessageReadReceiptWhereInput
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    cursor?: MessageReadReceiptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageReadReceipt
   */

  export type AggregateMessageReadReceipt = {
    _count: MessageReadReceiptCountAggregateOutputType | null
    _min: MessageReadReceiptMinAggregateOutputType | null
    _max: MessageReadReceiptMaxAggregateOutputType | null
  }

  export type MessageReadReceiptMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadReceiptMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadReceiptCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadReceiptMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadReceiptMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadReceiptCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadReceiptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReadReceipt to aggregate.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReadReceipts
    **/
    _count?: true | MessageReadReceiptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadReceiptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadReceiptMaxAggregateInputType
  }

  export type GetMessageReadReceiptAggregateType<T extends MessageReadReceiptAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageReadReceipt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageReadReceipt[P]>
      : GetScalarType<T[P], AggregateMessageReadReceipt[P]>
  }




  export type MessageReadReceiptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadReceiptWhereInput
    orderBy?: MessageReadReceiptOrderByWithAggregationInput | MessageReadReceiptOrderByWithAggregationInput[]
    by: MessageReadReceiptScalarFieldEnum[] | MessageReadReceiptScalarFieldEnum
    having?: MessageReadReceiptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadReceiptCountAggregateInputType | true
    _min?: MessageReadReceiptMinAggregateInputType
    _max?: MessageReadReceiptMaxAggregateInputType
  }

  export type MessageReadReceiptGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadReceiptCountAggregateOutputType | null
    _min: MessageReadReceiptMinAggregateOutputType | null
    _max: MessageReadReceiptMaxAggregateOutputType | null
  }

  type GetMessageReadReceiptGroupByPayload<T extends MessageReadReceiptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadReceiptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadReceiptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadReceiptGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadReceiptGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadReceiptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReadReceipt"]>

  export type MessageReadReceiptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReadReceipt"]>

  export type MessageReadReceiptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageReadReceipt"]>

  export type MessageReadReceiptSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadReceiptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "userId" | "readAt", ExtArgs["result"]["messageReadReceipt"]>
  export type MessageReadReceiptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageReadReceiptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }
  export type MessageReadReceiptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
  }

  export type $MessageReadReceiptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageReadReceipt"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageReadReceipt"]>
    composites: {}
  }

  type MessageReadReceiptGetPayload<S extends boolean | null | undefined | MessageReadReceiptDefaultArgs> = $Result.GetResult<Prisma.$MessageReadReceiptPayload, S>

  type MessageReadReceiptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageReadReceiptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageReadReceiptCountAggregateInputType | true
    }

  export interface MessageReadReceiptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageReadReceipt'], meta: { name: 'MessageReadReceipt' } }
    /**
     * Find zero or one MessageReadReceipt that matches the filter.
     * @param {MessageReadReceiptFindUniqueArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadReceiptFindUniqueArgs>(args: SelectSubset<T, MessageReadReceiptFindUniqueArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageReadReceipt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageReadReceiptFindUniqueOrThrowArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadReceiptFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageReadReceipt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindFirstArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadReceiptFindFirstArgs>(args?: SelectSubset<T, MessageReadReceiptFindFirstArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageReadReceipt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindFirstOrThrowArgs} args - Arguments to find a MessageReadReceipt
     * @example
     * // Get one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadReceiptFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadReceiptFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageReadReceipts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReadReceipts
     * const messageReadReceipts = await prisma.messageReadReceipt.findMany()
     * 
     * // Get first 10 MessageReadReceipts
     * const messageReadReceipts = await prisma.messageReadReceipt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageReadReceiptWithIdOnly = await prisma.messageReadReceipt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageReadReceiptFindManyArgs>(args?: SelectSubset<T, MessageReadReceiptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageReadReceipt.
     * @param {MessageReadReceiptCreateArgs} args - Arguments to create a MessageReadReceipt.
     * @example
     * // Create one MessageReadReceipt
     * const MessageReadReceipt = await prisma.messageReadReceipt.create({
     *   data: {
     *     // ... data to create a MessageReadReceipt
     *   }
     * })
     * 
     */
    create<T extends MessageReadReceiptCreateArgs>(args: SelectSubset<T, MessageReadReceiptCreateArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageReadReceipts.
     * @param {MessageReadReceiptCreateManyArgs} args - Arguments to create many MessageReadReceipts.
     * @example
     * // Create many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadReceiptCreateManyArgs>(args?: SelectSubset<T, MessageReadReceiptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReadReceipts and returns the data saved in the database.
     * @param {MessageReadReceiptCreateManyAndReturnArgs} args - Arguments to create many MessageReadReceipts.
     * @example
     * // Create many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReadReceipts and only return the `id`
     * const messageReadReceiptWithIdOnly = await prisma.messageReadReceipt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadReceiptCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadReceiptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageReadReceipt.
     * @param {MessageReadReceiptDeleteArgs} args - Arguments to delete one MessageReadReceipt.
     * @example
     * // Delete one MessageReadReceipt
     * const MessageReadReceipt = await prisma.messageReadReceipt.delete({
     *   where: {
     *     // ... filter to delete one MessageReadReceipt
     *   }
     * })
     * 
     */
    delete<T extends MessageReadReceiptDeleteArgs>(args: SelectSubset<T, MessageReadReceiptDeleteArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageReadReceipt.
     * @param {MessageReadReceiptUpdateArgs} args - Arguments to update one MessageReadReceipt.
     * @example
     * // Update one MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadReceiptUpdateArgs>(args: SelectSubset<T, MessageReadReceiptUpdateArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageReadReceipts.
     * @param {MessageReadReceiptDeleteManyArgs} args - Arguments to filter MessageReadReceipts to delete.
     * @example
     * // Delete a few MessageReadReceipts
     * const { count } = await prisma.messageReadReceipt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadReceiptDeleteManyArgs>(args?: SelectSubset<T, MessageReadReceiptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadReceiptUpdateManyArgs>(args: SelectSubset<T, MessageReadReceiptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReadReceipts and returns the data updated in the database.
     * @param {MessageReadReceiptUpdateManyAndReturnArgs} args - Arguments to update many MessageReadReceipts.
     * @example
     * // Update many MessageReadReceipts
     * const messageReadReceipt = await prisma.messageReadReceipt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageReadReceipts and only return the `id`
     * const messageReadReceiptWithIdOnly = await prisma.messageReadReceipt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageReadReceiptUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageReadReceiptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageReadReceipt.
     * @param {MessageReadReceiptUpsertArgs} args - Arguments to update or create a MessageReadReceipt.
     * @example
     * // Update or create a MessageReadReceipt
     * const messageReadReceipt = await prisma.messageReadReceipt.upsert({
     *   create: {
     *     // ... data to create a MessageReadReceipt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageReadReceipt we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadReceiptUpsertArgs>(args: SelectSubset<T, MessageReadReceiptUpsertArgs<ExtArgs>>): Prisma__MessageReadReceiptClient<$Result.GetResult<Prisma.$MessageReadReceiptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageReadReceipts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptCountArgs} args - Arguments to filter MessageReadReceipts to count.
     * @example
     * // Count the number of MessageReadReceipts
     * const count = await prisma.messageReadReceipt.count({
     *   where: {
     *     // ... the filter for the MessageReadReceipts we want to count
     *   }
     * })
    **/
    count<T extends MessageReadReceiptCountArgs>(
      args?: Subset<T, MessageReadReceiptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadReceiptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadReceiptAggregateArgs>(args: Subset<T, MessageReadReceiptAggregateArgs>): Prisma.PrismaPromise<GetMessageReadReceiptAggregateType<T>>

    /**
     * Group by MessageReadReceipt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadReceiptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadReceiptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadReceiptGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadReceiptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadReceiptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadReceiptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageReadReceipt model
   */
  readonly fields: MessageReadReceiptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageReadReceipt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadReceiptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageReadReceipt model
   */
  interface MessageReadReceiptFieldRefs {
    readonly id: FieldRef<"MessageReadReceipt", 'String'>
    readonly messageId: FieldRef<"MessageReadReceipt", 'String'>
    readonly userId: FieldRef<"MessageReadReceipt", 'String'>
    readonly readAt: FieldRef<"MessageReadReceipt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageReadReceipt findUnique
   */
  export type MessageReadReceiptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt findUniqueOrThrow
   */
  export type MessageReadReceiptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt findFirst
   */
  export type MessageReadReceiptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReadReceipts.
     */
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt findFirstOrThrow
   */
  export type MessageReadReceiptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipt to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReadReceipts.
     */
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt findMany
   */
  export type MessageReadReceiptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter, which MessageReadReceipts to fetch.
     */
    where?: MessageReadReceiptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReadReceipts to fetch.
     */
    orderBy?: MessageReadReceiptOrderByWithRelationInput | MessageReadReceiptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReadReceipts.
     */
    cursor?: MessageReadReceiptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReadReceipts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReadReceipts.
     */
    skip?: number
    distinct?: MessageReadReceiptScalarFieldEnum | MessageReadReceiptScalarFieldEnum[]
  }

  /**
   * MessageReadReceipt create
   */
  export type MessageReadReceiptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageReadReceipt.
     */
    data: XOR<MessageReadReceiptCreateInput, MessageReadReceiptUncheckedCreateInput>
  }

  /**
   * MessageReadReceipt createMany
   */
  export type MessageReadReceiptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReadReceipts.
     */
    data: MessageReadReceiptCreateManyInput | MessageReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageReadReceipt createManyAndReturn
   */
  export type MessageReadReceiptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * The data used to create many MessageReadReceipts.
     */
    data: MessageReadReceiptCreateManyInput | MessageReadReceiptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReadReceipt update
   */
  export type MessageReadReceiptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageReadReceipt.
     */
    data: XOR<MessageReadReceiptUpdateInput, MessageReadReceiptUncheckedUpdateInput>
    /**
     * Choose, which MessageReadReceipt to update.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt updateMany
   */
  export type MessageReadReceiptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReadReceipts.
     */
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyInput>
    /**
     * Filter which MessageReadReceipts to update
     */
    where?: MessageReadReceiptWhereInput
    /**
     * Limit how many MessageReadReceipts to update.
     */
    limit?: number
  }

  /**
   * MessageReadReceipt updateManyAndReturn
   */
  export type MessageReadReceiptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * The data used to update MessageReadReceipts.
     */
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyInput>
    /**
     * Filter which MessageReadReceipts to update
     */
    where?: MessageReadReceiptWhereInput
    /**
     * Limit how many MessageReadReceipts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageReadReceipt upsert
   */
  export type MessageReadReceiptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageReadReceipt to update in case it exists.
     */
    where: MessageReadReceiptWhereUniqueInput
    /**
     * In case the MessageReadReceipt found by the `where` argument doesn't exist, create a new MessageReadReceipt with this data.
     */
    create: XOR<MessageReadReceiptCreateInput, MessageReadReceiptUncheckedCreateInput>
    /**
     * In case the MessageReadReceipt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadReceiptUpdateInput, MessageReadReceiptUncheckedUpdateInput>
  }

  /**
   * MessageReadReceipt delete
   */
  export type MessageReadReceiptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
    /**
     * Filter which MessageReadReceipt to delete.
     */
    where: MessageReadReceiptWhereUniqueInput
  }

  /**
   * MessageReadReceipt deleteMany
   */
  export type MessageReadReceiptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReadReceipts to delete
     */
    where?: MessageReadReceiptWhereInput
    /**
     * Limit how many MessageReadReceipts to delete.
     */
    limit?: number
  }

  /**
   * MessageReadReceipt without action
   */
  export type MessageReadReceiptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageReadReceipt
     */
    select?: MessageReadReceiptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageReadReceipt
     */
    omit?: MessageReadReceiptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadReceiptInclude<ExtArgs> | null
  }


  /**
   * Model ConditionReport
   */

  export type AggregateConditionReport = {
    _count: ConditionReportCountAggregateOutputType | null
    _avg: ConditionReportAvgAggregateOutputType | null
    _sum: ConditionReportSumAggregateOutputType | null
    _min: ConditionReportMinAggregateOutputType | null
    _max: ConditionReportMaxAggregateOutputType | null
  }

  export type ConditionReportAvgAggregateOutputType = {
    damageAmount: number | null
  }

  export type ConditionReportSumAggregateOutputType = {
    damageAmount: number | null
  }

  export type ConditionReportMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    reportType: $Enums.ReportType | null
    type: $Enums.ReportType | null
    reportedBy: string | null
    reportedAt: Date | null
    overallCondition: string | null
    condition: string | null
    notes: string | null
    issuesFound: boolean | null
    damageAmount: number | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    disputeRaised: boolean | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ConditionReportMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    reportType: $Enums.ReportType | null
    type: $Enums.ReportType | null
    reportedBy: string | null
    reportedAt: Date | null
    overallCondition: string | null
    condition: string | null
    notes: string | null
    issuesFound: boolean | null
    damageAmount: number | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    disputeRaised: boolean | null
    status: $Enums.ReportStatus | null
    createdAt: Date | null
    completedAt: Date | null
  }

  export type ConditionReportCountAggregateOutputType = {
    id: number
    bookingId: number
    reportType: number
    type: number
    reportedBy: number
    reportedAt: number
    checklistData: number
    overallCondition: number
    condition: number
    notes: number
    damages: number
    issuesFound: number
    damageAmount: number
    acknowledgedBy: number
    acknowledgedAt: number
    disputeRaised: number
    status: number
    createdAt: number
    completedAt: number
    _all: number
  }


  export type ConditionReportAvgAggregateInputType = {
    damageAmount?: true
  }

  export type ConditionReportSumAggregateInputType = {
    damageAmount?: true
  }

  export type ConditionReportMinAggregateInputType = {
    id?: true
    bookingId?: true
    reportType?: true
    type?: true
    reportedBy?: true
    reportedAt?: true
    overallCondition?: true
    condition?: true
    notes?: true
    issuesFound?: true
    damageAmount?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    disputeRaised?: true
    status?: true
    createdAt?: true
    completedAt?: true
  }

  export type ConditionReportMaxAggregateInputType = {
    id?: true
    bookingId?: true
    reportType?: true
    type?: true
    reportedBy?: true
    reportedAt?: true
    overallCondition?: true
    condition?: true
    notes?: true
    issuesFound?: true
    damageAmount?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    disputeRaised?: true
    status?: true
    createdAt?: true
    completedAt?: true
  }

  export type ConditionReportCountAggregateInputType = {
    id?: true
    bookingId?: true
    reportType?: true
    type?: true
    reportedBy?: true
    reportedAt?: true
    checklistData?: true
    overallCondition?: true
    condition?: true
    notes?: true
    damages?: true
    issuesFound?: true
    damageAmount?: true
    acknowledgedBy?: true
    acknowledgedAt?: true
    disputeRaised?: true
    status?: true
    createdAt?: true
    completedAt?: true
    _all?: true
  }

  export type ConditionReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConditionReport to aggregate.
     */
    where?: ConditionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionReports to fetch.
     */
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConditionReports
    **/
    _count?: true | ConditionReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConditionReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConditionReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionReportMaxAggregateInputType
  }

  export type GetConditionReportAggregateType<T extends ConditionReportAggregateArgs> = {
        [P in keyof T & keyof AggregateConditionReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConditionReport[P]>
      : GetScalarType<T[P], AggregateConditionReport[P]>
  }




  export type ConditionReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConditionReportWhereInput
    orderBy?: ConditionReportOrderByWithAggregationInput | ConditionReportOrderByWithAggregationInput[]
    by: ConditionReportScalarFieldEnum[] | ConditionReportScalarFieldEnum
    having?: ConditionReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionReportCountAggregateInputType | true
    _avg?: ConditionReportAvgAggregateInputType
    _sum?: ConditionReportSumAggregateInputType
    _min?: ConditionReportMinAggregateInputType
    _max?: ConditionReportMaxAggregateInputType
  }

  export type ConditionReportGroupByOutputType = {
    id: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt: Date
    checklistData: JsonValue
    overallCondition: string | null
    condition: string | null
    notes: string | null
    damages: JsonValue | null
    issuesFound: boolean
    damageAmount: number | null
    acknowledgedBy: string | null
    acknowledgedAt: Date | null
    disputeRaised: boolean
    status: $Enums.ReportStatus
    createdAt: Date
    completedAt: Date | null
    _count: ConditionReportCountAggregateOutputType | null
    _avg: ConditionReportAvgAggregateOutputType | null
    _sum: ConditionReportSumAggregateOutputType | null
    _min: ConditionReportMinAggregateOutputType | null
    _max: ConditionReportMaxAggregateOutputType | null
  }

  type GetConditionReportGroupByPayload<T extends ConditionReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionReportGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionReportGroupByOutputType[P]>
        }
      >
    >


  export type ConditionReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reportType?: boolean
    type?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    checklistData?: boolean
    overallCondition?: boolean
    condition?: boolean
    notes?: boolean
    damages?: boolean
    issuesFound?: boolean
    damageAmount?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    disputeRaised?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
    photos?: boolean | ConditionReport$photosArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
    dispute?: boolean | ConditionReport$disputeArgs<ExtArgs>
    _count?: boolean | ConditionReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditionReport"]>

  export type ConditionReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reportType?: boolean
    type?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    checklistData?: boolean
    overallCondition?: boolean
    condition?: boolean
    notes?: boolean
    damages?: boolean
    issuesFound?: boolean
    damageAmount?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    disputeRaised?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditionReport"]>

  export type ConditionReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    reportType?: boolean
    type?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    checklistData?: boolean
    overallCondition?: boolean
    condition?: boolean
    notes?: boolean
    damages?: boolean
    issuesFound?: boolean
    damageAmount?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    disputeRaised?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conditionReport"]>

  export type ConditionReportSelectScalar = {
    id?: boolean
    bookingId?: boolean
    reportType?: boolean
    type?: boolean
    reportedBy?: boolean
    reportedAt?: boolean
    checklistData?: boolean
    overallCondition?: boolean
    condition?: boolean
    notes?: boolean
    damages?: boolean
    issuesFound?: boolean
    damageAmount?: boolean
    acknowledgedBy?: boolean
    acknowledgedAt?: boolean
    disputeRaised?: boolean
    status?: boolean
    createdAt?: boolean
    completedAt?: boolean
  }

  export type ConditionReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "reportType" | "type" | "reportedBy" | "reportedAt" | "checklistData" | "overallCondition" | "condition" | "notes" | "damages" | "issuesFound" | "damageAmount" | "acknowledgedBy" | "acknowledgedAt" | "disputeRaised" | "status" | "createdAt" | "completedAt", ExtArgs["result"]["conditionReport"]>
  export type ConditionReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ConditionReport$photosArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
    dispute?: boolean | ConditionReport$disputeArgs<ExtArgs>
    _count?: boolean | ConditionReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConditionReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ConditionReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    reportedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ConditionReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConditionReport"
    objects: {
      photos: Prisma.$ReportPhotoPayload<ExtArgs>[]
      booking: Prisma.$BookingPayload<ExtArgs>
      reportedByUser: Prisma.$UserPayload<ExtArgs>
      dispute: Prisma.$DisputePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      reportType: $Enums.ReportType
      type: $Enums.ReportType
      reportedBy: string
      reportedAt: Date
      checklistData: Prisma.JsonValue
      overallCondition: string | null
      condition: string | null
      notes: string | null
      damages: Prisma.JsonValue | null
      issuesFound: boolean
      damageAmount: number | null
      acknowledgedBy: string | null
      acknowledgedAt: Date | null
      disputeRaised: boolean
      status: $Enums.ReportStatus
      createdAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["conditionReport"]>
    composites: {}
  }

  type ConditionReportGetPayload<S extends boolean | null | undefined | ConditionReportDefaultArgs> = $Result.GetResult<Prisma.$ConditionReportPayload, S>

  type ConditionReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConditionReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConditionReportCountAggregateInputType | true
    }

  export interface ConditionReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConditionReport'], meta: { name: 'ConditionReport' } }
    /**
     * Find zero or one ConditionReport that matches the filter.
     * @param {ConditionReportFindUniqueArgs} args - Arguments to find a ConditionReport
     * @example
     * // Get one ConditionReport
     * const conditionReport = await prisma.conditionReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConditionReportFindUniqueArgs>(args: SelectSubset<T, ConditionReportFindUniqueArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConditionReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConditionReportFindUniqueOrThrowArgs} args - Arguments to find a ConditionReport
     * @example
     * // Get one ConditionReport
     * const conditionReport = await prisma.conditionReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConditionReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ConditionReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConditionReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportFindFirstArgs} args - Arguments to find a ConditionReport
     * @example
     * // Get one ConditionReport
     * const conditionReport = await prisma.conditionReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConditionReportFindFirstArgs>(args?: SelectSubset<T, ConditionReportFindFirstArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConditionReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportFindFirstOrThrowArgs} args - Arguments to find a ConditionReport
     * @example
     * // Get one ConditionReport
     * const conditionReport = await prisma.conditionReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConditionReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ConditionReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConditionReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConditionReports
     * const conditionReports = await prisma.conditionReport.findMany()
     * 
     * // Get first 10 ConditionReports
     * const conditionReports = await prisma.conditionReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionReportWithIdOnly = await prisma.conditionReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConditionReportFindManyArgs>(args?: SelectSubset<T, ConditionReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConditionReport.
     * @param {ConditionReportCreateArgs} args - Arguments to create a ConditionReport.
     * @example
     * // Create one ConditionReport
     * const ConditionReport = await prisma.conditionReport.create({
     *   data: {
     *     // ... data to create a ConditionReport
     *   }
     * })
     * 
     */
    create<T extends ConditionReportCreateArgs>(args: SelectSubset<T, ConditionReportCreateArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConditionReports.
     * @param {ConditionReportCreateManyArgs} args - Arguments to create many ConditionReports.
     * @example
     * // Create many ConditionReports
     * const conditionReport = await prisma.conditionReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConditionReportCreateManyArgs>(args?: SelectSubset<T, ConditionReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConditionReports and returns the data saved in the database.
     * @param {ConditionReportCreateManyAndReturnArgs} args - Arguments to create many ConditionReports.
     * @example
     * // Create many ConditionReports
     * const conditionReport = await prisma.conditionReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConditionReports and only return the `id`
     * const conditionReportWithIdOnly = await prisma.conditionReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConditionReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ConditionReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConditionReport.
     * @param {ConditionReportDeleteArgs} args - Arguments to delete one ConditionReport.
     * @example
     * // Delete one ConditionReport
     * const ConditionReport = await prisma.conditionReport.delete({
     *   where: {
     *     // ... filter to delete one ConditionReport
     *   }
     * })
     * 
     */
    delete<T extends ConditionReportDeleteArgs>(args: SelectSubset<T, ConditionReportDeleteArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConditionReport.
     * @param {ConditionReportUpdateArgs} args - Arguments to update one ConditionReport.
     * @example
     * // Update one ConditionReport
     * const conditionReport = await prisma.conditionReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConditionReportUpdateArgs>(args: SelectSubset<T, ConditionReportUpdateArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConditionReports.
     * @param {ConditionReportDeleteManyArgs} args - Arguments to filter ConditionReports to delete.
     * @example
     * // Delete a few ConditionReports
     * const { count } = await prisma.conditionReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConditionReportDeleteManyArgs>(args?: SelectSubset<T, ConditionReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConditionReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConditionReports
     * const conditionReport = await prisma.conditionReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConditionReportUpdateManyArgs>(args: SelectSubset<T, ConditionReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConditionReports and returns the data updated in the database.
     * @param {ConditionReportUpdateManyAndReturnArgs} args - Arguments to update many ConditionReports.
     * @example
     * // Update many ConditionReports
     * const conditionReport = await prisma.conditionReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConditionReports and only return the `id`
     * const conditionReportWithIdOnly = await prisma.conditionReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConditionReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ConditionReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConditionReport.
     * @param {ConditionReportUpsertArgs} args - Arguments to update or create a ConditionReport.
     * @example
     * // Update or create a ConditionReport
     * const conditionReport = await prisma.conditionReport.upsert({
     *   create: {
     *     // ... data to create a ConditionReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConditionReport we want to update
     *   }
     * })
     */
    upsert<T extends ConditionReportUpsertArgs>(args: SelectSubset<T, ConditionReportUpsertArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConditionReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportCountArgs} args - Arguments to filter ConditionReports to count.
     * @example
     * // Count the number of ConditionReports
     * const count = await prisma.conditionReport.count({
     *   where: {
     *     // ... the filter for the ConditionReports we want to count
     *   }
     * })
    **/
    count<T extends ConditionReportCountArgs>(
      args?: Subset<T, ConditionReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConditionReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionReportAggregateArgs>(args: Subset<T, ConditionReportAggregateArgs>): Prisma.PrismaPromise<GetConditionReportAggregateType<T>>

    /**
     * Group by ConditionReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionReportGroupByArgs['orderBy'] }
        : { orderBy?: ConditionReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConditionReport model
   */
  readonly fields: ConditionReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConditionReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    photos<T extends ConditionReport$photosArgs<ExtArgs> = {}>(args?: Subset<T, ConditionReport$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reportedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dispute<T extends ConditionReport$disputeArgs<ExtArgs> = {}>(args?: Subset<T, ConditionReport$disputeArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConditionReport model
   */
  interface ConditionReportFieldRefs {
    readonly id: FieldRef<"ConditionReport", 'String'>
    readonly bookingId: FieldRef<"ConditionReport", 'String'>
    readonly reportType: FieldRef<"ConditionReport", 'ReportType'>
    readonly type: FieldRef<"ConditionReport", 'ReportType'>
    readonly reportedBy: FieldRef<"ConditionReport", 'String'>
    readonly reportedAt: FieldRef<"ConditionReport", 'DateTime'>
    readonly checklistData: FieldRef<"ConditionReport", 'Json'>
    readonly overallCondition: FieldRef<"ConditionReport", 'String'>
    readonly condition: FieldRef<"ConditionReport", 'String'>
    readonly notes: FieldRef<"ConditionReport", 'String'>
    readonly damages: FieldRef<"ConditionReport", 'Json'>
    readonly issuesFound: FieldRef<"ConditionReport", 'Boolean'>
    readonly damageAmount: FieldRef<"ConditionReport", 'Float'>
    readonly acknowledgedBy: FieldRef<"ConditionReport", 'String'>
    readonly acknowledgedAt: FieldRef<"ConditionReport", 'DateTime'>
    readonly disputeRaised: FieldRef<"ConditionReport", 'Boolean'>
    readonly status: FieldRef<"ConditionReport", 'ReportStatus'>
    readonly createdAt: FieldRef<"ConditionReport", 'DateTime'>
    readonly completedAt: FieldRef<"ConditionReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConditionReport findUnique
   */
  export type ConditionReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter, which ConditionReport to fetch.
     */
    where: ConditionReportWhereUniqueInput
  }

  /**
   * ConditionReport findUniqueOrThrow
   */
  export type ConditionReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter, which ConditionReport to fetch.
     */
    where: ConditionReportWhereUniqueInput
  }

  /**
   * ConditionReport findFirst
   */
  export type ConditionReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter, which ConditionReport to fetch.
     */
    where?: ConditionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionReports to fetch.
     */
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionReports.
     */
    cursor?: ConditionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionReports.
     */
    distinct?: ConditionReportScalarFieldEnum | ConditionReportScalarFieldEnum[]
  }

  /**
   * ConditionReport findFirstOrThrow
   */
  export type ConditionReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter, which ConditionReport to fetch.
     */
    where?: ConditionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionReports to fetch.
     */
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConditionReports.
     */
    cursor?: ConditionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConditionReports.
     */
    distinct?: ConditionReportScalarFieldEnum | ConditionReportScalarFieldEnum[]
  }

  /**
   * ConditionReport findMany
   */
  export type ConditionReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter, which ConditionReports to fetch.
     */
    where?: ConditionReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConditionReports to fetch.
     */
    orderBy?: ConditionReportOrderByWithRelationInput | ConditionReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConditionReports.
     */
    cursor?: ConditionReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConditionReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConditionReports.
     */
    skip?: number
    distinct?: ConditionReportScalarFieldEnum | ConditionReportScalarFieldEnum[]
  }

  /**
   * ConditionReport create
   */
  export type ConditionReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ConditionReport.
     */
    data: XOR<ConditionReportCreateInput, ConditionReportUncheckedCreateInput>
  }

  /**
   * ConditionReport createMany
   */
  export type ConditionReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConditionReports.
     */
    data: ConditionReportCreateManyInput | ConditionReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConditionReport createManyAndReturn
   */
  export type ConditionReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * The data used to create many ConditionReports.
     */
    data: ConditionReportCreateManyInput | ConditionReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConditionReport update
   */
  export type ConditionReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ConditionReport.
     */
    data: XOR<ConditionReportUpdateInput, ConditionReportUncheckedUpdateInput>
    /**
     * Choose, which ConditionReport to update.
     */
    where: ConditionReportWhereUniqueInput
  }

  /**
   * ConditionReport updateMany
   */
  export type ConditionReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConditionReports.
     */
    data: XOR<ConditionReportUpdateManyMutationInput, ConditionReportUncheckedUpdateManyInput>
    /**
     * Filter which ConditionReports to update
     */
    where?: ConditionReportWhereInput
    /**
     * Limit how many ConditionReports to update.
     */
    limit?: number
  }

  /**
   * ConditionReport updateManyAndReturn
   */
  export type ConditionReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * The data used to update ConditionReports.
     */
    data: XOR<ConditionReportUpdateManyMutationInput, ConditionReportUncheckedUpdateManyInput>
    /**
     * Filter which ConditionReports to update
     */
    where?: ConditionReportWhereInput
    /**
     * Limit how many ConditionReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConditionReport upsert
   */
  export type ConditionReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ConditionReport to update in case it exists.
     */
    where: ConditionReportWhereUniqueInput
    /**
     * In case the ConditionReport found by the `where` argument doesn't exist, create a new ConditionReport with this data.
     */
    create: XOR<ConditionReportCreateInput, ConditionReportUncheckedCreateInput>
    /**
     * In case the ConditionReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionReportUpdateInput, ConditionReportUncheckedUpdateInput>
  }

  /**
   * ConditionReport delete
   */
  export type ConditionReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    /**
     * Filter which ConditionReport to delete.
     */
    where: ConditionReportWhereUniqueInput
  }

  /**
   * ConditionReport deleteMany
   */
  export type ConditionReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConditionReports to delete
     */
    where?: ConditionReportWhereInput
    /**
     * Limit how many ConditionReports to delete.
     */
    limit?: number
  }

  /**
   * ConditionReport.photos
   */
  export type ConditionReport$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    where?: ReportPhotoWhereInput
    orderBy?: ReportPhotoOrderByWithRelationInput | ReportPhotoOrderByWithRelationInput[]
    cursor?: ReportPhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportPhotoScalarFieldEnum | ReportPhotoScalarFieldEnum[]
  }

  /**
   * ConditionReport.dispute
   */
  export type ConditionReport$disputeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    where?: DisputeWhereInput
  }

  /**
   * ConditionReport without action
   */
  export type ConditionReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
  }


  /**
   * Model ReportPhoto
   */

  export type AggregateReportPhoto = {
    _count: ReportPhotoCountAggregateOutputType | null
    _avg: ReportPhotoAvgAggregateOutputType | null
    _sum: ReportPhotoSumAggregateOutputType | null
    _min: ReportPhotoMinAggregateOutputType | null
    _max: ReportPhotoMaxAggregateOutputType | null
  }

  export type ReportPhotoAvgAggregateOutputType = {
    order: number | null
  }

  export type ReportPhotoSumAggregateOutputType = {
    order: number | null
  }

  export type ReportPhotoMinAggregateOutputType = {
    id: string | null
    reportId: string | null
    url: string | null
    thumbnailUrl: string | null
    caption: string | null
    order: number | null
    uploadedAt: Date | null
  }

  export type ReportPhotoMaxAggregateOutputType = {
    id: string | null
    reportId: string | null
    url: string | null
    thumbnailUrl: string | null
    caption: string | null
    order: number | null
    uploadedAt: Date | null
  }

  export type ReportPhotoCountAggregateOutputType = {
    id: number
    reportId: number
    url: number
    thumbnailUrl: number
    caption: number
    tags: number
    metadata: number
    order: number
    uploadedAt: number
    _all: number
  }


  export type ReportPhotoAvgAggregateInputType = {
    order?: true
  }

  export type ReportPhotoSumAggregateInputType = {
    order?: true
  }

  export type ReportPhotoMinAggregateInputType = {
    id?: true
    reportId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    order?: true
    uploadedAt?: true
  }

  export type ReportPhotoMaxAggregateInputType = {
    id?: true
    reportId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    order?: true
    uploadedAt?: true
  }

  export type ReportPhotoCountAggregateInputType = {
    id?: true
    reportId?: true
    url?: true
    thumbnailUrl?: true
    caption?: true
    tags?: true
    metadata?: true
    order?: true
    uploadedAt?: true
    _all?: true
  }

  export type ReportPhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportPhoto to aggregate.
     */
    where?: ReportPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPhotos to fetch.
     */
    orderBy?: ReportPhotoOrderByWithRelationInput | ReportPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReportPhotos
    **/
    _count?: true | ReportPhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportPhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportPhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportPhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportPhotoMaxAggregateInputType
  }

  export type GetReportPhotoAggregateType<T extends ReportPhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateReportPhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportPhoto[P]>
      : GetScalarType<T[P], AggregateReportPhoto[P]>
  }




  export type ReportPhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportPhotoWhereInput
    orderBy?: ReportPhotoOrderByWithAggregationInput | ReportPhotoOrderByWithAggregationInput[]
    by: ReportPhotoScalarFieldEnum[] | ReportPhotoScalarFieldEnum
    having?: ReportPhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportPhotoCountAggregateInputType | true
    _avg?: ReportPhotoAvgAggregateInputType
    _sum?: ReportPhotoSumAggregateInputType
    _min?: ReportPhotoMinAggregateInputType
    _max?: ReportPhotoMaxAggregateInputType
  }

  export type ReportPhotoGroupByOutputType = {
    id: string
    reportId: string
    url: string
    thumbnailUrl: string | null
    caption: string | null
    tags: JsonValue
    metadata: JsonValue
    order: number
    uploadedAt: Date
    _count: ReportPhotoCountAggregateOutputType | null
    _avg: ReportPhotoAvgAggregateOutputType | null
    _sum: ReportPhotoSumAggregateOutputType | null
    _min: ReportPhotoMinAggregateOutputType | null
    _max: ReportPhotoMaxAggregateOutputType | null
  }

  type GetReportPhotoGroupByPayload<T extends ReportPhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportPhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportPhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportPhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ReportPhotoGroupByOutputType[P]>
        }
      >
    >


  export type ReportPhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean
    uploadedAt?: boolean
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportPhoto"]>

  export type ReportPhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean
    uploadedAt?: boolean
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportPhoto"]>

  export type ReportPhotoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reportId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean
    uploadedAt?: boolean
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportPhoto"]>

  export type ReportPhotoSelectScalar = {
    id?: boolean
    reportId?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    caption?: boolean
    tags?: boolean
    metadata?: boolean
    order?: boolean
    uploadedAt?: boolean
  }

  export type ReportPhotoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reportId" | "url" | "thumbnailUrl" | "caption" | "tags" | "metadata" | "order" | "uploadedAt", ExtArgs["result"]["reportPhoto"]>
  export type ReportPhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }
  export type ReportPhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }
  export type ReportPhotoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ConditionReportDefaultArgs<ExtArgs>
  }

  export type $ReportPhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReportPhoto"
    objects: {
      report: Prisma.$ConditionReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reportId: string
      url: string
      thumbnailUrl: string | null
      caption: string | null
      tags: Prisma.JsonValue
      metadata: Prisma.JsonValue
      order: number
      uploadedAt: Date
    }, ExtArgs["result"]["reportPhoto"]>
    composites: {}
  }

  type ReportPhotoGetPayload<S extends boolean | null | undefined | ReportPhotoDefaultArgs> = $Result.GetResult<Prisma.$ReportPhotoPayload, S>

  type ReportPhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportPhotoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportPhotoCountAggregateInputType | true
    }

  export interface ReportPhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReportPhoto'], meta: { name: 'ReportPhoto' } }
    /**
     * Find zero or one ReportPhoto that matches the filter.
     * @param {ReportPhotoFindUniqueArgs} args - Arguments to find a ReportPhoto
     * @example
     * // Get one ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportPhotoFindUniqueArgs>(args: SelectSubset<T, ReportPhotoFindUniqueArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReportPhoto that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportPhotoFindUniqueOrThrowArgs} args - Arguments to find a ReportPhoto
     * @example
     * // Get one ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportPhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportPhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportPhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoFindFirstArgs} args - Arguments to find a ReportPhoto
     * @example
     * // Get one ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportPhotoFindFirstArgs>(args?: SelectSubset<T, ReportPhotoFindFirstArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReportPhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoFindFirstOrThrowArgs} args - Arguments to find a ReportPhoto
     * @example
     * // Get one ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportPhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportPhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReportPhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportPhotos
     * const reportPhotos = await prisma.reportPhoto.findMany()
     * 
     * // Get first 10 ReportPhotos
     * const reportPhotos = await prisma.reportPhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportPhotoWithIdOnly = await prisma.reportPhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportPhotoFindManyArgs>(args?: SelectSubset<T, ReportPhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReportPhoto.
     * @param {ReportPhotoCreateArgs} args - Arguments to create a ReportPhoto.
     * @example
     * // Create one ReportPhoto
     * const ReportPhoto = await prisma.reportPhoto.create({
     *   data: {
     *     // ... data to create a ReportPhoto
     *   }
     * })
     * 
     */
    create<T extends ReportPhotoCreateArgs>(args: SelectSubset<T, ReportPhotoCreateArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReportPhotos.
     * @param {ReportPhotoCreateManyArgs} args - Arguments to create many ReportPhotos.
     * @example
     * // Create many ReportPhotos
     * const reportPhoto = await prisma.reportPhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportPhotoCreateManyArgs>(args?: SelectSubset<T, ReportPhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReportPhotos and returns the data saved in the database.
     * @param {ReportPhotoCreateManyAndReturnArgs} args - Arguments to create many ReportPhotos.
     * @example
     * // Create many ReportPhotos
     * const reportPhoto = await prisma.reportPhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReportPhotos and only return the `id`
     * const reportPhotoWithIdOnly = await prisma.reportPhoto.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportPhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportPhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReportPhoto.
     * @param {ReportPhotoDeleteArgs} args - Arguments to delete one ReportPhoto.
     * @example
     * // Delete one ReportPhoto
     * const ReportPhoto = await prisma.reportPhoto.delete({
     *   where: {
     *     // ... filter to delete one ReportPhoto
     *   }
     * })
     * 
     */
    delete<T extends ReportPhotoDeleteArgs>(args: SelectSubset<T, ReportPhotoDeleteArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReportPhoto.
     * @param {ReportPhotoUpdateArgs} args - Arguments to update one ReportPhoto.
     * @example
     * // Update one ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportPhotoUpdateArgs>(args: SelectSubset<T, ReportPhotoUpdateArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReportPhotos.
     * @param {ReportPhotoDeleteManyArgs} args - Arguments to filter ReportPhotos to delete.
     * @example
     * // Delete a few ReportPhotos
     * const { count } = await prisma.reportPhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportPhotoDeleteManyArgs>(args?: SelectSubset<T, ReportPhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportPhotos
     * const reportPhoto = await prisma.reportPhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportPhotoUpdateManyArgs>(args: SelectSubset<T, ReportPhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportPhotos and returns the data updated in the database.
     * @param {ReportPhotoUpdateManyAndReturnArgs} args - Arguments to update many ReportPhotos.
     * @example
     * // Update many ReportPhotos
     * const reportPhoto = await prisma.reportPhoto.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReportPhotos and only return the `id`
     * const reportPhotoWithIdOnly = await prisma.reportPhoto.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportPhotoUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportPhotoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReportPhoto.
     * @param {ReportPhotoUpsertArgs} args - Arguments to update or create a ReportPhoto.
     * @example
     * // Update or create a ReportPhoto
     * const reportPhoto = await prisma.reportPhoto.upsert({
     *   create: {
     *     // ... data to create a ReportPhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportPhoto we want to update
     *   }
     * })
     */
    upsert<T extends ReportPhotoUpsertArgs>(args: SelectSubset<T, ReportPhotoUpsertArgs<ExtArgs>>): Prisma__ReportPhotoClient<$Result.GetResult<Prisma.$ReportPhotoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReportPhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoCountArgs} args - Arguments to filter ReportPhotos to count.
     * @example
     * // Count the number of ReportPhotos
     * const count = await prisma.reportPhoto.count({
     *   where: {
     *     // ... the filter for the ReportPhotos we want to count
     *   }
     * })
    **/
    count<T extends ReportPhotoCountArgs>(
      args?: Subset<T, ReportPhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportPhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportPhotoAggregateArgs>(args: Subset<T, ReportPhotoAggregateArgs>): Prisma.PrismaPromise<GetReportPhotoAggregateType<T>>

    /**
     * Group by ReportPhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportPhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportPhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportPhotoGroupByArgs['orderBy'] }
        : { orderBy?: ReportPhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportPhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReportPhoto model
   */
  readonly fields: ReportPhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReportPhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportPhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ConditionReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConditionReportDefaultArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReportPhoto model
   */
  interface ReportPhotoFieldRefs {
    readonly id: FieldRef<"ReportPhoto", 'String'>
    readonly reportId: FieldRef<"ReportPhoto", 'String'>
    readonly url: FieldRef<"ReportPhoto", 'String'>
    readonly thumbnailUrl: FieldRef<"ReportPhoto", 'String'>
    readonly caption: FieldRef<"ReportPhoto", 'String'>
    readonly tags: FieldRef<"ReportPhoto", 'Json'>
    readonly metadata: FieldRef<"ReportPhoto", 'Json'>
    readonly order: FieldRef<"ReportPhoto", 'Int'>
    readonly uploadedAt: FieldRef<"ReportPhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReportPhoto findUnique
   */
  export type ReportPhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReportPhoto to fetch.
     */
    where: ReportPhotoWhereUniqueInput
  }

  /**
   * ReportPhoto findUniqueOrThrow
   */
  export type ReportPhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReportPhoto to fetch.
     */
    where: ReportPhotoWhereUniqueInput
  }

  /**
   * ReportPhoto findFirst
   */
  export type ReportPhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReportPhoto to fetch.
     */
    where?: ReportPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPhotos to fetch.
     */
    orderBy?: ReportPhotoOrderByWithRelationInput | ReportPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPhotos.
     */
    cursor?: ReportPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportPhotos.
     */
    distinct?: ReportPhotoScalarFieldEnum | ReportPhotoScalarFieldEnum[]
  }

  /**
   * ReportPhoto findFirstOrThrow
   */
  export type ReportPhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReportPhoto to fetch.
     */
    where?: ReportPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPhotos to fetch.
     */
    orderBy?: ReportPhotoOrderByWithRelationInput | ReportPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReportPhotos.
     */
    cursor?: ReportPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReportPhotos.
     */
    distinct?: ReportPhotoScalarFieldEnum | ReportPhotoScalarFieldEnum[]
  }

  /**
   * ReportPhoto findMany
   */
  export type ReportPhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter, which ReportPhotos to fetch.
     */
    where?: ReportPhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReportPhotos to fetch.
     */
    orderBy?: ReportPhotoOrderByWithRelationInput | ReportPhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReportPhotos.
     */
    cursor?: ReportPhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReportPhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReportPhotos.
     */
    skip?: number
    distinct?: ReportPhotoScalarFieldEnum | ReportPhotoScalarFieldEnum[]
  }

  /**
   * ReportPhoto create
   */
  export type ReportPhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ReportPhoto.
     */
    data: XOR<ReportPhotoCreateInput, ReportPhotoUncheckedCreateInput>
  }

  /**
   * ReportPhoto createMany
   */
  export type ReportPhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReportPhotos.
     */
    data: ReportPhotoCreateManyInput | ReportPhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReportPhoto createManyAndReturn
   */
  export type ReportPhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * The data used to create many ReportPhotos.
     */
    data: ReportPhotoCreateManyInput | ReportPhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportPhoto update
   */
  export type ReportPhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ReportPhoto.
     */
    data: XOR<ReportPhotoUpdateInput, ReportPhotoUncheckedUpdateInput>
    /**
     * Choose, which ReportPhoto to update.
     */
    where: ReportPhotoWhereUniqueInput
  }

  /**
   * ReportPhoto updateMany
   */
  export type ReportPhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReportPhotos.
     */
    data: XOR<ReportPhotoUpdateManyMutationInput, ReportPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ReportPhotos to update
     */
    where?: ReportPhotoWhereInput
    /**
     * Limit how many ReportPhotos to update.
     */
    limit?: number
  }

  /**
   * ReportPhoto updateManyAndReturn
   */
  export type ReportPhotoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * The data used to update ReportPhotos.
     */
    data: XOR<ReportPhotoUpdateManyMutationInput, ReportPhotoUncheckedUpdateManyInput>
    /**
     * Filter which ReportPhotos to update
     */
    where?: ReportPhotoWhereInput
    /**
     * Limit how many ReportPhotos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReportPhoto upsert
   */
  export type ReportPhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ReportPhoto to update in case it exists.
     */
    where: ReportPhotoWhereUniqueInput
    /**
     * In case the ReportPhoto found by the `where` argument doesn't exist, create a new ReportPhoto with this data.
     */
    create: XOR<ReportPhotoCreateInput, ReportPhotoUncheckedCreateInput>
    /**
     * In case the ReportPhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportPhotoUpdateInput, ReportPhotoUncheckedUpdateInput>
  }

  /**
   * ReportPhoto delete
   */
  export type ReportPhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
    /**
     * Filter which ReportPhoto to delete.
     */
    where: ReportPhotoWhereUniqueInput
  }

  /**
   * ReportPhoto deleteMany
   */
  export type ReportPhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReportPhotos to delete
     */
    where?: ReportPhotoWhereInput
    /**
     * Limit how many ReportPhotos to delete.
     */
    limit?: number
  }

  /**
   * ReportPhoto without action
   */
  export type ReportPhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportPhoto
     */
    select?: ReportPhotoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReportPhoto
     */
    omit?: ReportPhotoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportPhotoInclude<ExtArgs> | null
  }


  /**
   * Model Dispute
   */

  export type AggregateDispute = {
    _count: DisputeCountAggregateOutputType | null
    _avg: DisputeAvgAggregateOutputType | null
    _sum: DisputeSumAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  export type DisputeAvgAggregateOutputType = {
    amount: number | null
  }

  export type DisputeSumAggregateOutputType = {
    amount: number | null
  }

  export type DisputeMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    conditionReportId: string | null
    initiatorId: string | null
    defendantId: string | null
    type: $Enums.DisputeType | null
    title: string | null
    description: string | null
    amount: number | null
    currency: string | null
    status: $Enums.DisputeStatus | null
    priority: $Enums.DisputePriority | null
    slaDeadline: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    assignedTo: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    conditionReportId: string | null
    initiatorId: string | null
    defendantId: string | null
    type: $Enums.DisputeType | null
    title: string | null
    description: string | null
    amount: number | null
    currency: string | null
    status: $Enums.DisputeStatus | null
    priority: $Enums.DisputePriority | null
    slaDeadline: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    assignedTo: string | null
    assignedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DisputeCountAggregateOutputType = {
    id: number
    bookingId: number
    conditionReportId: number
    initiatorId: number
    defendantId: number
    type: number
    title: number
    description: number
    amount: number
    currency: number
    status: number
    priority: number
    slaDeadline: number
    respondedAt: number
    resolvedAt: number
    assignedTo: number
    assignedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DisputeAvgAggregateInputType = {
    amount?: true
  }

  export type DisputeSumAggregateInputType = {
    amount?: true
  }

  export type DisputeMinAggregateInputType = {
    id?: true
    bookingId?: true
    conditionReportId?: true
    initiatorId?: true
    defendantId?: true
    type?: true
    title?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    priority?: true
    slaDeadline?: true
    respondedAt?: true
    resolvedAt?: true
    assignedTo?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeMaxAggregateInputType = {
    id?: true
    bookingId?: true
    conditionReportId?: true
    initiatorId?: true
    defendantId?: true
    type?: true
    title?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    priority?: true
    slaDeadline?: true
    respondedAt?: true
    resolvedAt?: true
    assignedTo?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DisputeCountAggregateInputType = {
    id?: true
    bookingId?: true
    conditionReportId?: true
    initiatorId?: true
    defendantId?: true
    type?: true
    title?: true
    description?: true
    amount?: true
    currency?: true
    status?: true
    priority?: true
    slaDeadline?: true
    respondedAt?: true
    resolvedAt?: true
    assignedTo?: true
    assignedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DisputeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dispute to aggregate.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Disputes
    **/
    _count?: true | DisputeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisputeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisputeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeMaxAggregateInputType
  }

  export type GetDisputeAggregateType<T extends DisputeAggregateArgs> = {
        [P in keyof T & keyof AggregateDispute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDispute[P]>
      : GetScalarType<T[P], AggregateDispute[P]>
  }




  export type DisputeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeWhereInput
    orderBy?: DisputeOrderByWithAggregationInput | DisputeOrderByWithAggregationInput[]
    by: DisputeScalarFieldEnum[] | DisputeScalarFieldEnum
    having?: DisputeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeCountAggregateInputType | true
    _avg?: DisputeAvgAggregateInputType
    _sum?: DisputeSumAggregateInputType
    _min?: DisputeMinAggregateInputType
    _max?: DisputeMaxAggregateInputType
  }

  export type DisputeGroupByOutputType = {
    id: string
    bookingId: string
    conditionReportId: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount: number | null
    currency: string
    status: $Enums.DisputeStatus
    priority: $Enums.DisputePriority
    slaDeadline: Date | null
    respondedAt: Date | null
    resolvedAt: Date | null
    assignedTo: string | null
    assignedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DisputeCountAggregateOutputType | null
    _avg: DisputeAvgAggregateOutputType | null
    _sum: DisputeSumAggregateOutputType | null
    _min: DisputeMinAggregateOutputType | null
    _max: DisputeMaxAggregateOutputType | null
  }

  type GetDisputeGroupByPayload<T extends DisputeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeGroupByOutputType[P]>
        }
      >
    >


  export type DisputeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    conditionReportId?: boolean
    initiatorId?: boolean
    defendantId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    slaDeadline?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolution?: boolean | Dispute$resolutionArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | Dispute$responsesArgs<ExtArgs>
    evidence?: boolean | Dispute$evidenceArgs<ExtArgs>
    timeline?: boolean | Dispute$timelineArgs<ExtArgs>
    _count?: boolean | DisputeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    conditionReportId?: boolean
    initiatorId?: boolean
    defendantId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    slaDeadline?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    conditionReportId?: boolean
    initiatorId?: boolean
    defendantId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    slaDeadline?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dispute"]>

  export type DisputeSelectScalar = {
    id?: boolean
    bookingId?: boolean
    conditionReportId?: boolean
    initiatorId?: boolean
    defendantId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    priority?: boolean
    slaDeadline?: boolean
    respondedAt?: boolean
    resolvedAt?: boolean
    assignedTo?: boolean
    assignedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DisputeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "conditionReportId" | "initiatorId" | "defendantId" | "type" | "title" | "description" | "amount" | "currency" | "status" | "priority" | "slaDeadline" | "respondedAt" | "resolvedAt" | "assignedTo" | "assignedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["dispute"]>
  export type DisputeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    resolution?: boolean | Dispute$resolutionArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | Dispute$responsesArgs<ExtArgs>
    evidence?: boolean | Dispute$evidenceArgs<ExtArgs>
    timeline?: boolean | Dispute$timelineArgs<ExtArgs>
    _count?: boolean | DisputeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisputeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    conditionReport?: boolean | Dispute$conditionReportArgs<ExtArgs>
    initiator?: boolean | UserDefaultArgs<ExtArgs>
    defendant?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisputePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dispute"
    objects: {
      resolution: Prisma.$DisputeResolutionPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs>
      conditionReport: Prisma.$ConditionReportPayload<ExtArgs> | null
      initiator: Prisma.$UserPayload<ExtArgs>
      defendant: Prisma.$UserPayload<ExtArgs>
      responses: Prisma.$DisputeResponsePayload<ExtArgs>[]
      evidence: Prisma.$DisputeEvidencePayload<ExtArgs>[]
      timeline: Prisma.$DisputeTimelineEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      conditionReportId: string | null
      initiatorId: string
      defendantId: string
      type: $Enums.DisputeType
      title: string
      description: string
      amount: number | null
      currency: string
      status: $Enums.DisputeStatus
      priority: $Enums.DisputePriority
      slaDeadline: Date | null
      respondedAt: Date | null
      resolvedAt: Date | null
      assignedTo: string | null
      assignedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dispute"]>
    composites: {}
  }

  type DisputeGetPayload<S extends boolean | null | undefined | DisputeDefaultArgs> = $Result.GetResult<Prisma.$DisputePayload, S>

  type DisputeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeCountAggregateInputType | true
    }

  export interface DisputeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dispute'], meta: { name: 'Dispute' } }
    /**
     * Find zero or one Dispute that matches the filter.
     * @param {DisputeFindUniqueArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeFindUniqueArgs>(args: SelectSubset<T, DisputeFindUniqueArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dispute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeFindUniqueOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeFindFirstArgs>(args?: SelectSubset<T, DisputeFindFirstArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dispute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindFirstOrThrowArgs} args - Arguments to find a Dispute
     * @example
     * // Get one Dispute
     * const dispute = await prisma.dispute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disputes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disputes
     * const disputes = await prisma.dispute.findMany()
     * 
     * // Get first 10 Disputes
     * const disputes = await prisma.dispute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeWithIdOnly = await prisma.dispute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeFindManyArgs>(args?: SelectSubset<T, DisputeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dispute.
     * @param {DisputeCreateArgs} args - Arguments to create a Dispute.
     * @example
     * // Create one Dispute
     * const Dispute = await prisma.dispute.create({
     *   data: {
     *     // ... data to create a Dispute
     *   }
     * })
     * 
     */
    create<T extends DisputeCreateArgs>(args: SelectSubset<T, DisputeCreateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disputes.
     * @param {DisputeCreateManyArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeCreateManyArgs>(args?: SelectSubset<T, DisputeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disputes and returns the data saved in the database.
     * @param {DisputeCreateManyAndReturnArgs} args - Arguments to create many Disputes.
     * @example
     * // Create many Disputes
     * const dispute = await prisma.dispute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disputes and only return the `id`
     * const disputeWithIdOnly = await prisma.dispute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dispute.
     * @param {DisputeDeleteArgs} args - Arguments to delete one Dispute.
     * @example
     * // Delete one Dispute
     * const Dispute = await prisma.dispute.delete({
     *   where: {
     *     // ... filter to delete one Dispute
     *   }
     * })
     * 
     */
    delete<T extends DisputeDeleteArgs>(args: SelectSubset<T, DisputeDeleteArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dispute.
     * @param {DisputeUpdateArgs} args - Arguments to update one Dispute.
     * @example
     * // Update one Dispute
     * const dispute = await prisma.dispute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeUpdateArgs>(args: SelectSubset<T, DisputeUpdateArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disputes.
     * @param {DisputeDeleteManyArgs} args - Arguments to filter Disputes to delete.
     * @example
     * // Delete a few Disputes
     * const { count } = await prisma.dispute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeDeleteManyArgs>(args?: SelectSubset<T, DisputeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeUpdateManyArgs>(args: SelectSubset<T, DisputeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disputes and returns the data updated in the database.
     * @param {DisputeUpdateManyAndReturnArgs} args - Arguments to update many Disputes.
     * @example
     * // Update many Disputes
     * const dispute = await prisma.dispute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Disputes and only return the `id`
     * const disputeWithIdOnly = await prisma.dispute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dispute.
     * @param {DisputeUpsertArgs} args - Arguments to update or create a Dispute.
     * @example
     * // Update or create a Dispute
     * const dispute = await prisma.dispute.upsert({
     *   create: {
     *     // ... data to create a Dispute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dispute we want to update
     *   }
     * })
     */
    upsert<T extends DisputeUpsertArgs>(args: SelectSubset<T, DisputeUpsertArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disputes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeCountArgs} args - Arguments to filter Disputes to count.
     * @example
     * // Count the number of Disputes
     * const count = await prisma.dispute.count({
     *   where: {
     *     // ... the filter for the Disputes we want to count
     *   }
     * })
    **/
    count<T extends DisputeCountArgs>(
      args?: Subset<T, DisputeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeAggregateArgs>(args: Subset<T, DisputeAggregateArgs>): Prisma.PrismaPromise<GetDisputeAggregateType<T>>

    /**
     * Group by Dispute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeGroupByArgs['orderBy'] }
        : { orderBy?: DisputeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dispute model
   */
  readonly fields: DisputeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dispute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    resolution<T extends Dispute$resolutionArgs<ExtArgs> = {}>(args?: Subset<T, Dispute$resolutionArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conditionReport<T extends Dispute$conditionReportArgs<ExtArgs> = {}>(args?: Subset<T, Dispute$conditionReportArgs<ExtArgs>>): Prisma__ConditionReportClient<$Result.GetResult<Prisma.$ConditionReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    initiator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    defendant<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responses<T extends Dispute$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Dispute$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evidence<T extends Dispute$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, Dispute$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    timeline<T extends Dispute$timelineArgs<ExtArgs> = {}>(args?: Subset<T, Dispute$timelineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dispute model
   */
  interface DisputeFieldRefs {
    readonly id: FieldRef<"Dispute", 'String'>
    readonly bookingId: FieldRef<"Dispute", 'String'>
    readonly conditionReportId: FieldRef<"Dispute", 'String'>
    readonly initiatorId: FieldRef<"Dispute", 'String'>
    readonly defendantId: FieldRef<"Dispute", 'String'>
    readonly type: FieldRef<"Dispute", 'DisputeType'>
    readonly title: FieldRef<"Dispute", 'String'>
    readonly description: FieldRef<"Dispute", 'String'>
    readonly amount: FieldRef<"Dispute", 'Float'>
    readonly currency: FieldRef<"Dispute", 'String'>
    readonly status: FieldRef<"Dispute", 'DisputeStatus'>
    readonly priority: FieldRef<"Dispute", 'DisputePriority'>
    readonly slaDeadline: FieldRef<"Dispute", 'DateTime'>
    readonly respondedAt: FieldRef<"Dispute", 'DateTime'>
    readonly resolvedAt: FieldRef<"Dispute", 'DateTime'>
    readonly assignedTo: FieldRef<"Dispute", 'String'>
    readonly assignedAt: FieldRef<"Dispute", 'DateTime'>
    readonly createdAt: FieldRef<"Dispute", 'DateTime'>
    readonly updatedAt: FieldRef<"Dispute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dispute findUnique
   */
  export type DisputeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findUniqueOrThrow
   */
  export type DisputeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute findFirst
   */
  export type DisputeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findFirstOrThrow
   */
  export type DisputeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Dispute to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Disputes.
     */
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute findMany
   */
  export type DisputeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter, which Disputes to fetch.
     */
    where?: DisputeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Disputes to fetch.
     */
    orderBy?: DisputeOrderByWithRelationInput | DisputeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Disputes.
     */
    cursor?: DisputeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Disputes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Disputes.
     */
    skip?: number
    distinct?: DisputeScalarFieldEnum | DisputeScalarFieldEnum[]
  }

  /**
   * Dispute create
   */
  export type DisputeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to create a Dispute.
     */
    data: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
  }

  /**
   * Dispute createMany
   */
  export type DisputeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dispute createManyAndReturn
   */
  export type DisputeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * The data used to create many Disputes.
     */
    data: DisputeCreateManyInput | DisputeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute update
   */
  export type DisputeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The data needed to update a Dispute.
     */
    data: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
    /**
     * Choose, which Dispute to update.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute updateMany
   */
  export type DisputeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to update.
     */
    limit?: number
  }

  /**
   * Dispute updateManyAndReturn
   */
  export type DisputeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * The data used to update Disputes.
     */
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyInput>
    /**
     * Filter which Disputes to update
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dispute upsert
   */
  export type DisputeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * The filter to search for the Dispute to update in case it exists.
     */
    where: DisputeWhereUniqueInput
    /**
     * In case the Dispute found by the `where` argument doesn't exist, create a new Dispute with this data.
     */
    create: XOR<DisputeCreateInput, DisputeUncheckedCreateInput>
    /**
     * In case the Dispute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeUpdateInput, DisputeUncheckedUpdateInput>
  }

  /**
   * Dispute delete
   */
  export type DisputeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
    /**
     * Filter which Dispute to delete.
     */
    where: DisputeWhereUniqueInput
  }

  /**
   * Dispute deleteMany
   */
  export type DisputeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Disputes to delete
     */
    where?: DisputeWhereInput
    /**
     * Limit how many Disputes to delete.
     */
    limit?: number
  }

  /**
   * Dispute.resolution
   */
  export type Dispute$resolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    where?: DisputeResolutionWhereInput
  }

  /**
   * Dispute.conditionReport
   */
  export type Dispute$conditionReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionReport
     */
    select?: ConditionReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConditionReport
     */
    omit?: ConditionReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConditionReportInclude<ExtArgs> | null
    where?: ConditionReportWhereInput
  }

  /**
   * Dispute.responses
   */
  export type Dispute$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    where?: DisputeResponseWhereInput
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    cursor?: DisputeResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeResponseScalarFieldEnum | DisputeResponseScalarFieldEnum[]
  }

  /**
   * Dispute.evidence
   */
  export type Dispute$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    where?: DisputeEvidenceWhereInput
    orderBy?: DisputeEvidenceOrderByWithRelationInput | DisputeEvidenceOrderByWithRelationInput[]
    cursor?: DisputeEvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeEvidenceScalarFieldEnum | DisputeEvidenceScalarFieldEnum[]
  }

  /**
   * Dispute.timeline
   */
  export type Dispute$timelineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    where?: DisputeTimelineEventWhereInput
    orderBy?: DisputeTimelineEventOrderByWithRelationInput | DisputeTimelineEventOrderByWithRelationInput[]
    cursor?: DisputeTimelineEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisputeTimelineEventScalarFieldEnum | DisputeTimelineEventScalarFieldEnum[]
  }

  /**
   * Dispute without action
   */
  export type DisputeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dispute
     */
    select?: DisputeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dispute
     */
    omit?: DisputeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeInclude<ExtArgs> | null
  }


  /**
   * Model DisputeResponse
   */

  export type AggregateDisputeResponse = {
    _count: DisputeResponseCountAggregateOutputType | null
    _min: DisputeResponseMinAggregateOutputType | null
    _max: DisputeResponseMaxAggregateOutputType | null
  }

  export type DisputeResponseMinAggregateOutputType = {
    id: string | null
    disputeId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type DisputeResponseMaxAggregateOutputType = {
    id: string | null
    disputeId: string | null
    userId: string | null
    content: string | null
    createdAt: Date | null
  }

  export type DisputeResponseCountAggregateOutputType = {
    id: number
    disputeId: number
    userId: number
    content: number
    attachments: number
    createdAt: number
    _all: number
  }


  export type DisputeResponseMinAggregateInputType = {
    id?: true
    disputeId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type DisputeResponseMaxAggregateInputType = {
    id?: true
    disputeId?: true
    userId?: true
    content?: true
    createdAt?: true
  }

  export type DisputeResponseCountAggregateInputType = {
    id?: true
    disputeId?: true
    userId?: true
    content?: true
    attachments?: true
    createdAt?: true
    _all?: true
  }

  export type DisputeResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeResponse to aggregate.
     */
    where?: DisputeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResponses to fetch.
     */
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisputeResponses
    **/
    _count?: true | DisputeResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeResponseMaxAggregateInputType
  }

  export type GetDisputeResponseAggregateType<T extends DisputeResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateDisputeResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisputeResponse[P]>
      : GetScalarType<T[P], AggregateDisputeResponse[P]>
  }




  export type DisputeResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeResponseWhereInput
    orderBy?: DisputeResponseOrderByWithAggregationInput | DisputeResponseOrderByWithAggregationInput[]
    by: DisputeResponseScalarFieldEnum[] | DisputeResponseScalarFieldEnum
    having?: DisputeResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeResponseCountAggregateInputType | true
    _min?: DisputeResponseMinAggregateInputType
    _max?: DisputeResponseMaxAggregateInputType
  }

  export type DisputeResponseGroupByOutputType = {
    id: string
    disputeId: string
    userId: string
    content: string
    attachments: JsonValue
    createdAt: Date
    _count: DisputeResponseCountAggregateOutputType | null
    _min: DisputeResponseMinAggregateOutputType | null
    _max: DisputeResponseMaxAggregateOutputType | null
  }

  type GetDisputeResponseGroupByPayload<T extends DisputeResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeResponseGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeResponseGroupByOutputType[P]>
        }
      >
    >


  export type DisputeResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResponse"]>

  export type DisputeResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResponse"]>

  export type DisputeResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResponse"]>

  export type DisputeResponseSelectScalar = {
    id?: boolean
    disputeId?: boolean
    userId?: boolean
    content?: boolean
    attachments?: boolean
    createdAt?: boolean
  }

  export type DisputeResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "disputeId" | "userId" | "content" | "attachments" | "createdAt", ExtArgs["result"]["disputeResponse"]>
  export type DisputeResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisputeResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DisputeResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DisputeResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisputeResponse"
    objects: {
      dispute: Prisma.$DisputePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      disputeId: string
      userId: string
      content: string
      attachments: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["disputeResponse"]>
    composites: {}
  }

  type DisputeResponseGetPayload<S extends boolean | null | undefined | DisputeResponseDefaultArgs> = $Result.GetResult<Prisma.$DisputeResponsePayload, S>

  type DisputeResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeResponseCountAggregateInputType | true
    }

  export interface DisputeResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisputeResponse'], meta: { name: 'DisputeResponse' } }
    /**
     * Find zero or one DisputeResponse that matches the filter.
     * @param {DisputeResponseFindUniqueArgs} args - Arguments to find a DisputeResponse
     * @example
     * // Get one DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeResponseFindUniqueArgs>(args: SelectSubset<T, DisputeResponseFindUniqueArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisputeResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeResponseFindUniqueOrThrowArgs} args - Arguments to find a DisputeResponse
     * @example
     * // Get one DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseFindFirstArgs} args - Arguments to find a DisputeResponse
     * @example
     * // Get one DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeResponseFindFirstArgs>(args?: SelectSubset<T, DisputeResponseFindFirstArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseFindFirstOrThrowArgs} args - Arguments to find a DisputeResponse
     * @example
     * // Get one DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisputeResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisputeResponses
     * const disputeResponses = await prisma.disputeResponse.findMany()
     * 
     * // Get first 10 DisputeResponses
     * const disputeResponses = await prisma.disputeResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeResponseWithIdOnly = await prisma.disputeResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeResponseFindManyArgs>(args?: SelectSubset<T, DisputeResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisputeResponse.
     * @param {DisputeResponseCreateArgs} args - Arguments to create a DisputeResponse.
     * @example
     * // Create one DisputeResponse
     * const DisputeResponse = await prisma.disputeResponse.create({
     *   data: {
     *     // ... data to create a DisputeResponse
     *   }
     * })
     * 
     */
    create<T extends DisputeResponseCreateArgs>(args: SelectSubset<T, DisputeResponseCreateArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisputeResponses.
     * @param {DisputeResponseCreateManyArgs} args - Arguments to create many DisputeResponses.
     * @example
     * // Create many DisputeResponses
     * const disputeResponse = await prisma.disputeResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeResponseCreateManyArgs>(args?: SelectSubset<T, DisputeResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisputeResponses and returns the data saved in the database.
     * @param {DisputeResponseCreateManyAndReturnArgs} args - Arguments to create many DisputeResponses.
     * @example
     * // Create many DisputeResponses
     * const disputeResponse = await prisma.disputeResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisputeResponses and only return the `id`
     * const disputeResponseWithIdOnly = await prisma.disputeResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisputeResponse.
     * @param {DisputeResponseDeleteArgs} args - Arguments to delete one DisputeResponse.
     * @example
     * // Delete one DisputeResponse
     * const DisputeResponse = await prisma.disputeResponse.delete({
     *   where: {
     *     // ... filter to delete one DisputeResponse
     *   }
     * })
     * 
     */
    delete<T extends DisputeResponseDeleteArgs>(args: SelectSubset<T, DisputeResponseDeleteArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisputeResponse.
     * @param {DisputeResponseUpdateArgs} args - Arguments to update one DisputeResponse.
     * @example
     * // Update one DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeResponseUpdateArgs>(args: SelectSubset<T, DisputeResponseUpdateArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisputeResponses.
     * @param {DisputeResponseDeleteManyArgs} args - Arguments to filter DisputeResponses to delete.
     * @example
     * // Delete a few DisputeResponses
     * const { count } = await prisma.disputeResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeResponseDeleteManyArgs>(args?: SelectSubset<T, DisputeResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisputeResponses
     * const disputeResponse = await prisma.disputeResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeResponseUpdateManyArgs>(args: SelectSubset<T, DisputeResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeResponses and returns the data updated in the database.
     * @param {DisputeResponseUpdateManyAndReturnArgs} args - Arguments to update many DisputeResponses.
     * @example
     * // Update many DisputeResponses
     * const disputeResponse = await prisma.disputeResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisputeResponses and only return the `id`
     * const disputeResponseWithIdOnly = await prisma.disputeResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisputeResponse.
     * @param {DisputeResponseUpsertArgs} args - Arguments to update or create a DisputeResponse.
     * @example
     * // Update or create a DisputeResponse
     * const disputeResponse = await prisma.disputeResponse.upsert({
     *   create: {
     *     // ... data to create a DisputeResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisputeResponse we want to update
     *   }
     * })
     */
    upsert<T extends DisputeResponseUpsertArgs>(args: SelectSubset<T, DisputeResponseUpsertArgs<ExtArgs>>): Prisma__DisputeResponseClient<$Result.GetResult<Prisma.$DisputeResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisputeResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseCountArgs} args - Arguments to filter DisputeResponses to count.
     * @example
     * // Count the number of DisputeResponses
     * const count = await prisma.disputeResponse.count({
     *   where: {
     *     // ... the filter for the DisputeResponses we want to count
     *   }
     * })
    **/
    count<T extends DisputeResponseCountArgs>(
      args?: Subset<T, DisputeResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisputeResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeResponseAggregateArgs>(args: Subset<T, DisputeResponseAggregateArgs>): Prisma.PrismaPromise<GetDisputeResponseAggregateType<T>>

    /**
     * Group by DisputeResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeResponseGroupByArgs['orderBy'] }
        : { orderBy?: DisputeResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisputeResponse model
   */
  readonly fields: DisputeResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisputeResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispute<T extends DisputeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisputeDefaultArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisputeResponse model
   */
  interface DisputeResponseFieldRefs {
    readonly id: FieldRef<"DisputeResponse", 'String'>
    readonly disputeId: FieldRef<"DisputeResponse", 'String'>
    readonly userId: FieldRef<"DisputeResponse", 'String'>
    readonly content: FieldRef<"DisputeResponse", 'String'>
    readonly attachments: FieldRef<"DisputeResponse", 'Json'>
    readonly createdAt: FieldRef<"DisputeResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisputeResponse findUnique
   */
  export type DisputeResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResponse to fetch.
     */
    where: DisputeResponseWhereUniqueInput
  }

  /**
   * DisputeResponse findUniqueOrThrow
   */
  export type DisputeResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResponse to fetch.
     */
    where: DisputeResponseWhereUniqueInput
  }

  /**
   * DisputeResponse findFirst
   */
  export type DisputeResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResponse to fetch.
     */
    where?: DisputeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResponses to fetch.
     */
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeResponses.
     */
    cursor?: DisputeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeResponses.
     */
    distinct?: DisputeResponseScalarFieldEnum | DisputeResponseScalarFieldEnum[]
  }

  /**
   * DisputeResponse findFirstOrThrow
   */
  export type DisputeResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResponse to fetch.
     */
    where?: DisputeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResponses to fetch.
     */
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeResponses.
     */
    cursor?: DisputeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeResponses.
     */
    distinct?: DisputeResponseScalarFieldEnum | DisputeResponseScalarFieldEnum[]
  }

  /**
   * DisputeResponse findMany
   */
  export type DisputeResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResponses to fetch.
     */
    where?: DisputeResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResponses to fetch.
     */
    orderBy?: DisputeResponseOrderByWithRelationInput | DisputeResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisputeResponses.
     */
    cursor?: DisputeResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResponses.
     */
    skip?: number
    distinct?: DisputeResponseScalarFieldEnum | DisputeResponseScalarFieldEnum[]
  }

  /**
   * DisputeResponse create
   */
  export type DisputeResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a DisputeResponse.
     */
    data: XOR<DisputeResponseCreateInput, DisputeResponseUncheckedCreateInput>
  }

  /**
   * DisputeResponse createMany
   */
  export type DisputeResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisputeResponses.
     */
    data: DisputeResponseCreateManyInput | DisputeResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisputeResponse createManyAndReturn
   */
  export type DisputeResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * The data used to create many DisputeResponses.
     */
    data: DisputeResponseCreateManyInput | DisputeResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeResponse update
   */
  export type DisputeResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a DisputeResponse.
     */
    data: XOR<DisputeResponseUpdateInput, DisputeResponseUncheckedUpdateInput>
    /**
     * Choose, which DisputeResponse to update.
     */
    where: DisputeResponseWhereUniqueInput
  }

  /**
   * DisputeResponse updateMany
   */
  export type DisputeResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisputeResponses.
     */
    data: XOR<DisputeResponseUpdateManyMutationInput, DisputeResponseUncheckedUpdateManyInput>
    /**
     * Filter which DisputeResponses to update
     */
    where?: DisputeResponseWhereInput
    /**
     * Limit how many DisputeResponses to update.
     */
    limit?: number
  }

  /**
   * DisputeResponse updateManyAndReturn
   */
  export type DisputeResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * The data used to update DisputeResponses.
     */
    data: XOR<DisputeResponseUpdateManyMutationInput, DisputeResponseUncheckedUpdateManyInput>
    /**
     * Filter which DisputeResponses to update
     */
    where?: DisputeResponseWhereInput
    /**
     * Limit how many DisputeResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeResponse upsert
   */
  export type DisputeResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the DisputeResponse to update in case it exists.
     */
    where: DisputeResponseWhereUniqueInput
    /**
     * In case the DisputeResponse found by the `where` argument doesn't exist, create a new DisputeResponse with this data.
     */
    create: XOR<DisputeResponseCreateInput, DisputeResponseUncheckedCreateInput>
    /**
     * In case the DisputeResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeResponseUpdateInput, DisputeResponseUncheckedUpdateInput>
  }

  /**
   * DisputeResponse delete
   */
  export type DisputeResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
    /**
     * Filter which DisputeResponse to delete.
     */
    where: DisputeResponseWhereUniqueInput
  }

  /**
   * DisputeResponse deleteMany
   */
  export type DisputeResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeResponses to delete
     */
    where?: DisputeResponseWhereInput
    /**
     * Limit how many DisputeResponses to delete.
     */
    limit?: number
  }

  /**
   * DisputeResponse without action
   */
  export type DisputeResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResponse
     */
    select?: DisputeResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResponse
     */
    omit?: DisputeResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResponseInclude<ExtArgs> | null
  }


  /**
   * Model DisputeEvidence
   */

  export type AggregateDisputeEvidence = {
    _count: DisputeEvidenceCountAggregateOutputType | null
    _min: DisputeEvidenceMinAggregateOutputType | null
    _max: DisputeEvidenceMaxAggregateOutputType | null
  }

  export type DisputeEvidenceMinAggregateOutputType = {
    id: string | null
    disputeId: string | null
    uploadedBy: string | null
    type: $Enums.EvidenceType | null
    url: string | null
    description: string | null
    uploadedAt: Date | null
  }

  export type DisputeEvidenceMaxAggregateOutputType = {
    id: string | null
    disputeId: string | null
    uploadedBy: string | null
    type: $Enums.EvidenceType | null
    url: string | null
    description: string | null
    uploadedAt: Date | null
  }

  export type DisputeEvidenceCountAggregateOutputType = {
    id: number
    disputeId: number
    uploadedBy: number
    type: number
    url: number
    description: number
    metadata: number
    uploadedAt: number
    _all: number
  }


  export type DisputeEvidenceMinAggregateInputType = {
    id?: true
    disputeId?: true
    uploadedBy?: true
    type?: true
    url?: true
    description?: true
    uploadedAt?: true
  }

  export type DisputeEvidenceMaxAggregateInputType = {
    id?: true
    disputeId?: true
    uploadedBy?: true
    type?: true
    url?: true
    description?: true
    uploadedAt?: true
  }

  export type DisputeEvidenceCountAggregateInputType = {
    id?: true
    disputeId?: true
    uploadedBy?: true
    type?: true
    url?: true
    description?: true
    metadata?: true
    uploadedAt?: true
    _all?: true
  }

  export type DisputeEvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeEvidence to aggregate.
     */
    where?: DisputeEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeEvidences to fetch.
     */
    orderBy?: DisputeEvidenceOrderByWithRelationInput | DisputeEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisputeEvidences
    **/
    _count?: true | DisputeEvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeEvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeEvidenceMaxAggregateInputType
  }

  export type GetDisputeEvidenceAggregateType<T extends DisputeEvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateDisputeEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisputeEvidence[P]>
      : GetScalarType<T[P], AggregateDisputeEvidence[P]>
  }




  export type DisputeEvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeEvidenceWhereInput
    orderBy?: DisputeEvidenceOrderByWithAggregationInput | DisputeEvidenceOrderByWithAggregationInput[]
    by: DisputeEvidenceScalarFieldEnum[] | DisputeEvidenceScalarFieldEnum
    having?: DisputeEvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeEvidenceCountAggregateInputType | true
    _min?: DisputeEvidenceMinAggregateInputType
    _max?: DisputeEvidenceMaxAggregateInputType
  }

  export type DisputeEvidenceGroupByOutputType = {
    id: string
    disputeId: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description: string | null
    metadata: JsonValue
    uploadedAt: Date
    _count: DisputeEvidenceCountAggregateOutputType | null
    _min: DisputeEvidenceMinAggregateOutputType | null
    _max: DisputeEvidenceMaxAggregateOutputType | null
  }

  type GetDisputeEvidenceGroupByPayload<T extends DisputeEvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeEvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeEvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeEvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeEvidenceGroupByOutputType[P]>
        }
      >
    >


  export type DisputeEvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    uploadedBy?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    uploadedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeEvidence"]>

  export type DisputeEvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    uploadedBy?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    uploadedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeEvidence"]>

  export type DisputeEvidenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    uploadedBy?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    uploadedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeEvidence"]>

  export type DisputeEvidenceSelectScalar = {
    id?: boolean
    disputeId?: boolean
    uploadedBy?: boolean
    type?: boolean
    url?: boolean
    description?: boolean
    metadata?: boolean
    uploadedAt?: boolean
  }

  export type DisputeEvidenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "disputeId" | "uploadedBy" | "type" | "url" | "description" | "metadata" | "uploadedAt", ExtArgs["result"]["disputeEvidence"]>
  export type DisputeEvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeEvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeEvidenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }

  export type $DisputeEvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisputeEvidence"
    objects: {
      dispute: Prisma.$DisputePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      disputeId: string
      uploadedBy: string
      type: $Enums.EvidenceType
      url: string
      description: string | null
      metadata: Prisma.JsonValue
      uploadedAt: Date
    }, ExtArgs["result"]["disputeEvidence"]>
    composites: {}
  }

  type DisputeEvidenceGetPayload<S extends boolean | null | undefined | DisputeEvidenceDefaultArgs> = $Result.GetResult<Prisma.$DisputeEvidencePayload, S>

  type DisputeEvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeEvidenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeEvidenceCountAggregateInputType | true
    }

  export interface DisputeEvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisputeEvidence'], meta: { name: 'DisputeEvidence' } }
    /**
     * Find zero or one DisputeEvidence that matches the filter.
     * @param {DisputeEvidenceFindUniqueArgs} args - Arguments to find a DisputeEvidence
     * @example
     * // Get one DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeEvidenceFindUniqueArgs>(args: SelectSubset<T, DisputeEvidenceFindUniqueArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisputeEvidence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeEvidenceFindUniqueOrThrowArgs} args - Arguments to find a DisputeEvidence
     * @example
     * // Get one DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeEvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeEvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeEvidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceFindFirstArgs} args - Arguments to find a DisputeEvidence
     * @example
     * // Get one DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeEvidenceFindFirstArgs>(args?: SelectSubset<T, DisputeEvidenceFindFirstArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeEvidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceFindFirstOrThrowArgs} args - Arguments to find a DisputeEvidence
     * @example
     * // Get one DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeEvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeEvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisputeEvidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisputeEvidences
     * const disputeEvidences = await prisma.disputeEvidence.findMany()
     * 
     * // Get first 10 DisputeEvidences
     * const disputeEvidences = await prisma.disputeEvidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeEvidenceWithIdOnly = await prisma.disputeEvidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeEvidenceFindManyArgs>(args?: SelectSubset<T, DisputeEvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisputeEvidence.
     * @param {DisputeEvidenceCreateArgs} args - Arguments to create a DisputeEvidence.
     * @example
     * // Create one DisputeEvidence
     * const DisputeEvidence = await prisma.disputeEvidence.create({
     *   data: {
     *     // ... data to create a DisputeEvidence
     *   }
     * })
     * 
     */
    create<T extends DisputeEvidenceCreateArgs>(args: SelectSubset<T, DisputeEvidenceCreateArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisputeEvidences.
     * @param {DisputeEvidenceCreateManyArgs} args - Arguments to create many DisputeEvidences.
     * @example
     * // Create many DisputeEvidences
     * const disputeEvidence = await prisma.disputeEvidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeEvidenceCreateManyArgs>(args?: SelectSubset<T, DisputeEvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisputeEvidences and returns the data saved in the database.
     * @param {DisputeEvidenceCreateManyAndReturnArgs} args - Arguments to create many DisputeEvidences.
     * @example
     * // Create many DisputeEvidences
     * const disputeEvidence = await prisma.disputeEvidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisputeEvidences and only return the `id`
     * const disputeEvidenceWithIdOnly = await prisma.disputeEvidence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeEvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeEvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisputeEvidence.
     * @param {DisputeEvidenceDeleteArgs} args - Arguments to delete one DisputeEvidence.
     * @example
     * // Delete one DisputeEvidence
     * const DisputeEvidence = await prisma.disputeEvidence.delete({
     *   where: {
     *     // ... filter to delete one DisputeEvidence
     *   }
     * })
     * 
     */
    delete<T extends DisputeEvidenceDeleteArgs>(args: SelectSubset<T, DisputeEvidenceDeleteArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisputeEvidence.
     * @param {DisputeEvidenceUpdateArgs} args - Arguments to update one DisputeEvidence.
     * @example
     * // Update one DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeEvidenceUpdateArgs>(args: SelectSubset<T, DisputeEvidenceUpdateArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisputeEvidences.
     * @param {DisputeEvidenceDeleteManyArgs} args - Arguments to filter DisputeEvidences to delete.
     * @example
     * // Delete a few DisputeEvidences
     * const { count } = await prisma.disputeEvidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeEvidenceDeleteManyArgs>(args?: SelectSubset<T, DisputeEvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeEvidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisputeEvidences
     * const disputeEvidence = await prisma.disputeEvidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeEvidenceUpdateManyArgs>(args: SelectSubset<T, DisputeEvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeEvidences and returns the data updated in the database.
     * @param {DisputeEvidenceUpdateManyAndReturnArgs} args - Arguments to update many DisputeEvidences.
     * @example
     * // Update many DisputeEvidences
     * const disputeEvidence = await prisma.disputeEvidence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisputeEvidences and only return the `id`
     * const disputeEvidenceWithIdOnly = await prisma.disputeEvidence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeEvidenceUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeEvidenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisputeEvidence.
     * @param {DisputeEvidenceUpsertArgs} args - Arguments to update or create a DisputeEvidence.
     * @example
     * // Update or create a DisputeEvidence
     * const disputeEvidence = await prisma.disputeEvidence.upsert({
     *   create: {
     *     // ... data to create a DisputeEvidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisputeEvidence we want to update
     *   }
     * })
     */
    upsert<T extends DisputeEvidenceUpsertArgs>(args: SelectSubset<T, DisputeEvidenceUpsertArgs<ExtArgs>>): Prisma__DisputeEvidenceClient<$Result.GetResult<Prisma.$DisputeEvidencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisputeEvidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceCountArgs} args - Arguments to filter DisputeEvidences to count.
     * @example
     * // Count the number of DisputeEvidences
     * const count = await prisma.disputeEvidence.count({
     *   where: {
     *     // ... the filter for the DisputeEvidences we want to count
     *   }
     * })
    **/
    count<T extends DisputeEvidenceCountArgs>(
      args?: Subset<T, DisputeEvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeEvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisputeEvidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeEvidenceAggregateArgs>(args: Subset<T, DisputeEvidenceAggregateArgs>): Prisma.PrismaPromise<GetDisputeEvidenceAggregateType<T>>

    /**
     * Group by DisputeEvidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeEvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeEvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeEvidenceGroupByArgs['orderBy'] }
        : { orderBy?: DisputeEvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeEvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisputeEvidence model
   */
  readonly fields: DisputeEvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisputeEvidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeEvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispute<T extends DisputeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisputeDefaultArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisputeEvidence model
   */
  interface DisputeEvidenceFieldRefs {
    readonly id: FieldRef<"DisputeEvidence", 'String'>
    readonly disputeId: FieldRef<"DisputeEvidence", 'String'>
    readonly uploadedBy: FieldRef<"DisputeEvidence", 'String'>
    readonly type: FieldRef<"DisputeEvidence", 'EvidenceType'>
    readonly url: FieldRef<"DisputeEvidence", 'String'>
    readonly description: FieldRef<"DisputeEvidence", 'String'>
    readonly metadata: FieldRef<"DisputeEvidence", 'Json'>
    readonly uploadedAt: FieldRef<"DisputeEvidence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisputeEvidence findUnique
   */
  export type DisputeEvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which DisputeEvidence to fetch.
     */
    where: DisputeEvidenceWhereUniqueInput
  }

  /**
   * DisputeEvidence findUniqueOrThrow
   */
  export type DisputeEvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which DisputeEvidence to fetch.
     */
    where: DisputeEvidenceWhereUniqueInput
  }

  /**
   * DisputeEvidence findFirst
   */
  export type DisputeEvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which DisputeEvidence to fetch.
     */
    where?: DisputeEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeEvidences to fetch.
     */
    orderBy?: DisputeEvidenceOrderByWithRelationInput | DisputeEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeEvidences.
     */
    cursor?: DisputeEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeEvidences.
     */
    distinct?: DisputeEvidenceScalarFieldEnum | DisputeEvidenceScalarFieldEnum[]
  }

  /**
   * DisputeEvidence findFirstOrThrow
   */
  export type DisputeEvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which DisputeEvidence to fetch.
     */
    where?: DisputeEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeEvidences to fetch.
     */
    orderBy?: DisputeEvidenceOrderByWithRelationInput | DisputeEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeEvidences.
     */
    cursor?: DisputeEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeEvidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeEvidences.
     */
    distinct?: DisputeEvidenceScalarFieldEnum | DisputeEvidenceScalarFieldEnum[]
  }

  /**
   * DisputeEvidence findMany
   */
  export type DisputeEvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter, which DisputeEvidences to fetch.
     */
    where?: DisputeEvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeEvidences to fetch.
     */
    orderBy?: DisputeEvidenceOrderByWithRelationInput | DisputeEvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisputeEvidences.
     */
    cursor?: DisputeEvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeEvidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeEvidences.
     */
    skip?: number
    distinct?: DisputeEvidenceScalarFieldEnum | DisputeEvidenceScalarFieldEnum[]
  }

  /**
   * DisputeEvidence create
   */
  export type DisputeEvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a DisputeEvidence.
     */
    data: XOR<DisputeEvidenceCreateInput, DisputeEvidenceUncheckedCreateInput>
  }

  /**
   * DisputeEvidence createMany
   */
  export type DisputeEvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisputeEvidences.
     */
    data: DisputeEvidenceCreateManyInput | DisputeEvidenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisputeEvidence createManyAndReturn
   */
  export type DisputeEvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * The data used to create many DisputeEvidences.
     */
    data: DisputeEvidenceCreateManyInput | DisputeEvidenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeEvidence update
   */
  export type DisputeEvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a DisputeEvidence.
     */
    data: XOR<DisputeEvidenceUpdateInput, DisputeEvidenceUncheckedUpdateInput>
    /**
     * Choose, which DisputeEvidence to update.
     */
    where: DisputeEvidenceWhereUniqueInput
  }

  /**
   * DisputeEvidence updateMany
   */
  export type DisputeEvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisputeEvidences.
     */
    data: XOR<DisputeEvidenceUpdateManyMutationInput, DisputeEvidenceUncheckedUpdateManyInput>
    /**
     * Filter which DisputeEvidences to update
     */
    where?: DisputeEvidenceWhereInput
    /**
     * Limit how many DisputeEvidences to update.
     */
    limit?: number
  }

  /**
   * DisputeEvidence updateManyAndReturn
   */
  export type DisputeEvidenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * The data used to update DisputeEvidences.
     */
    data: XOR<DisputeEvidenceUpdateManyMutationInput, DisputeEvidenceUncheckedUpdateManyInput>
    /**
     * Filter which DisputeEvidences to update
     */
    where?: DisputeEvidenceWhereInput
    /**
     * Limit how many DisputeEvidences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeEvidence upsert
   */
  export type DisputeEvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the DisputeEvidence to update in case it exists.
     */
    where: DisputeEvidenceWhereUniqueInput
    /**
     * In case the DisputeEvidence found by the `where` argument doesn't exist, create a new DisputeEvidence with this data.
     */
    create: XOR<DisputeEvidenceCreateInput, DisputeEvidenceUncheckedCreateInput>
    /**
     * In case the DisputeEvidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeEvidenceUpdateInput, DisputeEvidenceUncheckedUpdateInput>
  }

  /**
   * DisputeEvidence delete
   */
  export type DisputeEvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
    /**
     * Filter which DisputeEvidence to delete.
     */
    where: DisputeEvidenceWhereUniqueInput
  }

  /**
   * DisputeEvidence deleteMany
   */
  export type DisputeEvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeEvidences to delete
     */
    where?: DisputeEvidenceWhereInput
    /**
     * Limit how many DisputeEvidences to delete.
     */
    limit?: number
  }

  /**
   * DisputeEvidence without action
   */
  export type DisputeEvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeEvidence
     */
    select?: DisputeEvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeEvidence
     */
    omit?: DisputeEvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeEvidenceInclude<ExtArgs> | null
  }


  /**
   * Model DisputeTimelineEvent
   */

  export type AggregateDisputeTimelineEvent = {
    _count: DisputeTimelineEventCountAggregateOutputType | null
    _min: DisputeTimelineEventMinAggregateOutputType | null
    _max: DisputeTimelineEventMaxAggregateOutputType | null
  }

  export type DisputeTimelineEventMinAggregateOutputType = {
    id: string | null
    disputeId: string | null
    eventType: string | null
    description: string | null
    createdAt: Date | null
  }

  export type DisputeTimelineEventMaxAggregateOutputType = {
    id: string | null
    disputeId: string | null
    eventType: string | null
    description: string | null
    createdAt: Date | null
  }

  export type DisputeTimelineEventCountAggregateOutputType = {
    id: number
    disputeId: number
    eventType: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type DisputeTimelineEventMinAggregateInputType = {
    id?: true
    disputeId?: true
    eventType?: true
    description?: true
    createdAt?: true
  }

  export type DisputeTimelineEventMaxAggregateInputType = {
    id?: true
    disputeId?: true
    eventType?: true
    description?: true
    createdAt?: true
  }

  export type DisputeTimelineEventCountAggregateInputType = {
    id?: true
    disputeId?: true
    eventType?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type DisputeTimelineEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeTimelineEvent to aggregate.
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeTimelineEvents to fetch.
     */
    orderBy?: DisputeTimelineEventOrderByWithRelationInput | DisputeTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisputeTimelineEvents
    **/
    _count?: true | DisputeTimelineEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeTimelineEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeTimelineEventMaxAggregateInputType
  }

  export type GetDisputeTimelineEventAggregateType<T extends DisputeTimelineEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDisputeTimelineEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisputeTimelineEvent[P]>
      : GetScalarType<T[P], AggregateDisputeTimelineEvent[P]>
  }




  export type DisputeTimelineEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeTimelineEventWhereInput
    orderBy?: DisputeTimelineEventOrderByWithAggregationInput | DisputeTimelineEventOrderByWithAggregationInput[]
    by: DisputeTimelineEventScalarFieldEnum[] | DisputeTimelineEventScalarFieldEnum
    having?: DisputeTimelineEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeTimelineEventCountAggregateInputType | true
    _min?: DisputeTimelineEventMinAggregateInputType
    _max?: DisputeTimelineEventMaxAggregateInputType
  }

  export type DisputeTimelineEventGroupByOutputType = {
    id: string
    disputeId: string
    eventType: string
    description: string
    metadata: JsonValue
    createdAt: Date
    _count: DisputeTimelineEventCountAggregateOutputType | null
    _min: DisputeTimelineEventMinAggregateOutputType | null
    _max: DisputeTimelineEventMaxAggregateOutputType | null
  }

  type GetDisputeTimelineEventGroupByPayload<T extends DisputeTimelineEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeTimelineEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeTimelineEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeTimelineEventGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeTimelineEventGroupByOutputType[P]>
        }
      >
    >


  export type DisputeTimelineEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    eventType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeTimelineEvent"]>

  export type DisputeTimelineEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    eventType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeTimelineEvent"]>

  export type DisputeTimelineEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    eventType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeTimelineEvent"]>

  export type DisputeTimelineEventSelectScalar = {
    id?: boolean
    disputeId?: boolean
    eventType?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type DisputeTimelineEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "disputeId" | "eventType" | "description" | "metadata" | "createdAt", ExtArgs["result"]["disputeTimelineEvent"]>
  export type DisputeTimelineEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeTimelineEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeTimelineEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }

  export type $DisputeTimelineEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisputeTimelineEvent"
    objects: {
      dispute: Prisma.$DisputePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      disputeId: string
      eventType: string
      description: string
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["disputeTimelineEvent"]>
    composites: {}
  }

  type DisputeTimelineEventGetPayload<S extends boolean | null | undefined | DisputeTimelineEventDefaultArgs> = $Result.GetResult<Prisma.$DisputeTimelineEventPayload, S>

  type DisputeTimelineEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeTimelineEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeTimelineEventCountAggregateInputType | true
    }

  export interface DisputeTimelineEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisputeTimelineEvent'], meta: { name: 'DisputeTimelineEvent' } }
    /**
     * Find zero or one DisputeTimelineEvent that matches the filter.
     * @param {DisputeTimelineEventFindUniqueArgs} args - Arguments to find a DisputeTimelineEvent
     * @example
     * // Get one DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeTimelineEventFindUniqueArgs>(args: SelectSubset<T, DisputeTimelineEventFindUniqueArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisputeTimelineEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeTimelineEventFindUniqueOrThrowArgs} args - Arguments to find a DisputeTimelineEvent
     * @example
     * // Get one DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeTimelineEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeTimelineEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeTimelineEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventFindFirstArgs} args - Arguments to find a DisputeTimelineEvent
     * @example
     * // Get one DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeTimelineEventFindFirstArgs>(args?: SelectSubset<T, DisputeTimelineEventFindFirstArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeTimelineEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventFindFirstOrThrowArgs} args - Arguments to find a DisputeTimelineEvent
     * @example
     * // Get one DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeTimelineEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeTimelineEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisputeTimelineEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisputeTimelineEvents
     * const disputeTimelineEvents = await prisma.disputeTimelineEvent.findMany()
     * 
     * // Get first 10 DisputeTimelineEvents
     * const disputeTimelineEvents = await prisma.disputeTimelineEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeTimelineEventWithIdOnly = await prisma.disputeTimelineEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeTimelineEventFindManyArgs>(args?: SelectSubset<T, DisputeTimelineEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisputeTimelineEvent.
     * @param {DisputeTimelineEventCreateArgs} args - Arguments to create a DisputeTimelineEvent.
     * @example
     * // Create one DisputeTimelineEvent
     * const DisputeTimelineEvent = await prisma.disputeTimelineEvent.create({
     *   data: {
     *     // ... data to create a DisputeTimelineEvent
     *   }
     * })
     * 
     */
    create<T extends DisputeTimelineEventCreateArgs>(args: SelectSubset<T, DisputeTimelineEventCreateArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisputeTimelineEvents.
     * @param {DisputeTimelineEventCreateManyArgs} args - Arguments to create many DisputeTimelineEvents.
     * @example
     * // Create many DisputeTimelineEvents
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeTimelineEventCreateManyArgs>(args?: SelectSubset<T, DisputeTimelineEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisputeTimelineEvents and returns the data saved in the database.
     * @param {DisputeTimelineEventCreateManyAndReturnArgs} args - Arguments to create many DisputeTimelineEvents.
     * @example
     * // Create many DisputeTimelineEvents
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisputeTimelineEvents and only return the `id`
     * const disputeTimelineEventWithIdOnly = await prisma.disputeTimelineEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeTimelineEventCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeTimelineEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisputeTimelineEvent.
     * @param {DisputeTimelineEventDeleteArgs} args - Arguments to delete one DisputeTimelineEvent.
     * @example
     * // Delete one DisputeTimelineEvent
     * const DisputeTimelineEvent = await prisma.disputeTimelineEvent.delete({
     *   where: {
     *     // ... filter to delete one DisputeTimelineEvent
     *   }
     * })
     * 
     */
    delete<T extends DisputeTimelineEventDeleteArgs>(args: SelectSubset<T, DisputeTimelineEventDeleteArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisputeTimelineEvent.
     * @param {DisputeTimelineEventUpdateArgs} args - Arguments to update one DisputeTimelineEvent.
     * @example
     * // Update one DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeTimelineEventUpdateArgs>(args: SelectSubset<T, DisputeTimelineEventUpdateArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisputeTimelineEvents.
     * @param {DisputeTimelineEventDeleteManyArgs} args - Arguments to filter DisputeTimelineEvents to delete.
     * @example
     * // Delete a few DisputeTimelineEvents
     * const { count } = await prisma.disputeTimelineEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeTimelineEventDeleteManyArgs>(args?: SelectSubset<T, DisputeTimelineEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisputeTimelineEvents
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeTimelineEventUpdateManyArgs>(args: SelectSubset<T, DisputeTimelineEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeTimelineEvents and returns the data updated in the database.
     * @param {DisputeTimelineEventUpdateManyAndReturnArgs} args - Arguments to update many DisputeTimelineEvents.
     * @example
     * // Update many DisputeTimelineEvents
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisputeTimelineEvents and only return the `id`
     * const disputeTimelineEventWithIdOnly = await prisma.disputeTimelineEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeTimelineEventUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeTimelineEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisputeTimelineEvent.
     * @param {DisputeTimelineEventUpsertArgs} args - Arguments to update or create a DisputeTimelineEvent.
     * @example
     * // Update or create a DisputeTimelineEvent
     * const disputeTimelineEvent = await prisma.disputeTimelineEvent.upsert({
     *   create: {
     *     // ... data to create a DisputeTimelineEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisputeTimelineEvent we want to update
     *   }
     * })
     */
    upsert<T extends DisputeTimelineEventUpsertArgs>(args: SelectSubset<T, DisputeTimelineEventUpsertArgs<ExtArgs>>): Prisma__DisputeTimelineEventClient<$Result.GetResult<Prisma.$DisputeTimelineEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisputeTimelineEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventCountArgs} args - Arguments to filter DisputeTimelineEvents to count.
     * @example
     * // Count the number of DisputeTimelineEvents
     * const count = await prisma.disputeTimelineEvent.count({
     *   where: {
     *     // ... the filter for the DisputeTimelineEvents we want to count
     *   }
     * })
    **/
    count<T extends DisputeTimelineEventCountArgs>(
      args?: Subset<T, DisputeTimelineEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeTimelineEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisputeTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeTimelineEventAggregateArgs>(args: Subset<T, DisputeTimelineEventAggregateArgs>): Prisma.PrismaPromise<GetDisputeTimelineEventAggregateType<T>>

    /**
     * Group by DisputeTimelineEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeTimelineEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeTimelineEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeTimelineEventGroupByArgs['orderBy'] }
        : { orderBy?: DisputeTimelineEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeTimelineEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeTimelineEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisputeTimelineEvent model
   */
  readonly fields: DisputeTimelineEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisputeTimelineEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeTimelineEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispute<T extends DisputeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisputeDefaultArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisputeTimelineEvent model
   */
  interface DisputeTimelineEventFieldRefs {
    readonly id: FieldRef<"DisputeTimelineEvent", 'String'>
    readonly disputeId: FieldRef<"DisputeTimelineEvent", 'String'>
    readonly eventType: FieldRef<"DisputeTimelineEvent", 'String'>
    readonly description: FieldRef<"DisputeTimelineEvent", 'String'>
    readonly metadata: FieldRef<"DisputeTimelineEvent", 'Json'>
    readonly createdAt: FieldRef<"DisputeTimelineEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisputeTimelineEvent findUnique
   */
  export type DisputeTimelineEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which DisputeTimelineEvent to fetch.
     */
    where: DisputeTimelineEventWhereUniqueInput
  }

  /**
   * DisputeTimelineEvent findUniqueOrThrow
   */
  export type DisputeTimelineEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which DisputeTimelineEvent to fetch.
     */
    where: DisputeTimelineEventWhereUniqueInput
  }

  /**
   * DisputeTimelineEvent findFirst
   */
  export type DisputeTimelineEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which DisputeTimelineEvent to fetch.
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeTimelineEvents to fetch.
     */
    orderBy?: DisputeTimelineEventOrderByWithRelationInput | DisputeTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeTimelineEvents.
     */
    cursor?: DisputeTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeTimelineEvents.
     */
    distinct?: DisputeTimelineEventScalarFieldEnum | DisputeTimelineEventScalarFieldEnum[]
  }

  /**
   * DisputeTimelineEvent findFirstOrThrow
   */
  export type DisputeTimelineEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which DisputeTimelineEvent to fetch.
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeTimelineEvents to fetch.
     */
    orderBy?: DisputeTimelineEventOrderByWithRelationInput | DisputeTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeTimelineEvents.
     */
    cursor?: DisputeTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeTimelineEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeTimelineEvents.
     */
    distinct?: DisputeTimelineEventScalarFieldEnum | DisputeTimelineEventScalarFieldEnum[]
  }

  /**
   * DisputeTimelineEvent findMany
   */
  export type DisputeTimelineEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter, which DisputeTimelineEvents to fetch.
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeTimelineEvents to fetch.
     */
    orderBy?: DisputeTimelineEventOrderByWithRelationInput | DisputeTimelineEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisputeTimelineEvents.
     */
    cursor?: DisputeTimelineEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeTimelineEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeTimelineEvents.
     */
    skip?: number
    distinct?: DisputeTimelineEventScalarFieldEnum | DisputeTimelineEventScalarFieldEnum[]
  }

  /**
   * DisputeTimelineEvent create
   */
  export type DisputeTimelineEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DisputeTimelineEvent.
     */
    data: XOR<DisputeTimelineEventCreateInput, DisputeTimelineEventUncheckedCreateInput>
  }

  /**
   * DisputeTimelineEvent createMany
   */
  export type DisputeTimelineEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisputeTimelineEvents.
     */
    data: DisputeTimelineEventCreateManyInput | DisputeTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisputeTimelineEvent createManyAndReturn
   */
  export type DisputeTimelineEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * The data used to create many DisputeTimelineEvents.
     */
    data: DisputeTimelineEventCreateManyInput | DisputeTimelineEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeTimelineEvent update
   */
  export type DisputeTimelineEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DisputeTimelineEvent.
     */
    data: XOR<DisputeTimelineEventUpdateInput, DisputeTimelineEventUncheckedUpdateInput>
    /**
     * Choose, which DisputeTimelineEvent to update.
     */
    where: DisputeTimelineEventWhereUniqueInput
  }

  /**
   * DisputeTimelineEvent updateMany
   */
  export type DisputeTimelineEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisputeTimelineEvents.
     */
    data: XOR<DisputeTimelineEventUpdateManyMutationInput, DisputeTimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which DisputeTimelineEvents to update
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * Limit how many DisputeTimelineEvents to update.
     */
    limit?: number
  }

  /**
   * DisputeTimelineEvent updateManyAndReturn
   */
  export type DisputeTimelineEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * The data used to update DisputeTimelineEvents.
     */
    data: XOR<DisputeTimelineEventUpdateManyMutationInput, DisputeTimelineEventUncheckedUpdateManyInput>
    /**
     * Filter which DisputeTimelineEvents to update
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * Limit how many DisputeTimelineEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeTimelineEvent upsert
   */
  export type DisputeTimelineEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DisputeTimelineEvent to update in case it exists.
     */
    where: DisputeTimelineEventWhereUniqueInput
    /**
     * In case the DisputeTimelineEvent found by the `where` argument doesn't exist, create a new DisputeTimelineEvent with this data.
     */
    create: XOR<DisputeTimelineEventCreateInput, DisputeTimelineEventUncheckedCreateInput>
    /**
     * In case the DisputeTimelineEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeTimelineEventUpdateInput, DisputeTimelineEventUncheckedUpdateInput>
  }

  /**
   * DisputeTimelineEvent delete
   */
  export type DisputeTimelineEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
    /**
     * Filter which DisputeTimelineEvent to delete.
     */
    where: DisputeTimelineEventWhereUniqueInput
  }

  /**
   * DisputeTimelineEvent deleteMany
   */
  export type DisputeTimelineEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeTimelineEvents to delete
     */
    where?: DisputeTimelineEventWhereInput
    /**
     * Limit how many DisputeTimelineEvents to delete.
     */
    limit?: number
  }

  /**
   * DisputeTimelineEvent without action
   */
  export type DisputeTimelineEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeTimelineEvent
     */
    select?: DisputeTimelineEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeTimelineEvent
     */
    omit?: DisputeTimelineEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeTimelineEventInclude<ExtArgs> | null
  }


  /**
   * Model DisputeResolution
   */

  export type AggregateDisputeResolution = {
    _count: DisputeResolutionCountAggregateOutputType | null
    _avg: DisputeResolutionAvgAggregateOutputType | null
    _sum: DisputeResolutionSumAggregateOutputType | null
    _min: DisputeResolutionMinAggregateOutputType | null
    _max: DisputeResolutionMaxAggregateOutputType | null
  }

  export type DisputeResolutionAvgAggregateOutputType = {
    refundAmount: number | null
    payoutAdjustment: number | null
  }

  export type DisputeResolutionSumAggregateOutputType = {
    refundAmount: number | null
    payoutAdjustment: number | null
  }

  export type DisputeResolutionMinAggregateOutputType = {
    id: string | null
    disputeId: string | null
    outcome: $Enums.ResolutionOutcome | null
    summary: string | null
    refundAmount: number | null
    payoutAdjustment: number | null
    resolvedBy: string | null
    resolvedAt: Date | null
  }

  export type DisputeResolutionMaxAggregateOutputType = {
    id: string | null
    disputeId: string | null
    outcome: $Enums.ResolutionOutcome | null
    summary: string | null
    refundAmount: number | null
    payoutAdjustment: number | null
    resolvedBy: string | null
    resolvedAt: Date | null
  }

  export type DisputeResolutionCountAggregateOutputType = {
    id: number
    disputeId: number
    outcome: number
    summary: number
    refundAmount: number
    payoutAdjustment: number
    actionsTaken: number
    resolvedBy: number
    resolvedAt: number
    _all: number
  }


  export type DisputeResolutionAvgAggregateInputType = {
    refundAmount?: true
    payoutAdjustment?: true
  }

  export type DisputeResolutionSumAggregateInputType = {
    refundAmount?: true
    payoutAdjustment?: true
  }

  export type DisputeResolutionMinAggregateInputType = {
    id?: true
    disputeId?: true
    outcome?: true
    summary?: true
    refundAmount?: true
    payoutAdjustment?: true
    resolvedBy?: true
    resolvedAt?: true
  }

  export type DisputeResolutionMaxAggregateInputType = {
    id?: true
    disputeId?: true
    outcome?: true
    summary?: true
    refundAmount?: true
    payoutAdjustment?: true
    resolvedBy?: true
    resolvedAt?: true
  }

  export type DisputeResolutionCountAggregateInputType = {
    id?: true
    disputeId?: true
    outcome?: true
    summary?: true
    refundAmount?: true
    payoutAdjustment?: true
    actionsTaken?: true
    resolvedBy?: true
    resolvedAt?: true
    _all?: true
  }

  export type DisputeResolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeResolution to aggregate.
     */
    where?: DisputeResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResolutions to fetch.
     */
    orderBy?: DisputeResolutionOrderByWithRelationInput | DisputeResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisputeResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisputeResolutions
    **/
    _count?: true | DisputeResolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DisputeResolutionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DisputeResolutionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisputeResolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisputeResolutionMaxAggregateInputType
  }

  export type GetDisputeResolutionAggregateType<T extends DisputeResolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateDisputeResolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisputeResolution[P]>
      : GetScalarType<T[P], AggregateDisputeResolution[P]>
  }




  export type DisputeResolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisputeResolutionWhereInput
    orderBy?: DisputeResolutionOrderByWithAggregationInput | DisputeResolutionOrderByWithAggregationInput[]
    by: DisputeResolutionScalarFieldEnum[] | DisputeResolutionScalarFieldEnum
    having?: DisputeResolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisputeResolutionCountAggregateInputType | true
    _avg?: DisputeResolutionAvgAggregateInputType
    _sum?: DisputeResolutionSumAggregateInputType
    _min?: DisputeResolutionMinAggregateInputType
    _max?: DisputeResolutionMaxAggregateInputType
  }

  export type DisputeResolutionGroupByOutputType = {
    id: string
    disputeId: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount: number | null
    payoutAdjustment: number | null
    actionsTaken: JsonValue
    resolvedBy: string
    resolvedAt: Date
    _count: DisputeResolutionCountAggregateOutputType | null
    _avg: DisputeResolutionAvgAggregateOutputType | null
    _sum: DisputeResolutionSumAggregateOutputType | null
    _min: DisputeResolutionMinAggregateOutputType | null
    _max: DisputeResolutionMaxAggregateOutputType | null
  }

  type GetDisputeResolutionGroupByPayload<T extends DisputeResolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisputeResolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisputeResolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisputeResolutionGroupByOutputType[P]>
            : GetScalarType<T[P], DisputeResolutionGroupByOutputType[P]>
        }
      >
    >


  export type DisputeResolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    outcome?: boolean
    summary?: boolean
    refundAmount?: boolean
    payoutAdjustment?: boolean
    actionsTaken?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResolution"]>

  export type DisputeResolutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    outcome?: boolean
    summary?: boolean
    refundAmount?: boolean
    payoutAdjustment?: boolean
    actionsTaken?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResolution"]>

  export type DisputeResolutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    disputeId?: boolean
    outcome?: boolean
    summary?: boolean
    refundAmount?: boolean
    payoutAdjustment?: boolean
    actionsTaken?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disputeResolution"]>

  export type DisputeResolutionSelectScalar = {
    id?: boolean
    disputeId?: boolean
    outcome?: boolean
    summary?: boolean
    refundAmount?: boolean
    payoutAdjustment?: boolean
    actionsTaken?: boolean
    resolvedBy?: boolean
    resolvedAt?: boolean
  }

  export type DisputeResolutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "disputeId" | "outcome" | "summary" | "refundAmount" | "payoutAdjustment" | "actionsTaken" | "resolvedBy" | "resolvedAt", ExtArgs["result"]["disputeResolution"]>
  export type DisputeResolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeResolutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }
  export type DisputeResolutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dispute?: boolean | DisputeDefaultArgs<ExtArgs>
  }

  export type $DisputeResolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisputeResolution"
    objects: {
      dispute: Prisma.$DisputePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      disputeId: string
      outcome: $Enums.ResolutionOutcome
      summary: string
      refundAmount: number | null
      payoutAdjustment: number | null
      actionsTaken: Prisma.JsonValue
      resolvedBy: string
      resolvedAt: Date
    }, ExtArgs["result"]["disputeResolution"]>
    composites: {}
  }

  type DisputeResolutionGetPayload<S extends boolean | null | undefined | DisputeResolutionDefaultArgs> = $Result.GetResult<Prisma.$DisputeResolutionPayload, S>

  type DisputeResolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisputeResolutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisputeResolutionCountAggregateInputType | true
    }

  export interface DisputeResolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisputeResolution'], meta: { name: 'DisputeResolution' } }
    /**
     * Find zero or one DisputeResolution that matches the filter.
     * @param {DisputeResolutionFindUniqueArgs} args - Arguments to find a DisputeResolution
     * @example
     * // Get one DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisputeResolutionFindUniqueArgs>(args: SelectSubset<T, DisputeResolutionFindUniqueArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisputeResolution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisputeResolutionFindUniqueOrThrowArgs} args - Arguments to find a DisputeResolution
     * @example
     * // Get one DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisputeResolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, DisputeResolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeResolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionFindFirstArgs} args - Arguments to find a DisputeResolution
     * @example
     * // Get one DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisputeResolutionFindFirstArgs>(args?: SelectSubset<T, DisputeResolutionFindFirstArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisputeResolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionFindFirstOrThrowArgs} args - Arguments to find a DisputeResolution
     * @example
     * // Get one DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisputeResolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, DisputeResolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisputeResolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisputeResolutions
     * const disputeResolutions = await prisma.disputeResolution.findMany()
     * 
     * // Get first 10 DisputeResolutions
     * const disputeResolutions = await prisma.disputeResolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disputeResolutionWithIdOnly = await prisma.disputeResolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisputeResolutionFindManyArgs>(args?: SelectSubset<T, DisputeResolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisputeResolution.
     * @param {DisputeResolutionCreateArgs} args - Arguments to create a DisputeResolution.
     * @example
     * // Create one DisputeResolution
     * const DisputeResolution = await prisma.disputeResolution.create({
     *   data: {
     *     // ... data to create a DisputeResolution
     *   }
     * })
     * 
     */
    create<T extends DisputeResolutionCreateArgs>(args: SelectSubset<T, DisputeResolutionCreateArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisputeResolutions.
     * @param {DisputeResolutionCreateManyArgs} args - Arguments to create many DisputeResolutions.
     * @example
     * // Create many DisputeResolutions
     * const disputeResolution = await prisma.disputeResolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisputeResolutionCreateManyArgs>(args?: SelectSubset<T, DisputeResolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisputeResolutions and returns the data saved in the database.
     * @param {DisputeResolutionCreateManyAndReturnArgs} args - Arguments to create many DisputeResolutions.
     * @example
     * // Create many DisputeResolutions
     * const disputeResolution = await prisma.disputeResolution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisputeResolutions and only return the `id`
     * const disputeResolutionWithIdOnly = await prisma.disputeResolution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisputeResolutionCreateManyAndReturnArgs>(args?: SelectSubset<T, DisputeResolutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisputeResolution.
     * @param {DisputeResolutionDeleteArgs} args - Arguments to delete one DisputeResolution.
     * @example
     * // Delete one DisputeResolution
     * const DisputeResolution = await prisma.disputeResolution.delete({
     *   where: {
     *     // ... filter to delete one DisputeResolution
     *   }
     * })
     * 
     */
    delete<T extends DisputeResolutionDeleteArgs>(args: SelectSubset<T, DisputeResolutionDeleteArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisputeResolution.
     * @param {DisputeResolutionUpdateArgs} args - Arguments to update one DisputeResolution.
     * @example
     * // Update one DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisputeResolutionUpdateArgs>(args: SelectSubset<T, DisputeResolutionUpdateArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisputeResolutions.
     * @param {DisputeResolutionDeleteManyArgs} args - Arguments to filter DisputeResolutions to delete.
     * @example
     * // Delete a few DisputeResolutions
     * const { count } = await prisma.disputeResolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisputeResolutionDeleteManyArgs>(args?: SelectSubset<T, DisputeResolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisputeResolutions
     * const disputeResolution = await prisma.disputeResolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisputeResolutionUpdateManyArgs>(args: SelectSubset<T, DisputeResolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisputeResolutions and returns the data updated in the database.
     * @param {DisputeResolutionUpdateManyAndReturnArgs} args - Arguments to update many DisputeResolutions.
     * @example
     * // Update many DisputeResolutions
     * const disputeResolution = await prisma.disputeResolution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisputeResolutions and only return the `id`
     * const disputeResolutionWithIdOnly = await prisma.disputeResolution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisputeResolutionUpdateManyAndReturnArgs>(args: SelectSubset<T, DisputeResolutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisputeResolution.
     * @param {DisputeResolutionUpsertArgs} args - Arguments to update or create a DisputeResolution.
     * @example
     * // Update or create a DisputeResolution
     * const disputeResolution = await prisma.disputeResolution.upsert({
     *   create: {
     *     // ... data to create a DisputeResolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisputeResolution we want to update
     *   }
     * })
     */
    upsert<T extends DisputeResolutionUpsertArgs>(args: SelectSubset<T, DisputeResolutionUpsertArgs<ExtArgs>>): Prisma__DisputeResolutionClient<$Result.GetResult<Prisma.$DisputeResolutionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisputeResolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionCountArgs} args - Arguments to filter DisputeResolutions to count.
     * @example
     * // Count the number of DisputeResolutions
     * const count = await prisma.disputeResolution.count({
     *   where: {
     *     // ... the filter for the DisputeResolutions we want to count
     *   }
     * })
    **/
    count<T extends DisputeResolutionCountArgs>(
      args?: Subset<T, DisputeResolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisputeResolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisputeResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisputeResolutionAggregateArgs>(args: Subset<T, DisputeResolutionAggregateArgs>): Prisma.PrismaPromise<GetDisputeResolutionAggregateType<T>>

    /**
     * Group by DisputeResolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisputeResolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisputeResolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisputeResolutionGroupByArgs['orderBy'] }
        : { orderBy?: DisputeResolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisputeResolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisputeResolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisputeResolution model
   */
  readonly fields: DisputeResolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisputeResolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisputeResolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dispute<T extends DisputeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DisputeDefaultArgs<ExtArgs>>): Prisma__DisputeClient<$Result.GetResult<Prisma.$DisputePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisputeResolution model
   */
  interface DisputeResolutionFieldRefs {
    readonly id: FieldRef<"DisputeResolution", 'String'>
    readonly disputeId: FieldRef<"DisputeResolution", 'String'>
    readonly outcome: FieldRef<"DisputeResolution", 'ResolutionOutcome'>
    readonly summary: FieldRef<"DisputeResolution", 'String'>
    readonly refundAmount: FieldRef<"DisputeResolution", 'Float'>
    readonly payoutAdjustment: FieldRef<"DisputeResolution", 'Float'>
    readonly actionsTaken: FieldRef<"DisputeResolution", 'Json'>
    readonly resolvedBy: FieldRef<"DisputeResolution", 'String'>
    readonly resolvedAt: FieldRef<"DisputeResolution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DisputeResolution findUnique
   */
  export type DisputeResolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResolution to fetch.
     */
    where: DisputeResolutionWhereUniqueInput
  }

  /**
   * DisputeResolution findUniqueOrThrow
   */
  export type DisputeResolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResolution to fetch.
     */
    where: DisputeResolutionWhereUniqueInput
  }

  /**
   * DisputeResolution findFirst
   */
  export type DisputeResolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResolution to fetch.
     */
    where?: DisputeResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResolutions to fetch.
     */
    orderBy?: DisputeResolutionOrderByWithRelationInput | DisputeResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeResolutions.
     */
    cursor?: DisputeResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeResolutions.
     */
    distinct?: DisputeResolutionScalarFieldEnum | DisputeResolutionScalarFieldEnum[]
  }

  /**
   * DisputeResolution findFirstOrThrow
   */
  export type DisputeResolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResolution to fetch.
     */
    where?: DisputeResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResolutions to fetch.
     */
    orderBy?: DisputeResolutionOrderByWithRelationInput | DisputeResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisputeResolutions.
     */
    cursor?: DisputeResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisputeResolutions.
     */
    distinct?: DisputeResolutionScalarFieldEnum | DisputeResolutionScalarFieldEnum[]
  }

  /**
   * DisputeResolution findMany
   */
  export type DisputeResolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter, which DisputeResolutions to fetch.
     */
    where?: DisputeResolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisputeResolutions to fetch.
     */
    orderBy?: DisputeResolutionOrderByWithRelationInput | DisputeResolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisputeResolutions.
     */
    cursor?: DisputeResolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisputeResolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisputeResolutions.
     */
    skip?: number
    distinct?: DisputeResolutionScalarFieldEnum | DisputeResolutionScalarFieldEnum[]
  }

  /**
   * DisputeResolution create
   */
  export type DisputeResolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a DisputeResolution.
     */
    data: XOR<DisputeResolutionCreateInput, DisputeResolutionUncheckedCreateInput>
  }

  /**
   * DisputeResolution createMany
   */
  export type DisputeResolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisputeResolutions.
     */
    data: DisputeResolutionCreateManyInput | DisputeResolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisputeResolution createManyAndReturn
   */
  export type DisputeResolutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * The data used to create many DisputeResolutions.
     */
    data: DisputeResolutionCreateManyInput | DisputeResolutionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeResolution update
   */
  export type DisputeResolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a DisputeResolution.
     */
    data: XOR<DisputeResolutionUpdateInput, DisputeResolutionUncheckedUpdateInput>
    /**
     * Choose, which DisputeResolution to update.
     */
    where: DisputeResolutionWhereUniqueInput
  }

  /**
   * DisputeResolution updateMany
   */
  export type DisputeResolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisputeResolutions.
     */
    data: XOR<DisputeResolutionUpdateManyMutationInput, DisputeResolutionUncheckedUpdateManyInput>
    /**
     * Filter which DisputeResolutions to update
     */
    where?: DisputeResolutionWhereInput
    /**
     * Limit how many DisputeResolutions to update.
     */
    limit?: number
  }

  /**
   * DisputeResolution updateManyAndReturn
   */
  export type DisputeResolutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * The data used to update DisputeResolutions.
     */
    data: XOR<DisputeResolutionUpdateManyMutationInput, DisputeResolutionUncheckedUpdateManyInput>
    /**
     * Filter which DisputeResolutions to update
     */
    where?: DisputeResolutionWhereInput
    /**
     * Limit how many DisputeResolutions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisputeResolution upsert
   */
  export type DisputeResolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the DisputeResolution to update in case it exists.
     */
    where: DisputeResolutionWhereUniqueInput
    /**
     * In case the DisputeResolution found by the `where` argument doesn't exist, create a new DisputeResolution with this data.
     */
    create: XOR<DisputeResolutionCreateInput, DisputeResolutionUncheckedCreateInput>
    /**
     * In case the DisputeResolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisputeResolutionUpdateInput, DisputeResolutionUncheckedUpdateInput>
  }

  /**
   * DisputeResolution delete
   */
  export type DisputeResolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
    /**
     * Filter which DisputeResolution to delete.
     */
    where: DisputeResolutionWhereUniqueInput
  }

  /**
   * DisputeResolution deleteMany
   */
  export type DisputeResolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisputeResolutions to delete
     */
    where?: DisputeResolutionWhereInput
    /**
     * Limit how many DisputeResolutions to delete.
     */
    limit?: number
  }

  /**
   * DisputeResolution without action
   */
  export type DisputeResolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisputeResolution
     */
    select?: DisputeResolutionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisputeResolution
     */
    omit?: DisputeResolutionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisputeResolutionInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    relatedId: string | null
    relatedType: string | null
    actionUrl: string | null
    actionLabel: string | null
    read: boolean | null
    readAt: Date | null
    status: string | null
    sentViaEmail: boolean | null
    sentViaPush: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    relatedId: string | null
    relatedType: string | null
    actionUrl: string | null
    actionLabel: string | null
    read: boolean | null
    readAt: Date | null
    status: string | null
    sentViaEmail: boolean | null
    sentViaPush: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    relatedId: number
    relatedType: number
    actionUrl: number
    actionLabel: number
    read: number
    readAt: number
    status: number
    sentViaEmail: number
    sentViaPush: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    relatedId?: true
    relatedType?: true
    actionUrl?: true
    actionLabel?: true
    read?: true
    readAt?: true
    status?: true
    sentViaEmail?: true
    sentViaPush?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    relatedId?: true
    relatedType?: true
    actionUrl?: true
    actionLabel?: true
    read?: true
    readAt?: true
    status?: true
    sentViaEmail?: true
    sentViaPush?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    relatedId?: true
    relatedType?: true
    actionUrl?: true
    actionLabel?: true
    read?: true
    readAt?: true
    status?: true
    sentViaEmail?: true
    sentViaPush?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data: JsonValue | null
    relatedId: string | null
    relatedType: string | null
    actionUrl: string | null
    actionLabel: string | null
    read: boolean
    readAt: Date | null
    status: string | null
    sentViaEmail: boolean
    sentViaPush: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    relatedId?: boolean
    relatedType?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    read?: boolean
    readAt?: boolean
    status?: boolean
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    relatedId?: boolean
    relatedType?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    read?: boolean
    readAt?: boolean
    status?: boolean
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    relatedId?: boolean
    relatedType?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    read?: boolean
    readAt?: boolean
    status?: boolean
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    relatedId?: boolean
    relatedType?: boolean
    actionUrl?: boolean
    actionLabel?: boolean
    read?: boolean
    readAt?: boolean
    status?: boolean
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "data" | "relatedId" | "relatedType" | "actionUrl" | "actionLabel" | "read" | "readAt" | "status" | "sentViaEmail" | "sentViaPush" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      data: Prisma.JsonValue | null
      relatedId: string | null
      relatedType: string | null
      actionUrl: string | null
      actionLabel: string | null
      read: boolean
      readAt: Date | null
      status: string | null
      sentViaEmail: boolean
      sentViaPush: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly relatedId: FieldRef<"Notification", 'String'>
    readonly relatedType: FieldRef<"Notification", 'String'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly actionLabel: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly status: FieldRef<"Notification", 'String'>
    readonly sentViaEmail: FieldRef<"Notification", 'Boolean'>
    readonly sentViaPush: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    metadata: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    metadata?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    metadata: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    metadata?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "oldValues" | "newValues" | "metadata" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValues: FieldRef<"AuditLog", 'Json'>
    readonly newValues: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model InsurancePolicy
   */

  export type AggregateInsurancePolicy = {
    _count: InsurancePolicyCountAggregateOutputType | null
    _avg: InsurancePolicyAvgAggregateOutputType | null
    _sum: InsurancePolicySumAggregateOutputType | null
    _min: InsurancePolicyMinAggregateOutputType | null
    _max: InsurancePolicyMaxAggregateOutputType | null
  }

  export type InsurancePolicyAvgAggregateOutputType = {
    coverageAmount: number | null
  }

  export type InsurancePolicySumAggregateOutputType = {
    coverageAmount: number | null
  }

  export type InsurancePolicyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    policyNumber: string | null
    provider: string | null
    type: string | null
    coverageAmount: number | null
    effectiveDate: Date | null
    expirationDate: Date | null
    documentUrl: string | null
    certificateUrl: string | null
    status: $Enums.InsuranceStatus | null
    verificationDate: Date | null
    verifiedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsurancePolicyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    policyNumber: string | null
    provider: string | null
    type: string | null
    coverageAmount: number | null
    effectiveDate: Date | null
    expirationDate: Date | null
    documentUrl: string | null
    certificateUrl: string | null
    status: $Enums.InsuranceStatus | null
    verificationDate: Date | null
    verifiedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsurancePolicyCountAggregateOutputType = {
    id: number
    userId: number
    listingId: number
    policyNumber: number
    provider: number
    type: number
    coverageAmount: number
    effectiveDate: number
    expirationDate: number
    documentUrl: number
    certificateUrl: number
    status: number
    verificationDate: number
    verifiedBy: number
    notes: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsurancePolicyAvgAggregateInputType = {
    coverageAmount?: true
  }

  export type InsurancePolicySumAggregateInputType = {
    coverageAmount?: true
  }

  export type InsurancePolicyMinAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    policyNumber?: true
    provider?: true
    type?: true
    coverageAmount?: true
    effectiveDate?: true
    expirationDate?: true
    documentUrl?: true
    certificateUrl?: true
    status?: true
    verificationDate?: true
    verifiedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsurancePolicyMaxAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    policyNumber?: true
    provider?: true
    type?: true
    coverageAmount?: true
    effectiveDate?: true
    expirationDate?: true
    documentUrl?: true
    certificateUrl?: true
    status?: true
    verificationDate?: true
    verifiedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsurancePolicyCountAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    policyNumber?: true
    provider?: true
    type?: true
    coverageAmount?: true
    effectiveDate?: true
    expirationDate?: true
    documentUrl?: true
    certificateUrl?: true
    status?: true
    verificationDate?: true
    verifiedBy?: true
    notes?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsurancePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurancePolicy to aggregate.
     */
    where?: InsurancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePolicies to fetch.
     */
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsurancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsurancePolicies
    **/
    _count?: true | InsurancePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsurancePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsurancePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsurancePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsurancePolicyMaxAggregateInputType
  }

  export type GetInsurancePolicyAggregateType<T extends InsurancePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateInsurancePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsurancePolicy[P]>
      : GetScalarType<T[P], AggregateInsurancePolicy[P]>
  }




  export type InsurancePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsurancePolicyWhereInput
    orderBy?: InsurancePolicyOrderByWithAggregationInput | InsurancePolicyOrderByWithAggregationInput[]
    by: InsurancePolicyScalarFieldEnum[] | InsurancePolicyScalarFieldEnum
    having?: InsurancePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsurancePolicyCountAggregateInputType | true
    _avg?: InsurancePolicyAvgAggregateInputType
    _sum?: InsurancePolicySumAggregateInputType
    _min?: InsurancePolicyMinAggregateInputType
    _max?: InsurancePolicyMaxAggregateInputType
  }

  export type InsurancePolicyGroupByOutputType = {
    id: string
    userId: string
    listingId: string | null
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date
    expirationDate: Date
    documentUrl: string
    certificateUrl: string | null
    status: $Enums.InsuranceStatus
    verificationDate: Date | null
    verifiedBy: string | null
    notes: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: InsurancePolicyCountAggregateOutputType | null
    _avg: InsurancePolicyAvgAggregateOutputType | null
    _sum: InsurancePolicySumAggregateOutputType | null
    _min: InsurancePolicyMinAggregateOutputType | null
    _max: InsurancePolicyMaxAggregateOutputType | null
  }

  type GetInsurancePolicyGroupByPayload<T extends InsurancePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsurancePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsurancePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsurancePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], InsurancePolicyGroupByOutputType[P]>
        }
      >
    >


  export type InsurancePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    policyNumber?: boolean
    provider?: boolean
    type?: boolean
    coverageAmount?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    documentUrl?: boolean
    certificateUrl?: boolean
    status?: boolean
    verificationDate?: boolean
    verifiedBy?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }, ExtArgs["result"]["insurancePolicy"]>

  export type InsurancePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    policyNumber?: boolean
    provider?: boolean
    type?: boolean
    coverageAmount?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    documentUrl?: boolean
    certificateUrl?: boolean
    status?: boolean
    verificationDate?: boolean
    verifiedBy?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }, ExtArgs["result"]["insurancePolicy"]>

  export type InsurancePolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    policyNumber?: boolean
    provider?: boolean
    type?: boolean
    coverageAmount?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    documentUrl?: boolean
    certificateUrl?: boolean
    status?: boolean
    verificationDate?: boolean
    verifiedBy?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }, ExtArgs["result"]["insurancePolicy"]>

  export type InsurancePolicySelectScalar = {
    id?: boolean
    userId?: boolean
    listingId?: boolean
    policyNumber?: boolean
    provider?: boolean
    type?: boolean
    coverageAmount?: boolean
    effectiveDate?: boolean
    expirationDate?: boolean
    documentUrl?: boolean
    certificateUrl?: boolean
    status?: boolean
    verificationDate?: boolean
    verifiedBy?: boolean
    notes?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsurancePolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "listingId" | "policyNumber" | "provider" | "type" | "coverageAmount" | "effectiveDate" | "expirationDate" | "documentUrl" | "certificateUrl" | "status" | "verificationDate" | "verifiedBy" | "notes" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["insurancePolicy"]>
  export type InsurancePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }
  export type InsurancePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }
  export type InsurancePolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | InsurancePolicy$listingArgs<ExtArgs>
  }

  export type $InsurancePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsurancePolicy"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      listingId: string | null
      policyNumber: string
      provider: string
      type: string
      coverageAmount: number
      effectiveDate: Date
      expirationDate: Date
      documentUrl: string
      certificateUrl: string | null
      status: $Enums.InsuranceStatus
      verificationDate: Date | null
      verifiedBy: string | null
      notes: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insurancePolicy"]>
    composites: {}
  }

  type InsurancePolicyGetPayload<S extends boolean | null | undefined | InsurancePolicyDefaultArgs> = $Result.GetResult<Prisma.$InsurancePolicyPayload, S>

  type InsurancePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsurancePolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsurancePolicyCountAggregateInputType | true
    }

  export interface InsurancePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsurancePolicy'], meta: { name: 'InsurancePolicy' } }
    /**
     * Find zero or one InsurancePolicy that matches the filter.
     * @param {InsurancePolicyFindUniqueArgs} args - Arguments to find a InsurancePolicy
     * @example
     * // Get one InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsurancePolicyFindUniqueArgs>(args: SelectSubset<T, InsurancePolicyFindUniqueArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsurancePolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsurancePolicyFindUniqueOrThrowArgs} args - Arguments to find a InsurancePolicy
     * @example
     * // Get one InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsurancePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, InsurancePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsurancePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyFindFirstArgs} args - Arguments to find a InsurancePolicy
     * @example
     * // Get one InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsurancePolicyFindFirstArgs>(args?: SelectSubset<T, InsurancePolicyFindFirstArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsurancePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyFindFirstOrThrowArgs} args - Arguments to find a InsurancePolicy
     * @example
     * // Get one InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsurancePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, InsurancePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsurancePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsurancePolicies
     * const insurancePolicies = await prisma.insurancePolicy.findMany()
     * 
     * // Get first 10 InsurancePolicies
     * const insurancePolicies = await prisma.insurancePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insurancePolicyWithIdOnly = await prisma.insurancePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsurancePolicyFindManyArgs>(args?: SelectSubset<T, InsurancePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsurancePolicy.
     * @param {InsurancePolicyCreateArgs} args - Arguments to create a InsurancePolicy.
     * @example
     * // Create one InsurancePolicy
     * const InsurancePolicy = await prisma.insurancePolicy.create({
     *   data: {
     *     // ... data to create a InsurancePolicy
     *   }
     * })
     * 
     */
    create<T extends InsurancePolicyCreateArgs>(args: SelectSubset<T, InsurancePolicyCreateArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsurancePolicies.
     * @param {InsurancePolicyCreateManyArgs} args - Arguments to create many InsurancePolicies.
     * @example
     * // Create many InsurancePolicies
     * const insurancePolicy = await prisma.insurancePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsurancePolicyCreateManyArgs>(args?: SelectSubset<T, InsurancePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsurancePolicies and returns the data saved in the database.
     * @param {InsurancePolicyCreateManyAndReturnArgs} args - Arguments to create many InsurancePolicies.
     * @example
     * // Create many InsurancePolicies
     * const insurancePolicy = await prisma.insurancePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsurancePolicies and only return the `id`
     * const insurancePolicyWithIdOnly = await prisma.insurancePolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsurancePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, InsurancePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsurancePolicy.
     * @param {InsurancePolicyDeleteArgs} args - Arguments to delete one InsurancePolicy.
     * @example
     * // Delete one InsurancePolicy
     * const InsurancePolicy = await prisma.insurancePolicy.delete({
     *   where: {
     *     // ... filter to delete one InsurancePolicy
     *   }
     * })
     * 
     */
    delete<T extends InsurancePolicyDeleteArgs>(args: SelectSubset<T, InsurancePolicyDeleteArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsurancePolicy.
     * @param {InsurancePolicyUpdateArgs} args - Arguments to update one InsurancePolicy.
     * @example
     * // Update one InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsurancePolicyUpdateArgs>(args: SelectSubset<T, InsurancePolicyUpdateArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsurancePolicies.
     * @param {InsurancePolicyDeleteManyArgs} args - Arguments to filter InsurancePolicies to delete.
     * @example
     * // Delete a few InsurancePolicies
     * const { count } = await prisma.insurancePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsurancePolicyDeleteManyArgs>(args?: SelectSubset<T, InsurancePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsurancePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsurancePolicies
     * const insurancePolicy = await prisma.insurancePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsurancePolicyUpdateManyArgs>(args: SelectSubset<T, InsurancePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsurancePolicies and returns the data updated in the database.
     * @param {InsurancePolicyUpdateManyAndReturnArgs} args - Arguments to update many InsurancePolicies.
     * @example
     * // Update many InsurancePolicies
     * const insurancePolicy = await prisma.insurancePolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsurancePolicies and only return the `id`
     * const insurancePolicyWithIdOnly = await prisma.insurancePolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsurancePolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, InsurancePolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsurancePolicy.
     * @param {InsurancePolicyUpsertArgs} args - Arguments to update or create a InsurancePolicy.
     * @example
     * // Update or create a InsurancePolicy
     * const insurancePolicy = await prisma.insurancePolicy.upsert({
     *   create: {
     *     // ... data to create a InsurancePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsurancePolicy we want to update
     *   }
     * })
     */
    upsert<T extends InsurancePolicyUpsertArgs>(args: SelectSubset<T, InsurancePolicyUpsertArgs<ExtArgs>>): Prisma__InsurancePolicyClient<$Result.GetResult<Prisma.$InsurancePolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsurancePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyCountArgs} args - Arguments to filter InsurancePolicies to count.
     * @example
     * // Count the number of InsurancePolicies
     * const count = await prisma.insurancePolicy.count({
     *   where: {
     *     // ... the filter for the InsurancePolicies we want to count
     *   }
     * })
    **/
    count<T extends InsurancePolicyCountArgs>(
      args?: Subset<T, InsurancePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsurancePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsurancePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsurancePolicyAggregateArgs>(args: Subset<T, InsurancePolicyAggregateArgs>): Prisma.PrismaPromise<GetInsurancePolicyAggregateType<T>>

    /**
     * Group by InsurancePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsurancePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsurancePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsurancePolicyGroupByArgs['orderBy'] }
        : { orderBy?: InsurancePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsurancePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsurancePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsurancePolicy model
   */
  readonly fields: InsurancePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsurancePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsurancePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    listing<T extends InsurancePolicy$listingArgs<ExtArgs> = {}>(args?: Subset<T, InsurancePolicy$listingArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsurancePolicy model
   */
  interface InsurancePolicyFieldRefs {
    readonly id: FieldRef<"InsurancePolicy", 'String'>
    readonly userId: FieldRef<"InsurancePolicy", 'String'>
    readonly listingId: FieldRef<"InsurancePolicy", 'String'>
    readonly policyNumber: FieldRef<"InsurancePolicy", 'String'>
    readonly provider: FieldRef<"InsurancePolicy", 'String'>
    readonly type: FieldRef<"InsurancePolicy", 'String'>
    readonly coverageAmount: FieldRef<"InsurancePolicy", 'Int'>
    readonly effectiveDate: FieldRef<"InsurancePolicy", 'DateTime'>
    readonly expirationDate: FieldRef<"InsurancePolicy", 'DateTime'>
    readonly documentUrl: FieldRef<"InsurancePolicy", 'String'>
    readonly certificateUrl: FieldRef<"InsurancePolicy", 'String'>
    readonly status: FieldRef<"InsurancePolicy", 'InsuranceStatus'>
    readonly verificationDate: FieldRef<"InsurancePolicy", 'DateTime'>
    readonly verifiedBy: FieldRef<"InsurancePolicy", 'String'>
    readonly notes: FieldRef<"InsurancePolicy", 'String'>
    readonly metadata: FieldRef<"InsurancePolicy", 'Json'>
    readonly createdAt: FieldRef<"InsurancePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"InsurancePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsurancePolicy findUnique
   */
  export type InsurancePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePolicy to fetch.
     */
    where: InsurancePolicyWhereUniqueInput
  }

  /**
   * InsurancePolicy findUniqueOrThrow
   */
  export type InsurancePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePolicy to fetch.
     */
    where: InsurancePolicyWhereUniqueInput
  }

  /**
   * InsurancePolicy findFirst
   */
  export type InsurancePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePolicy to fetch.
     */
    where?: InsurancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePolicies to fetch.
     */
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurancePolicies.
     */
    cursor?: InsurancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurancePolicies.
     */
    distinct?: InsurancePolicyScalarFieldEnum | InsurancePolicyScalarFieldEnum[]
  }

  /**
   * InsurancePolicy findFirstOrThrow
   */
  export type InsurancePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePolicy to fetch.
     */
    where?: InsurancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePolicies to fetch.
     */
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsurancePolicies.
     */
    cursor?: InsurancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsurancePolicies.
     */
    distinct?: InsurancePolicyScalarFieldEnum | InsurancePolicyScalarFieldEnum[]
  }

  /**
   * InsurancePolicy findMany
   */
  export type InsurancePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter, which InsurancePolicies to fetch.
     */
    where?: InsurancePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsurancePolicies to fetch.
     */
    orderBy?: InsurancePolicyOrderByWithRelationInput | InsurancePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsurancePolicies.
     */
    cursor?: InsurancePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsurancePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsurancePolicies.
     */
    skip?: number
    distinct?: InsurancePolicyScalarFieldEnum | InsurancePolicyScalarFieldEnum[]
  }

  /**
   * InsurancePolicy create
   */
  export type InsurancePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a InsurancePolicy.
     */
    data: XOR<InsurancePolicyCreateInput, InsurancePolicyUncheckedCreateInput>
  }

  /**
   * InsurancePolicy createMany
   */
  export type InsurancePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsurancePolicies.
     */
    data: InsurancePolicyCreateManyInput | InsurancePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsurancePolicy createManyAndReturn
   */
  export type InsurancePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * The data used to create many InsurancePolicies.
     */
    data: InsurancePolicyCreateManyInput | InsurancePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsurancePolicy update
   */
  export type InsurancePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a InsurancePolicy.
     */
    data: XOR<InsurancePolicyUpdateInput, InsurancePolicyUncheckedUpdateInput>
    /**
     * Choose, which InsurancePolicy to update.
     */
    where: InsurancePolicyWhereUniqueInput
  }

  /**
   * InsurancePolicy updateMany
   */
  export type InsurancePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsurancePolicies.
     */
    data: XOR<InsurancePolicyUpdateManyMutationInput, InsurancePolicyUncheckedUpdateManyInput>
    /**
     * Filter which InsurancePolicies to update
     */
    where?: InsurancePolicyWhereInput
    /**
     * Limit how many InsurancePolicies to update.
     */
    limit?: number
  }

  /**
   * InsurancePolicy updateManyAndReturn
   */
  export type InsurancePolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * The data used to update InsurancePolicies.
     */
    data: XOR<InsurancePolicyUpdateManyMutationInput, InsurancePolicyUncheckedUpdateManyInput>
    /**
     * Filter which InsurancePolicies to update
     */
    where?: InsurancePolicyWhereInput
    /**
     * Limit how many InsurancePolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsurancePolicy upsert
   */
  export type InsurancePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the InsurancePolicy to update in case it exists.
     */
    where: InsurancePolicyWhereUniqueInput
    /**
     * In case the InsurancePolicy found by the `where` argument doesn't exist, create a new InsurancePolicy with this data.
     */
    create: XOR<InsurancePolicyCreateInput, InsurancePolicyUncheckedCreateInput>
    /**
     * In case the InsurancePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsurancePolicyUpdateInput, InsurancePolicyUncheckedUpdateInput>
  }

  /**
   * InsurancePolicy delete
   */
  export type InsurancePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
    /**
     * Filter which InsurancePolicy to delete.
     */
    where: InsurancePolicyWhereUniqueInput
  }

  /**
   * InsurancePolicy deleteMany
   */
  export type InsurancePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsurancePolicies to delete
     */
    where?: InsurancePolicyWhereInput
    /**
     * Limit how many InsurancePolicies to delete.
     */
    limit?: number
  }

  /**
   * InsurancePolicy.listing
   */
  export type InsurancePolicy$listingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Listing
     */
    omit?: ListingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
  }

  /**
   * InsurancePolicy without action
   */
  export type InsurancePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsurancePolicy
     */
    select?: InsurancePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsurancePolicy
     */
    omit?: InsurancePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsurancePolicyInclude<ExtArgs> | null
  }


  /**
   * Model DeviceToken
   */

  export type AggregateDeviceToken = {
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  export type DeviceTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    platform: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DeviceTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    platform: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DeviceTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DeviceTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    platform?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceToken to aggregate.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTokens
    **/
    _count?: true | DeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type GetDeviceTokenAggregateType<T extends DeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceToken[P]>
      : GetScalarType<T[P], AggregateDeviceToken[P]>
  }




  export type DeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithAggregationInput | DeviceTokenOrderByWithAggregationInput[]
    by: DeviceTokenScalarFieldEnum[] | DeviceTokenScalarFieldEnum
    having?: DeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTokenCountAggregateInputType | true
    _min?: DeviceTokenMinAggregateInputType
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type DeviceTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    platform: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  type GetDeviceTokenGroupByPayload<T extends DeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    platform?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DeviceTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "platform" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["deviceToken"]>
  export type DeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      platform: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deviceToken"]>
    composites: {}
  }

  type DeviceTokenGetPayload<S extends boolean | null | undefined | DeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$DeviceTokenPayload, S>

  type DeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTokenCountAggregateInputType | true
    }

  export interface DeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceToken'], meta: { name: 'DeviceToken' } }
    /**
     * Find zero or one DeviceToken that matches the filter.
     * @param {DeviceTokenFindUniqueArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTokenFindUniqueArgs>(args: SelectSubset<T, DeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTokenFindFirstArgs>(args?: SelectSubset<T, DeviceTokenFindFirstArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany()
     * 
     * // Get first 10 DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTokenFindManyArgs>(args?: SelectSubset<T, DeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceToken.
     * @param {DeviceTokenCreateArgs} args - Arguments to create a DeviceToken.
     * @example
     * // Create one DeviceToken
     * const DeviceToken = await prisma.deviceToken.create({
     *   data: {
     *     // ... data to create a DeviceToken
     *   }
     * })
     * 
     */
    create<T extends DeviceTokenCreateArgs>(args: SelectSubset<T, DeviceTokenCreateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTokens.
     * @param {DeviceTokenCreateManyArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTokenCreateManyArgs>(args?: SelectSubset<T, DeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTokens and returns the data saved in the database.
     * @param {DeviceTokenCreateManyAndReturnArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceToken.
     * @param {DeviceTokenDeleteArgs} args - Arguments to delete one DeviceToken.
     * @example
     * // Delete one DeviceToken
     * const DeviceToken = await prisma.deviceToken.delete({
     *   where: {
     *     // ... filter to delete one DeviceToken
     *   }
     * })
     * 
     */
    delete<T extends DeviceTokenDeleteArgs>(args: SelectSubset<T, DeviceTokenDeleteArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceToken.
     * @param {DeviceTokenUpdateArgs} args - Arguments to update one DeviceToken.
     * @example
     * // Update one DeviceToken
     * const deviceToken = await prisma.deviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTokenUpdateArgs>(args: SelectSubset<T, DeviceTokenUpdateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTokens.
     * @param {DeviceTokenDeleteManyArgs} args - Arguments to filter DeviceTokens to delete.
     * @example
     * // Delete a few DeviceTokens
     * const { count } = await prisma.deviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTokenDeleteManyArgs>(args?: SelectSubset<T, DeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTokenUpdateManyArgs>(args: SelectSubset<T, DeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens and returns the data updated in the database.
     * @param {DeviceTokenUpdateManyAndReturnArgs} args - Arguments to update many DeviceTokens.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceToken.
     * @param {DeviceTokenUpsertArgs} args - Arguments to update or create a DeviceToken.
     * @example
     * // Update or create a DeviceToken
     * const deviceToken = await prisma.deviceToken.upsert({
     *   create: {
     *     // ... data to create a DeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTokenUpsertArgs>(args: SelectSubset<T, DeviceTokenUpsertArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenCountArgs} args - Arguments to filter DeviceTokens to count.
     * @example
     * // Count the number of DeviceTokens
     * const count = await prisma.deviceToken.count({
     *   where: {
     *     // ... the filter for the DeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends DeviceTokenCountArgs>(
      args?: Subset<T, DeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTokenAggregateArgs>(args: Subset<T, DeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetDeviceTokenAggregateType<T>>

    /**
     * Group by DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceToken model
   */
  readonly fields: DeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceToken model
   */
  interface DeviceTokenFieldRefs {
    readonly id: FieldRef<"DeviceToken", 'String'>
    readonly userId: FieldRef<"DeviceToken", 'String'>
    readonly token: FieldRef<"DeviceToken", 'String'>
    readonly platform: FieldRef<"DeviceToken", 'String'>
    readonly active: FieldRef<"DeviceToken", 'Boolean'>
    readonly createdAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceToken findUnique
   */
  export type DeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findUniqueOrThrow
   */
  export type DeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findFirst
   */
  export type DeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findFirstOrThrow
   */
  export type DeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findMany
   */
  export type DeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTokens to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken create
   */
  export type DeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceToken.
     */
    data: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
  }

  /**
   * DeviceToken createMany
   */
  export type DeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceToken createManyAndReturn
   */
  export type DeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken update
   */
  export type DeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceToken.
     */
    data: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which DeviceToken to update.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken updateMany
   */
  export type DeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
  }

  /**
   * DeviceToken updateManyAndReturn
   */
  export type DeviceTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken upsert
   */
  export type DeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceToken to update in case it exists.
     */
    where: DeviceTokenWhereUniqueInput
    /**
     * In case the DeviceToken found by the `where` argument doesn't exist, create a new DeviceToken with this data.
     */
    create: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
    /**
     * In case the DeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
  }

  /**
   * DeviceToken delete
   */
  export type DeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which DeviceToken to delete.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken deleteMany
   */
  export type DeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTokens to delete
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to delete.
     */
    limit?: number
  }

  /**
   * DeviceToken without action
   */
  export type DeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    preferences: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      preferences: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly preferences: FieldRef<"UserPreferences", 'Json'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    emailVerified: 'emailVerified',
    emailVerificationToken: 'emailVerificationToken',
    passwordHash: 'passwordHash',
    firstName: 'firstName',
    lastName: 'lastName',
    phoneNumber: 'phoneNumber',
    phone: 'phone',
    phoneVerified: 'phoneVerified',
    dateOfBirth: 'dateOfBirth',
    profilePhotoUrl: 'profilePhotoUrl',
    bio: 'bio',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    idVerificationStatus: 'idVerificationStatus',
    idVerificationUrl: 'idVerificationUrl',
    governmentIdUrl: 'governmentIdUrl',
    governmentIdType: 'governmentIdType',
    governmentIdNumber: 'governmentIdNumber',
    stripeCustomerId: 'stripeCustomerId',
    stripeConnectId: 'stripeConnectId',
    stripeOnboardingComplete: 'stripeOnboardingComplete',
    stripeChargesEnabled: 'stripeChargesEnabled',
    stripePayoutsEnabled: 'stripePayoutsEnabled',
    role: 'role',
    status: 'status',
    preferredLanguage: 'preferredLanguage',
    preferredCurrency: 'preferredCurrency',
    timezone: 'timezone',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    lastLoginAt: 'lastLoginAt',
    lastLoginIp: 'lastLoginIp',
    averageRating: 'averageRating',
    totalReviews: 'totalReviews',
    responseRate: 'responseRate',
    responseTime: 'responseTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    logoUrl: 'logoUrl',
    websiteUrl: 'websiteUrl',
    businessType: 'businessType',
    taxId: 'taxId',
    email: 'email',
    phoneNumber: 'phoneNumber',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    stripeConnectId: 'stripeConnectId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const OrganizationMemberScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    invitedBy: 'invitedBy',
    joinedAt: 'joinedAt'
  };

  export type OrganizationMemberScalarFieldEnum = (typeof OrganizationMemberScalarFieldEnum)[keyof typeof OrganizationMemberScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    iconUrl: 'iconUrl',
    order: 'order',
    active: 'active',
    templateSchema: 'templateSchema',
    searchableFields: 'searchableFields',
    requiredFields: 'requiredFields',
    defaultPricingMode: 'defaultPricingMode',
    allowInstantBook: 'allowInstantBook',
    requiresDepositDefault: 'requiresDepositDefault',
    defaultDepositPercentage: 'defaultDepositPercentage',
    insuranceRequired: 'insuranceRequired',
    minimumInsuranceAmount: 'minimumInsuranceAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ListingScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    organizationId: 'organizationId',
    categoryId: 'categoryId',
    title: 'title',
    description: 'description',
    slug: 'slug',
    addressLine1: 'addressLine1',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    photos: 'photos',
    videos: 'videos',
    documents: 'documents',
    pricingMode: 'pricingMode',
    basePrice: 'basePrice',
    hourlyPrice: 'hourlyPrice',
    dailyPrice: 'dailyPrice',
    weeklyPrice: 'weeklyPrice',
    monthlyPrice: 'monthlyPrice',
    currency: 'currency',
    requiresDeposit: 'requiresDeposit',
    depositAmount: 'depositAmount',
    depositType: 'depositType',
    bookingMode: 'bookingMode',
    minBookingHours: 'minBookingHours',
    maxBookingDays: 'maxBookingDays',
    leadTime: 'leadTime',
    advanceNotice: 'advanceNotice',
    capacity: 'capacity',
    categorySpecificData: 'categorySpecificData',
    condition: 'condition',
    features: 'features',
    amenities: 'amenities',
    cancellationPolicyId: 'cancellationPolicyId',
    rules: 'rules',
    insurancePolicyId: 'insurancePolicyId',
    insuranceVerified: 'insuranceVerified',
    insuranceVerifiedAt: 'insuranceVerifiedAt',
    insuranceExpiresAt: 'insuranceExpiresAt',
    status: 'status',
    verificationStatus: 'verificationStatus',
    rejectionReason: 'rejectionReason',
    moderatedBy: 'moderatedBy',
    moderatedAt: 'moderatedAt',
    viewCount: 'viewCount',
    bookingCount: 'bookingCount',
    favoriteCount: 'favoriteCount',
    averageRating: 'averageRating',
    totalReviews: 'totalReviews',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt',
    deletedAt: 'deletedAt'
  };

  export type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]


  export const CancellationPolicyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    description: 'description',
    rules: 'rules',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CancellationPolicyScalarFieldEnum = (typeof CancellationPolicyScalarFieldEnum)[keyof typeof CancellationPolicyScalarFieldEnum]


  export const AvailabilityScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    startDate: 'startDate',
    endDate: 'endDate',
    available: 'available',
    price: 'price',
    minStay: 'minStay',
    createdAt: 'createdAt'
  };

  export type AvailabilityScalarFieldEnum = (typeof AvailabilityScalarFieldEnum)[keyof typeof AvailabilityScalarFieldEnum]


  export const FavoriteListingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    listingId: 'listingId',
    createdAt: 'createdAt'
  };

  export type FavoriteListingScalarFieldEnum = (typeof FavoriteListingScalarFieldEnum)[keyof typeof FavoriteListingScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    renterId: 'renterId',
    ownerId: 'ownerId',
    startDate: 'startDate',
    endDate: 'endDate',
    duration: 'duration',
    guestCount: 'guestCount',
    basePrice: 'basePrice',
    serviceFee: 'serviceFee',
    tax: 'tax',
    depositAmount: 'depositAmount',
    discountAmount: 'discountAmount',
    totalPrice: 'totalPrice',
    totalAmount: 'totalAmount',
    ownerEarnings: 'ownerEarnings',
    platformFee: 'platformFee',
    currency: 'currency',
    renterMessage: 'renterMessage',
    status: 'status',
    cancellationReason: 'cancellationReason',
    cancelledBy: 'cancelledBy',
    cancelledAt: 'cancelledAt',
    paymentIntentId: 'paymentIntentId',
    depositHoldId: 'depositHoldId',
    depositReleased: 'depositReleased',
    depositReleasedAt: 'depositReleasedAt',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    actualReturnTime: 'actualReturnTime',
    categoryData: 'categoryData',
    renterNotes: 'renterNotes',
    ownerNotes: 'ownerNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    confirmedAt: 'confirmedAt',
    completedAt: 'completedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const BookingStateHistoryScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    fromState: 'fromState',
    toState: 'toState',
    reason: 'reason',
    metadata: 'metadata',
    changedBy: 'changedBy',
    createdAt: 'createdAt'
  };

  export type BookingStateHistoryScalarFieldEnum = (typeof BookingStateHistoryScalarFieldEnum)[keyof typeof BookingStateHistoryScalarFieldEnum]


  export const LedgerEntryScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    accountType: 'accountType',
    side: 'side',
    amount: 'amount',
    currency: 'currency',
    transactionType: 'transactionType',
    description: 'description',
    referenceId: 'referenceId',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    settledAt: 'settledAt'
  };

  export type LedgerEntryScalarFieldEnum = (typeof LedgerEntryScalarFieldEnum)[keyof typeof LedgerEntryScalarFieldEnum]


  export const DepositHoldScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    paymentIntentId: 'paymentIntentId',
    status: 'status',
    authorizedAt: 'authorizedAt',
    capturedAt: 'capturedAt',
    releasedAt: 'releasedAt',
    deductedAmount: 'deductedAmount',
    deductionReason: 'deductionReason',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type DepositHoldScalarFieldEnum = (typeof DepositHoldScalarFieldEnum)[keyof typeof DepositHoldScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeChargeId: 'stripeChargeId',
    status: 'status',
    failureReason: 'failureReason',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RefundScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    reason: 'reason',
    refundId: 'refundId',
    status: 'status',
    processedAt: 'processedAt',
    createdAt: 'createdAt'
  };

  export type RefundScalarFieldEnum = (typeof RefundScalarFieldEnum)[keyof typeof RefundScalarFieldEnum]


  export const PayoutScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    amount: 'amount',
    currency: 'currency',
    transferId: 'transferId',
    status: 'status',
    failureReason: 'failureReason',
    createdAt: 'createdAt',
    processedAt: 'processedAt',
    paidAt: 'paidAt'
  };

  export type PayoutScalarFieldEnum = (typeof PayoutScalarFieldEnum)[keyof typeof PayoutScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    listingId: 'listingId',
    reviewerId: 'reviewerId',
    revieweeId: 'revieweeId',
    type: 'type',
    overallRating: 'overallRating',
    accuracyRating: 'accuracyRating',
    communicationRating: 'communicationRating',
    cleanlinessRating: 'cleanlinessRating',
    valueRating: 'valueRating',
    title: 'title',
    content: 'content',
    response: 'response',
    respondedAt: 'respondedAt',
    status: 'status',
    flagged: 'flagged',
    flagReason: 'flagReason',
    moderatedBy: 'moderatedBy',
    moderatedAt: 'moderatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    listingId: 'listingId',
    type: 'type',
    subject: 'subject',
    lastMessageAt: 'lastMessageAt',
    lastMessagePreview: 'lastMessagePreview',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    userId: 'userId',
    muted: 'muted',
    lastReadAt: 'lastReadAt',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    type: 'type',
    content: 'content',
    attachments: 'attachments',
    metadata: 'metadata',
    status: 'status',
    createdAt: 'createdAt',
    editedAt: 'editedAt',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageReadReceiptScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadReceiptScalarFieldEnum = (typeof MessageReadReceiptScalarFieldEnum)[keyof typeof MessageReadReceiptScalarFieldEnum]


  export const ConditionReportScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    reportType: 'reportType',
    type: 'type',
    reportedBy: 'reportedBy',
    reportedAt: 'reportedAt',
    checklistData: 'checklistData',
    overallCondition: 'overallCondition',
    condition: 'condition',
    notes: 'notes',
    damages: 'damages',
    issuesFound: 'issuesFound',
    damageAmount: 'damageAmount',
    acknowledgedBy: 'acknowledgedBy',
    acknowledgedAt: 'acknowledgedAt',
    disputeRaised: 'disputeRaised',
    status: 'status',
    createdAt: 'createdAt',
    completedAt: 'completedAt'
  };

  export type ConditionReportScalarFieldEnum = (typeof ConditionReportScalarFieldEnum)[keyof typeof ConditionReportScalarFieldEnum]


  export const ReportPhotoScalarFieldEnum: {
    id: 'id',
    reportId: 'reportId',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    caption: 'caption',
    tags: 'tags',
    metadata: 'metadata',
    order: 'order',
    uploadedAt: 'uploadedAt'
  };

  export type ReportPhotoScalarFieldEnum = (typeof ReportPhotoScalarFieldEnum)[keyof typeof ReportPhotoScalarFieldEnum]


  export const DisputeScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    conditionReportId: 'conditionReportId',
    initiatorId: 'initiatorId',
    defendantId: 'defendantId',
    type: 'type',
    title: 'title',
    description: 'description',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    priority: 'priority',
    slaDeadline: 'slaDeadline',
    respondedAt: 'respondedAt',
    resolvedAt: 'resolvedAt',
    assignedTo: 'assignedTo',
    assignedAt: 'assignedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DisputeScalarFieldEnum = (typeof DisputeScalarFieldEnum)[keyof typeof DisputeScalarFieldEnum]


  export const DisputeResponseScalarFieldEnum: {
    id: 'id',
    disputeId: 'disputeId',
    userId: 'userId',
    content: 'content',
    attachments: 'attachments',
    createdAt: 'createdAt'
  };

  export type DisputeResponseScalarFieldEnum = (typeof DisputeResponseScalarFieldEnum)[keyof typeof DisputeResponseScalarFieldEnum]


  export const DisputeEvidenceScalarFieldEnum: {
    id: 'id',
    disputeId: 'disputeId',
    uploadedBy: 'uploadedBy',
    type: 'type',
    url: 'url',
    description: 'description',
    metadata: 'metadata',
    uploadedAt: 'uploadedAt'
  };

  export type DisputeEvidenceScalarFieldEnum = (typeof DisputeEvidenceScalarFieldEnum)[keyof typeof DisputeEvidenceScalarFieldEnum]


  export const DisputeTimelineEventScalarFieldEnum: {
    id: 'id',
    disputeId: 'disputeId',
    eventType: 'eventType',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type DisputeTimelineEventScalarFieldEnum = (typeof DisputeTimelineEventScalarFieldEnum)[keyof typeof DisputeTimelineEventScalarFieldEnum]


  export const DisputeResolutionScalarFieldEnum: {
    id: 'id',
    disputeId: 'disputeId',
    outcome: 'outcome',
    summary: 'summary',
    refundAmount: 'refundAmount',
    payoutAdjustment: 'payoutAdjustment',
    actionsTaken: 'actionsTaken',
    resolvedBy: 'resolvedBy',
    resolvedAt: 'resolvedAt'
  };

  export type DisputeResolutionScalarFieldEnum = (typeof DisputeResolutionScalarFieldEnum)[keyof typeof DisputeResolutionScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    relatedId: 'relatedId',
    relatedType: 'relatedType',
    actionUrl: 'actionUrl',
    actionLabel: 'actionLabel',
    read: 'read',
    readAt: 'readAt',
    status: 'status',
    sentViaEmail: 'sentViaEmail',
    sentViaPush: 'sentViaPush',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    metadata: 'metadata',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const InsurancePolicyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    listingId: 'listingId',
    policyNumber: 'policyNumber',
    provider: 'provider',
    type: 'type',
    coverageAmount: 'coverageAmount',
    effectiveDate: 'effectiveDate',
    expirationDate: 'expirationDate',
    documentUrl: 'documentUrl',
    certificateUrl: 'certificateUrl',
    status: 'status',
    verificationDate: 'verificationDate',
    verifiedBy: 'verifiedBy',
    notes: 'notes',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsurancePolicyScalarFieldEnum = (typeof InsurancePolicyScalarFieldEnum)[keyof typeof InsurancePolicyScalarFieldEnum]


  export const DeviceTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    platform: 'platform',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'VerificationStatus'
   */
  export type EnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus'>
    


  /**
   * Reference to a field of type 'VerificationStatus[]'
   */
  export type ListEnumVerificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationStatus[]'>
    


  /**
   * Reference to a field of type 'GovernmentIdType'
   */
  export type EnumGovernmentIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovernmentIdType'>
    


  /**
   * Reference to a field of type 'GovernmentIdType[]'
   */
  export type ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GovernmentIdType[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'OrganizationStatus'
   */
  export type EnumOrganizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationStatus'>
    


  /**
   * Reference to a field of type 'OrganizationStatus[]'
   */
  export type ListEnumOrganizationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrganizationStatus[]'>
    


  /**
   * Reference to a field of type 'OrgRole'
   */
  export type EnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole'>
    


  /**
   * Reference to a field of type 'OrgRole[]'
   */
  export type ListEnumOrgRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrgRole[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'PricingMode'
   */
  export type EnumPricingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingMode'>
    


  /**
   * Reference to a field of type 'PricingMode[]'
   */
  export type ListEnumPricingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingMode[]'>
    


  /**
   * Reference to a field of type 'DepositType'
   */
  export type EnumDepositTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositType'>
    


  /**
   * Reference to a field of type 'DepositType[]'
   */
  export type ListEnumDepositTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositType[]'>
    


  /**
   * Reference to a field of type 'BookingMode'
   */
  export type EnumBookingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingMode'>
    


  /**
   * Reference to a field of type 'BookingMode[]'
   */
  export type ListEnumBookingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingMode[]'>
    


  /**
   * Reference to a field of type 'ListingCondition'
   */
  export type EnumListingConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingCondition'>
    


  /**
   * Reference to a field of type 'ListingCondition[]'
   */
  export type ListEnumListingConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingCondition[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'CancellationPolicyType'
   */
  export type EnumCancellationPolicyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationPolicyType'>
    


  /**
   * Reference to a field of type 'CancellationPolicyType[]'
   */
  export type ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationPolicyType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'LedgerSide'
   */
  export type EnumLedgerSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerSide'>
    


  /**
   * Reference to a field of type 'LedgerSide[]'
   */
  export type ListEnumLedgerSideFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerSide[]'>
    


  /**
   * Reference to a field of type 'LedgerEntryStatus'
   */
  export type EnumLedgerEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryStatus'>
    


  /**
   * Reference to a field of type 'LedgerEntryStatus[]'
   */
  export type ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LedgerEntryStatus[]'>
    


  /**
   * Reference to a field of type 'DepositStatus'
   */
  export type EnumDepositStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositStatus'>
    


  /**
   * Reference to a field of type 'DepositStatus[]'
   */
  export type ListEnumDepositStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepositStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'RefundStatus'
   */
  export type EnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus'>
    


  /**
   * Reference to a field of type 'RefundStatus[]'
   */
  export type ListEnumRefundStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RefundStatus[]'>
    


  /**
   * Reference to a field of type 'PayoutStatus'
   */
  export type EnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus'>
    


  /**
   * Reference to a field of type 'PayoutStatus[]'
   */
  export type ListEnumPayoutStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayoutStatus[]'>
    


  /**
   * Reference to a field of type 'ReviewType'
   */
  export type EnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType'>
    


  /**
   * Reference to a field of type 'ReviewType[]'
   */
  export type ListEnumReviewTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewType[]'>
    


  /**
   * Reference to a field of type 'ReviewStatus'
   */
  export type EnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus'>
    


  /**
   * Reference to a field of type 'ReviewStatus[]'
   */
  export type ListEnumReviewStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewStatus[]'>
    


  /**
   * Reference to a field of type 'ConversationType'
   */
  export type EnumConversationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationType'>
    


  /**
   * Reference to a field of type 'ConversationType[]'
   */
  export type ListEnumConversationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationType[]'>
    


  /**
   * Reference to a field of type 'ConversationStatus'
   */
  export type EnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus'>
    


  /**
   * Reference to a field of type 'ConversationStatus[]'
   */
  export type ListEnumConversationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConversationStatus[]'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'MessageType[]'
   */
  export type ListEnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType[]'>
    


  /**
   * Reference to a field of type 'MessageStatus'
   */
  export type EnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus'>
    


  /**
   * Reference to a field of type 'MessageStatus[]'
   */
  export type ListEnumMessageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageStatus[]'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    


  /**
   * Reference to a field of type 'ReportType[]'
   */
  export type ListEnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    


  /**
   * Reference to a field of type 'DisputeType'
   */
  export type EnumDisputeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeType'>
    


  /**
   * Reference to a field of type 'DisputeType[]'
   */
  export type ListEnumDisputeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeType[]'>
    


  /**
   * Reference to a field of type 'DisputeStatus'
   */
  export type EnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus'>
    


  /**
   * Reference to a field of type 'DisputeStatus[]'
   */
  export type ListEnumDisputeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputeStatus[]'>
    


  /**
   * Reference to a field of type 'DisputePriority'
   */
  export type EnumDisputePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputePriority'>
    


  /**
   * Reference to a field of type 'DisputePriority[]'
   */
  export type ListEnumDisputePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DisputePriority[]'>
    


  /**
   * Reference to a field of type 'EvidenceType'
   */
  export type EnumEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceType'>
    


  /**
   * Reference to a field of type 'EvidenceType[]'
   */
  export type ListEnumEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceType[]'>
    


  /**
   * Reference to a field of type 'ResolutionOutcome'
   */
  export type EnumResolutionOutcomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResolutionOutcome'>
    


  /**
   * Reference to a field of type 'ResolutionOutcome[]'
   */
  export type ListEnumResolutionOutcomeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ResolutionOutcome[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'InsuranceStatus'
   */
  export type EnumInsuranceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceStatus'>
    


  /**
   * Reference to a field of type 'InsuranceStatus[]'
   */
  export type ListEnumInsuranceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsuranceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    addressLine1?: StringNullableFilter<"User"> | string | null
    addressLine2?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    postalCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    idVerificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    idVerificationUrl?: StringNullableFilter<"User"> | string | null
    governmentIdUrl?: StringNullableFilter<"User"> | string | null
    governmentIdType?: EnumGovernmentIdTypeNullableFilter<"User"> | $Enums.GovernmentIdType | null
    governmentIdNumber?: StringNullableFilter<"User"> | string | null
    stripeCustomerId?: StringNullableFilter<"User"> | string | null
    stripeConnectId?: StringNullableFilter<"User"> | string | null
    stripeOnboardingComplete?: BoolFilter<"User"> | boolean
    stripeChargesEnabled?: BoolFilter<"User"> | boolean
    stripePayoutsEnabled?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    preferredLanguage?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    timezone?: StringFilter<"User"> | string
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    averageRating?: FloatFilter<"User"> | number
    totalReviews?: IntFilter<"User"> | number
    responseRate?: FloatFilter<"User"> | number
    responseTime?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    listings?: ListingListRelationFilter
    bookingsAsRenter?: BookingListRelationFilter
    bookingsAsOwner?: BookingListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
    conversationParticipants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    disputesInitiated?: DisputeListRelationFilter
    disputesDefended?: DisputeListRelationFilter
    disputeResponses?: DisputeResponseListRelationFilter
    organizations?: OrganizationMemberListRelationFilter
    favoriteListings?: FavoriteListingListRelationFilter
    notifications?: NotificationListRelationFilter
    insurancePolicies?: InsurancePolicyListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    userPreferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    conditionReportsReported?: ConditionReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    idVerificationStatus?: SortOrder
    idVerificationUrl?: SortOrderInput | SortOrder
    governmentIdUrl?: SortOrderInput | SortOrder
    governmentIdType?: SortOrderInput | SortOrder
    governmentIdNumber?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeConnectId?: SortOrderInput | SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    role?: SortOrder
    status?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    timezone?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
    bookingsAsRenter?: BookingOrderByRelationAggregateInput
    bookingsAsOwner?: BookingOrderByRelationAggregateInput
    reviewsGiven?: ReviewOrderByRelationAggregateInput
    reviewsReceived?: ReviewOrderByRelationAggregateInput
    conversationParticipants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    disputesInitiated?: DisputeOrderByRelationAggregateInput
    disputesDefended?: DisputeOrderByRelationAggregateInput
    disputeResponses?: DisputeResponseOrderByRelationAggregateInput
    organizations?: OrganizationMemberOrderByRelationAggregateInput
    favoriteListings?: FavoriteListingOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    insurancePolicies?: InsurancePolicyOrderByRelationAggregateInput
    deviceTokens?: DeviceTokenOrderByRelationAggregateInput
    userPreferences?: UserPreferencesOrderByWithRelationInput
    conditionReportsReported?: ConditionReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    stripeCustomerId?: string
    stripeConnectId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    emailVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phoneNumber?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    phoneVerified?: BoolFilter<"User"> | boolean
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    bio?: StringNullableFilter<"User"> | string | null
    addressLine1?: StringNullableFilter<"User"> | string | null
    addressLine2?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    postalCode?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    idVerificationStatus?: EnumVerificationStatusFilter<"User"> | $Enums.VerificationStatus
    idVerificationUrl?: StringNullableFilter<"User"> | string | null
    governmentIdUrl?: StringNullableFilter<"User"> | string | null
    governmentIdType?: EnumGovernmentIdTypeNullableFilter<"User"> | $Enums.GovernmentIdType | null
    governmentIdNumber?: StringNullableFilter<"User"> | string | null
    stripeOnboardingComplete?: BoolFilter<"User"> | boolean
    stripeChargesEnabled?: BoolFilter<"User"> | boolean
    stripePayoutsEnabled?: BoolFilter<"User"> | boolean
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    preferredLanguage?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    timezone?: StringFilter<"User"> | string
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableFilter<"User"> | string | null
    averageRating?: FloatFilter<"User"> | number
    totalReviews?: IntFilter<"User"> | number
    responseRate?: FloatFilter<"User"> | number
    responseTime?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    listings?: ListingListRelationFilter
    bookingsAsRenter?: BookingListRelationFilter
    bookingsAsOwner?: BookingListRelationFilter
    reviewsGiven?: ReviewListRelationFilter
    reviewsReceived?: ReviewListRelationFilter
    conversationParticipants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    disputesInitiated?: DisputeListRelationFilter
    disputesDefended?: DisputeListRelationFilter
    disputeResponses?: DisputeResponseListRelationFilter
    organizations?: OrganizationMemberListRelationFilter
    favoriteListings?: FavoriteListingListRelationFilter
    notifications?: NotificationListRelationFilter
    insurancePolicies?: InsurancePolicyListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
    userPreferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    conditionReportsReported?: ConditionReportListRelationFilter
  }, "id" | "email" | "stripeCustomerId" | "stripeConnectId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    phoneVerified?: SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    bio?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    idVerificationStatus?: SortOrder
    idVerificationUrl?: SortOrderInput | SortOrder
    governmentIdUrl?: SortOrderInput | SortOrder
    governmentIdType?: SortOrderInput | SortOrder
    governmentIdNumber?: SortOrderInput | SortOrder
    stripeCustomerId?: SortOrderInput | SortOrder
    stripeConnectId?: SortOrderInput | SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    role?: SortOrder
    status?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    timezone?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    lastLoginIp?: SortOrderInput | SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profilePhotoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    bio?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"User"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    idVerificationStatus?: EnumVerificationStatusWithAggregatesFilter<"User"> | $Enums.VerificationStatus
    idVerificationUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    governmentIdUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    governmentIdType?: EnumGovernmentIdTypeNullableWithAggregatesFilter<"User"> | $Enums.GovernmentIdType | null
    governmentIdNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeCustomerId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeConnectId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeOnboardingComplete?: BoolWithAggregatesFilter<"User"> | boolean
    stripeChargesEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    stripePayoutsEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    preferredLanguage?: StringWithAggregatesFilter<"User"> | string
    preferredCurrency?: StringWithAggregatesFilter<"User"> | string
    timezone?: StringWithAggregatesFilter<"User"> | string
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginIp?: StringNullableWithAggregatesFilter<"User"> | string | null
    averageRating?: FloatWithAggregatesFilter<"User"> | number
    totalReviews?: IntWithAggregatesFilter<"User"> | number
    responseRate?: FloatWithAggregatesFilter<"User"> | number
    responseTime?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    websiteUrl?: StringNullableFilter<"Organization"> | string | null
    businessType?: StringNullableFilter<"Organization"> | string | null
    taxId?: StringNullableFilter<"Organization"> | string | null
    email?: StringFilter<"Organization"> | string
    phoneNumber?: StringNullableFilter<"Organization"> | string | null
    addressLine1?: StringNullableFilter<"Organization"> | string | null
    addressLine2?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    postalCode?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    stripeConnectId?: StringNullableFilter<"Organization"> | string | null
    status?: EnumOrganizationStatusFilter<"Organization"> | $Enums.OrganizationStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    listings?: ListingListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    stripeConnectId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: OrganizationMemberOrderByRelationAggregateInput
    listings?: ListingOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    stripeConnectId?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    description?: StringNullableFilter<"Organization"> | string | null
    logoUrl?: StringNullableFilter<"Organization"> | string | null
    websiteUrl?: StringNullableFilter<"Organization"> | string | null
    businessType?: StringNullableFilter<"Organization"> | string | null
    taxId?: StringNullableFilter<"Organization"> | string | null
    email?: StringFilter<"Organization"> | string
    phoneNumber?: StringNullableFilter<"Organization"> | string | null
    addressLine1?: StringNullableFilter<"Organization"> | string | null
    addressLine2?: StringNullableFilter<"Organization"> | string | null
    city?: StringNullableFilter<"Organization"> | string | null
    state?: StringNullableFilter<"Organization"> | string | null
    postalCode?: StringNullableFilter<"Organization"> | string | null
    country?: StringNullableFilter<"Organization"> | string | null
    status?: EnumOrganizationStatusFilter<"Organization"> | $Enums.OrganizationStatus
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    members?: OrganizationMemberListRelationFilter
    listings?: ListingListRelationFilter
  }, "id" | "slug" | "stripeConnectId">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    websiteUrl?: SortOrderInput | SortOrder
    businessType?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    email?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    stripeConnectId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    description?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    websiteUrl?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    businessType?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    email?: StringWithAggregatesFilter<"Organization"> | string
    phoneNumber?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    addressLine1?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    city?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    state?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    country?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    stripeConnectId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    status?: EnumOrganizationStatusWithAggregatesFilter<"Organization"> | $Enums.OrganizationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type OrganizationMemberWhereInput = {
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    permissions?: JsonFilter<"OrganizationMember">
    invitedBy?: StringNullableFilter<"OrganizationMember"> | string | null
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type OrganizationMemberOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type OrganizationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId_userId?: OrganizationMemberOrganizationIdUserIdCompoundUniqueInput
    AND?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    OR?: OrganizationMemberWhereInput[]
    NOT?: OrganizationMemberWhereInput | OrganizationMemberWhereInput[]
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    permissions?: JsonFilter<"OrganizationMember">
    invitedBy?: StringNullableFilter<"OrganizationMember"> | string | null
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "organizationId_userId">

  export type OrganizationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: OrganizationMemberCountOrderByAggregateInput
    _max?: OrganizationMemberMaxOrderByAggregateInput
    _min?: OrganizationMemberMinOrderByAggregateInput
  }

  export type OrganizationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganizationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganizationMemberScalarWhereWithAggregatesInput | OrganizationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganizationMember"> | string
    organizationId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    userId?: StringWithAggregatesFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleWithAggregatesFilter<"OrganizationMember"> | $Enums.OrgRole
    permissions?: JsonWithAggregatesFilter<"OrganizationMember">
    invitedBy?: StringNullableWithAggregatesFilter<"OrganizationMember"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"OrganizationMember"> | Date | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter<"Category"> | string
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    iconUrl?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    active?: BoolFilter<"Category"> | boolean
    templateSchema?: JsonFilter<"Category">
    searchableFields?: JsonFilter<"Category">
    requiredFields?: JsonFilter<"Category">
    defaultPricingMode?: EnumPricingModeFilter<"Category"> | $Enums.PricingMode
    allowInstantBook?: BoolFilter<"Category"> | boolean
    requiresDepositDefault?: BoolFilter<"Category"> | boolean
    defaultDepositPercentage?: FloatFilter<"Category"> | number
    insuranceRequired?: BoolFilter<"Category"> | boolean
    minimumInsuranceAmount?: FloatNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    listings?: ListingListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    templateSchema?: SortOrder
    searchableFields?: SortOrder
    requiredFields?: SortOrder
    defaultPricingMode?: SortOrder
    allowInstantBook?: SortOrder
    requiresDepositDefault?: SortOrder
    defaultDepositPercentage?: SortOrder
    insuranceRequired?: SortOrder
    minimumInsuranceAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    description?: StringNullableFilter<"Category"> | string | null
    iconUrl?: StringNullableFilter<"Category"> | string | null
    order?: IntFilter<"Category"> | number
    active?: BoolFilter<"Category"> | boolean
    templateSchema?: JsonFilter<"Category">
    searchableFields?: JsonFilter<"Category">
    requiredFields?: JsonFilter<"Category">
    defaultPricingMode?: EnumPricingModeFilter<"Category"> | $Enums.PricingMode
    allowInstantBook?: BoolFilter<"Category"> | boolean
    requiresDepositDefault?: BoolFilter<"Category"> | boolean
    defaultDepositPercentage?: FloatFilter<"Category"> | number
    insuranceRequired?: BoolFilter<"Category"> | boolean
    minimumInsuranceAmount?: FloatNullableFilter<"Category"> | number | null
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    listings?: ListingListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    templateSchema?: SortOrder
    searchableFields?: SortOrder
    requiredFields?: SortOrder
    defaultPricingMode?: SortOrder
    allowInstantBook?: SortOrder
    requiresDepositDefault?: SortOrder
    defaultDepositPercentage?: SortOrder
    insuranceRequired?: SortOrder
    minimumInsuranceAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Category"> | string
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"Category"> | string | null
    order?: IntWithAggregatesFilter<"Category"> | number
    active?: BoolWithAggregatesFilter<"Category"> | boolean
    templateSchema?: JsonWithAggregatesFilter<"Category">
    searchableFields?: JsonWithAggregatesFilter<"Category">
    requiredFields?: JsonWithAggregatesFilter<"Category">
    defaultPricingMode?: EnumPricingModeWithAggregatesFilter<"Category"> | $Enums.PricingMode
    allowInstantBook?: BoolWithAggregatesFilter<"Category"> | boolean
    requiresDepositDefault?: BoolWithAggregatesFilter<"Category"> | boolean
    defaultDepositPercentage?: FloatWithAggregatesFilter<"Category"> | number
    insuranceRequired?: BoolWithAggregatesFilter<"Category"> | boolean
    minimumInsuranceAmount?: FloatNullableWithAggregatesFilter<"Category"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type ListingWhereInput = {
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    id?: StringFilter<"Listing"> | string
    ownerId?: StringFilter<"Listing"> | string
    organizationId?: StringNullableFilter<"Listing"> | string | null
    categoryId?: StringFilter<"Listing"> | string
    title?: StringFilter<"Listing"> | string
    description?: StringFilter<"Listing"> | string
    slug?: StringFilter<"Listing"> | string
    addressLine1?: StringNullableFilter<"Listing"> | string | null
    addressLine2?: StringNullableFilter<"Listing"> | string | null
    city?: StringFilter<"Listing"> | string
    state?: StringFilter<"Listing"> | string
    postalCode?: StringNullableFilter<"Listing"> | string | null
    country?: StringFilter<"Listing"> | string
    latitude?: FloatFilter<"Listing"> | number
    longitude?: FloatFilter<"Listing"> | number
    photos?: JsonFilter<"Listing">
    videos?: JsonFilter<"Listing">
    documents?: JsonFilter<"Listing">
    pricingMode?: EnumPricingModeFilter<"Listing"> | $Enums.PricingMode
    basePrice?: FloatFilter<"Listing"> | number
    hourlyPrice?: FloatNullableFilter<"Listing"> | number | null
    dailyPrice?: FloatNullableFilter<"Listing"> | number | null
    weeklyPrice?: FloatNullableFilter<"Listing"> | number | null
    monthlyPrice?: FloatNullableFilter<"Listing"> | number | null
    currency?: StringFilter<"Listing"> | string
    requiresDeposit?: BoolFilter<"Listing"> | boolean
    depositAmount?: FloatNullableFilter<"Listing"> | number | null
    depositType?: EnumDepositTypeNullableFilter<"Listing"> | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFilter<"Listing"> | $Enums.BookingMode
    minBookingHours?: IntNullableFilter<"Listing"> | number | null
    maxBookingDays?: IntNullableFilter<"Listing"> | number | null
    leadTime?: IntFilter<"Listing"> | number
    advanceNotice?: IntFilter<"Listing"> | number
    capacity?: IntNullableFilter<"Listing"> | number | null
    categorySpecificData?: JsonFilter<"Listing">
    condition?: EnumListingConditionNullableFilter<"Listing"> | $Enums.ListingCondition | null
    features?: JsonFilter<"Listing">
    amenities?: JsonFilter<"Listing">
    cancellationPolicyId?: StringNullableFilter<"Listing"> | string | null
    rules?: JsonFilter<"Listing">
    insurancePolicyId?: StringNullableFilter<"Listing"> | string | null
    insuranceVerified?: BoolFilter<"Listing"> | boolean
    insuranceVerifiedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    insuranceExpiresAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFilter<"Listing"> | $Enums.VerificationStatus
    rejectionReason?: StringNullableFilter<"Listing"> | string | null
    moderatedBy?: StringNullableFilter<"Listing"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    viewCount?: IntFilter<"Listing"> | number
    bookingCount?: IntFilter<"Listing"> | number
    favoriteCount?: IntFilter<"Listing"> | number
    averageRating?: FloatFilter<"Listing"> | number
    totalReviews?: IntFilter<"Listing"> | number
    metaTitle?: StringNullableFilter<"Listing"> | string | null
    metaDescription?: StringNullableFilter<"Listing"> | string | null
    createdAt?: DateTimeFilter<"Listing"> | Date | string
    updatedAt?: DateTimeFilter<"Listing"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    cancellationPolicy?: XOR<CancellationPolicyNullableScalarRelationFilter, CancellationPolicyWhereInput> | null
    availability?: AvailabilityListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    favorites?: FavoriteListingListRelationFilter
    insurancePolicies?: InsurancePolicyListRelationFilter
  }

  export type ListingOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    photos?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    pricingMode?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrderInput | SortOrder
    dailyPrice?: SortOrderInput | SortOrder
    weeklyPrice?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrderInput | SortOrder
    depositType?: SortOrderInput | SortOrder
    bookingMode?: SortOrder
    minBookingHours?: SortOrderInput | SortOrder
    maxBookingDays?: SortOrderInput | SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrderInput | SortOrder
    categorySpecificData?: SortOrder
    condition?: SortOrderInput | SortOrder
    features?: SortOrder
    amenities?: SortOrder
    cancellationPolicyId?: SortOrderInput | SortOrder
    rules?: SortOrder
    insurancePolicyId?: SortOrderInput | SortOrder
    insuranceVerified?: SortOrder
    insuranceVerifiedAt?: SortOrderInput | SortOrder
    insuranceExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    cancellationPolicy?: CancellationPolicyOrderByWithRelationInput
    availability?: AvailabilityOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    favorites?: FavoriteListingOrderByRelationAggregateInput
    insurancePolicies?: InsurancePolicyOrderByRelationAggregateInput
  }

  export type ListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    ownerId?: StringFilter<"Listing"> | string
    organizationId?: StringNullableFilter<"Listing"> | string | null
    categoryId?: StringFilter<"Listing"> | string
    title?: StringFilter<"Listing"> | string
    description?: StringFilter<"Listing"> | string
    addressLine1?: StringNullableFilter<"Listing"> | string | null
    addressLine2?: StringNullableFilter<"Listing"> | string | null
    city?: StringFilter<"Listing"> | string
    state?: StringFilter<"Listing"> | string
    postalCode?: StringNullableFilter<"Listing"> | string | null
    country?: StringFilter<"Listing"> | string
    latitude?: FloatFilter<"Listing"> | number
    longitude?: FloatFilter<"Listing"> | number
    photos?: JsonFilter<"Listing">
    videos?: JsonFilter<"Listing">
    documents?: JsonFilter<"Listing">
    pricingMode?: EnumPricingModeFilter<"Listing"> | $Enums.PricingMode
    basePrice?: FloatFilter<"Listing"> | number
    hourlyPrice?: FloatNullableFilter<"Listing"> | number | null
    dailyPrice?: FloatNullableFilter<"Listing"> | number | null
    weeklyPrice?: FloatNullableFilter<"Listing"> | number | null
    monthlyPrice?: FloatNullableFilter<"Listing"> | number | null
    currency?: StringFilter<"Listing"> | string
    requiresDeposit?: BoolFilter<"Listing"> | boolean
    depositAmount?: FloatNullableFilter<"Listing"> | number | null
    depositType?: EnumDepositTypeNullableFilter<"Listing"> | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFilter<"Listing"> | $Enums.BookingMode
    minBookingHours?: IntNullableFilter<"Listing"> | number | null
    maxBookingDays?: IntNullableFilter<"Listing"> | number | null
    leadTime?: IntFilter<"Listing"> | number
    advanceNotice?: IntFilter<"Listing"> | number
    capacity?: IntNullableFilter<"Listing"> | number | null
    categorySpecificData?: JsonFilter<"Listing">
    condition?: EnumListingConditionNullableFilter<"Listing"> | $Enums.ListingCondition | null
    features?: JsonFilter<"Listing">
    amenities?: JsonFilter<"Listing">
    cancellationPolicyId?: StringNullableFilter<"Listing"> | string | null
    rules?: JsonFilter<"Listing">
    insurancePolicyId?: StringNullableFilter<"Listing"> | string | null
    insuranceVerified?: BoolFilter<"Listing"> | boolean
    insuranceVerifiedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    insuranceExpiresAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFilter<"Listing"> | $Enums.VerificationStatus
    rejectionReason?: StringNullableFilter<"Listing"> | string | null
    moderatedBy?: StringNullableFilter<"Listing"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    viewCount?: IntFilter<"Listing"> | number
    bookingCount?: IntFilter<"Listing"> | number
    favoriteCount?: IntFilter<"Listing"> | number
    averageRating?: FloatFilter<"Listing"> | number
    totalReviews?: IntFilter<"Listing"> | number
    metaTitle?: StringNullableFilter<"Listing"> | string | null
    metaDescription?: StringNullableFilter<"Listing"> | string | null
    createdAt?: DateTimeFilter<"Listing"> | Date | string
    updatedAt?: DateTimeFilter<"Listing"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationNullableScalarRelationFilter, OrganizationWhereInput> | null
    category?: XOR<CategoryScalarRelationFilter, CategoryWhereInput>
    cancellationPolicy?: XOR<CancellationPolicyNullableScalarRelationFilter, CancellationPolicyWhereInput> | null
    availability?: AvailabilityListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    favorites?: FavoriteListingListRelationFilter
    insurancePolicies?: InsurancePolicyListRelationFilter
  }, "id" | "slug">

  export type ListingOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    addressLine1?: SortOrderInput | SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    photos?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    pricingMode?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrderInput | SortOrder
    dailyPrice?: SortOrderInput | SortOrder
    weeklyPrice?: SortOrderInput | SortOrder
    monthlyPrice?: SortOrderInput | SortOrder
    currency?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrderInput | SortOrder
    depositType?: SortOrderInput | SortOrder
    bookingMode?: SortOrder
    minBookingHours?: SortOrderInput | SortOrder
    maxBookingDays?: SortOrderInput | SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrderInput | SortOrder
    categorySpecificData?: SortOrder
    condition?: SortOrderInput | SortOrder
    features?: SortOrder
    amenities?: SortOrder
    cancellationPolicyId?: SortOrderInput | SortOrder
    rules?: SortOrder
    insurancePolicyId?: SortOrderInput | SortOrder
    insuranceVerified?: SortOrder
    insuranceVerifiedAt?: SortOrderInput | SortOrder
    insuranceExpiresAt?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    metaTitle?: SortOrderInput | SortOrder
    metaDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ListingCountOrderByAggregateInput
    _avg?: ListingAvgOrderByAggregateInput
    _max?: ListingMaxOrderByAggregateInput
    _min?: ListingMinOrderByAggregateInput
    _sum?: ListingSumOrderByAggregateInput
  }

  export type ListingScalarWhereWithAggregatesInput = {
    AND?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    OR?: ListingScalarWhereWithAggregatesInput[]
    NOT?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Listing"> | string
    ownerId?: StringWithAggregatesFilter<"Listing"> | string
    organizationId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    categoryId?: StringWithAggregatesFilter<"Listing"> | string
    title?: StringWithAggregatesFilter<"Listing"> | string
    description?: StringWithAggregatesFilter<"Listing"> | string
    slug?: StringWithAggregatesFilter<"Listing"> | string
    addressLine1?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    addressLine2?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    city?: StringWithAggregatesFilter<"Listing"> | string
    state?: StringWithAggregatesFilter<"Listing"> | string
    postalCode?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    country?: StringWithAggregatesFilter<"Listing"> | string
    latitude?: FloatWithAggregatesFilter<"Listing"> | number
    longitude?: FloatWithAggregatesFilter<"Listing"> | number
    photos?: JsonWithAggregatesFilter<"Listing">
    videos?: JsonWithAggregatesFilter<"Listing">
    documents?: JsonWithAggregatesFilter<"Listing">
    pricingMode?: EnumPricingModeWithAggregatesFilter<"Listing"> | $Enums.PricingMode
    basePrice?: FloatWithAggregatesFilter<"Listing"> | number
    hourlyPrice?: FloatNullableWithAggregatesFilter<"Listing"> | number | null
    dailyPrice?: FloatNullableWithAggregatesFilter<"Listing"> | number | null
    weeklyPrice?: FloatNullableWithAggregatesFilter<"Listing"> | number | null
    monthlyPrice?: FloatNullableWithAggregatesFilter<"Listing"> | number | null
    currency?: StringWithAggregatesFilter<"Listing"> | string
    requiresDeposit?: BoolWithAggregatesFilter<"Listing"> | boolean
    depositAmount?: FloatNullableWithAggregatesFilter<"Listing"> | number | null
    depositType?: EnumDepositTypeNullableWithAggregatesFilter<"Listing"> | $Enums.DepositType | null
    bookingMode?: EnumBookingModeWithAggregatesFilter<"Listing"> | $Enums.BookingMode
    minBookingHours?: IntNullableWithAggregatesFilter<"Listing"> | number | null
    maxBookingDays?: IntNullableWithAggregatesFilter<"Listing"> | number | null
    leadTime?: IntWithAggregatesFilter<"Listing"> | number
    advanceNotice?: IntWithAggregatesFilter<"Listing"> | number
    capacity?: IntNullableWithAggregatesFilter<"Listing"> | number | null
    categorySpecificData?: JsonWithAggregatesFilter<"Listing">
    condition?: EnumListingConditionNullableWithAggregatesFilter<"Listing"> | $Enums.ListingCondition | null
    features?: JsonWithAggregatesFilter<"Listing">
    amenities?: JsonWithAggregatesFilter<"Listing">
    cancellationPolicyId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    rules?: JsonWithAggregatesFilter<"Listing">
    insurancePolicyId?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    insuranceVerified?: BoolWithAggregatesFilter<"Listing"> | boolean
    insuranceVerifiedAt?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    insuranceExpiresAt?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    status?: EnumListingStatusWithAggregatesFilter<"Listing"> | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusWithAggregatesFilter<"Listing"> | $Enums.VerificationStatus
    rejectionReason?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    moderatedBy?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"Listing"> | number
    bookingCount?: IntWithAggregatesFilter<"Listing"> | number
    favoriteCount?: IntWithAggregatesFilter<"Listing"> | number
    averageRating?: FloatWithAggregatesFilter<"Listing"> | number
    totalReviews?: IntWithAggregatesFilter<"Listing"> | number
    metaTitle?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Listing"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Listing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Listing"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Listing"> | Date | string | null
  }

  export type CancellationPolicyWhereInput = {
    AND?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    OR?: CancellationPolicyWhereInput[]
    NOT?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    id?: StringFilter<"CancellationPolicy"> | string
    name?: StringFilter<"CancellationPolicy"> | string
    type?: EnumCancellationPolicyTypeFilter<"CancellationPolicy"> | $Enums.CancellationPolicyType
    description?: StringFilter<"CancellationPolicy"> | string
    rules?: JsonFilter<"CancellationPolicy">
    createdAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    listings?: ListingListRelationFilter
  }

  export type CancellationPolicyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
  }

  export type CancellationPolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    OR?: CancellationPolicyWhereInput[]
    NOT?: CancellationPolicyWhereInput | CancellationPolicyWhereInput[]
    name?: StringFilter<"CancellationPolicy"> | string
    type?: EnumCancellationPolicyTypeFilter<"CancellationPolicy"> | $Enums.CancellationPolicyType
    description?: StringFilter<"CancellationPolicy"> | string
    rules?: JsonFilter<"CancellationPolicy">
    createdAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeFilter<"CancellationPolicy"> | Date | string
    listings?: ListingListRelationFilter
  }, "id">

  export type CancellationPolicyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CancellationPolicyCountOrderByAggregateInput
    _max?: CancellationPolicyMaxOrderByAggregateInput
    _min?: CancellationPolicyMinOrderByAggregateInput
  }

  export type CancellationPolicyScalarWhereWithAggregatesInput = {
    AND?: CancellationPolicyScalarWhereWithAggregatesInput | CancellationPolicyScalarWhereWithAggregatesInput[]
    OR?: CancellationPolicyScalarWhereWithAggregatesInput[]
    NOT?: CancellationPolicyScalarWhereWithAggregatesInput | CancellationPolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CancellationPolicy"> | string
    name?: StringWithAggregatesFilter<"CancellationPolicy"> | string
    type?: EnumCancellationPolicyTypeWithAggregatesFilter<"CancellationPolicy"> | $Enums.CancellationPolicyType
    description?: StringWithAggregatesFilter<"CancellationPolicy"> | string
    rules?: JsonWithAggregatesFilter<"CancellationPolicy">
    createdAt?: DateTimeWithAggregatesFilter<"CancellationPolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CancellationPolicy"> | Date | string
  }

  export type AvailabilityWhereInput = {
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    id?: StringFilter<"Availability"> | string
    listingId?: StringFilter<"Availability"> | string
    startDate?: DateTimeFilter<"Availability"> | Date | string
    endDate?: DateTimeFilter<"Availability"> | Date | string
    available?: BoolFilter<"Availability"> | boolean
    price?: FloatNullableFilter<"Availability"> | number | null
    minStay?: IntNullableFilter<"Availability"> | number | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
  }

  export type AvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    available?: SortOrder
    price?: SortOrderInput | SortOrder
    minStay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    listing?: ListingOrderByWithRelationInput
  }

  export type AvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AvailabilityWhereInput | AvailabilityWhereInput[]
    OR?: AvailabilityWhereInput[]
    NOT?: AvailabilityWhereInput | AvailabilityWhereInput[]
    listingId?: StringFilter<"Availability"> | string
    startDate?: DateTimeFilter<"Availability"> | Date | string
    endDate?: DateTimeFilter<"Availability"> | Date | string
    available?: BoolFilter<"Availability"> | boolean
    price?: FloatNullableFilter<"Availability"> | number | null
    minStay?: IntNullableFilter<"Availability"> | number | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
  }, "id">

  export type AvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    available?: SortOrder
    price?: SortOrderInput | SortOrder
    minStay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AvailabilityCountOrderByAggregateInput
    _avg?: AvailabilityAvgOrderByAggregateInput
    _max?: AvailabilityMaxOrderByAggregateInput
    _min?: AvailabilityMinOrderByAggregateInput
    _sum?: AvailabilitySumOrderByAggregateInput
  }

  export type AvailabilityScalarWhereWithAggregatesInput = {
    AND?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    OR?: AvailabilityScalarWhereWithAggregatesInput[]
    NOT?: AvailabilityScalarWhereWithAggregatesInput | AvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Availability"> | string
    listingId?: StringWithAggregatesFilter<"Availability"> | string
    startDate?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
    available?: BoolWithAggregatesFilter<"Availability"> | boolean
    price?: FloatNullableWithAggregatesFilter<"Availability"> | number | null
    minStay?: IntNullableWithAggregatesFilter<"Availability"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Availability"> | Date | string
  }

  export type FavoriteListingWhereInput = {
    AND?: FavoriteListingWhereInput | FavoriteListingWhereInput[]
    OR?: FavoriteListingWhereInput[]
    NOT?: FavoriteListingWhereInput | FavoriteListingWhereInput[]
    id?: StringFilter<"FavoriteListing"> | string
    userId?: StringFilter<"FavoriteListing"> | string
    listingId?: StringFilter<"FavoriteListing"> | string
    createdAt?: DateTimeFilter<"FavoriteListing"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
  }

  export type FavoriteListingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
  }

  export type FavoriteListingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_listingId?: FavoriteListingUserIdListingIdCompoundUniqueInput
    AND?: FavoriteListingWhereInput | FavoriteListingWhereInput[]
    OR?: FavoriteListingWhereInput[]
    NOT?: FavoriteListingWhereInput | FavoriteListingWhereInput[]
    userId?: StringFilter<"FavoriteListing"> | string
    listingId?: StringFilter<"FavoriteListing"> | string
    createdAt?: DateTimeFilter<"FavoriteListing"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
  }, "id" | "userId_listingId">

  export type FavoriteListingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteListingCountOrderByAggregateInput
    _max?: FavoriteListingMaxOrderByAggregateInput
    _min?: FavoriteListingMinOrderByAggregateInput
  }

  export type FavoriteListingScalarWhereWithAggregatesInput = {
    AND?: FavoriteListingScalarWhereWithAggregatesInput | FavoriteListingScalarWhereWithAggregatesInput[]
    OR?: FavoriteListingScalarWhereWithAggregatesInput[]
    NOT?: FavoriteListingScalarWhereWithAggregatesInput | FavoriteListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FavoriteListing"> | string
    userId?: StringWithAggregatesFilter<"FavoriteListing"> | string
    listingId?: StringWithAggregatesFilter<"FavoriteListing"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FavoriteListing"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    listingId?: StringFilter<"Booking"> | string
    renterId?: StringFilter<"Booking"> | string
    ownerId?: StringFilter<"Booking"> | string
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    guestCount?: IntFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    serviceFee?: FloatFilter<"Booking"> | number
    tax?: FloatFilter<"Booking"> | number
    depositAmount?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    ownerEarnings?: FloatFilter<"Booking"> | number
    platformFee?: FloatFilter<"Booking"> | number
    currency?: StringFilter<"Booking"> | string
    renterMessage?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancelledBy?: StringNullableFilter<"Booking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentIntentId?: StringNullableFilter<"Booking"> | string | null
    depositHoldId?: StringNullableFilter<"Booking"> | string | null
    depositReleased?: BoolFilter<"Booking"> | boolean
    depositReleasedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkInTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    categoryData?: JsonFilter<"Booking">
    renterNotes?: StringNullableFilter<"Booking"> | string | null
    ownerNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
    renter?: XOR<UserScalarRelationFilter, UserWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    stateHistory?: BookingStateHistoryListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    depositHold?: XOR<DepositHoldNullableScalarRelationFilter, DepositHoldWhereInput> | null
    payments?: PaymentListRelationFilter
    conditionReports?: ConditionReportListRelationFilter
    reviews?: ReviewListRelationFilter
    disputes?: DisputeListRelationFilter
    conversations?: ConversationListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    renterId?: SortOrder
    ownerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
    currency?: SortOrder
    renterMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    depositHoldId?: SortOrderInput | SortOrder
    depositReleased?: SortOrder
    depositReleasedAt?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    actualReturnTime?: SortOrderInput | SortOrder
    categoryData?: SortOrder
    renterNotes?: SortOrderInput | SortOrder
    ownerNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    listing?: ListingOrderByWithRelationInput
    renter?: UserOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    stateHistory?: BookingStateHistoryOrderByRelationAggregateInput
    ledgerEntries?: LedgerEntryOrderByRelationAggregateInput
    depositHold?: DepositHoldOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    conditionReports?: ConditionReportOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    disputes?: DisputeOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    listingId?: StringFilter<"Booking"> | string
    renterId?: StringFilter<"Booking"> | string
    ownerId?: StringFilter<"Booking"> | string
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    guestCount?: IntFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    serviceFee?: FloatFilter<"Booking"> | number
    tax?: FloatFilter<"Booking"> | number
    depositAmount?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    ownerEarnings?: FloatFilter<"Booking"> | number
    platformFee?: FloatFilter<"Booking"> | number
    currency?: StringFilter<"Booking"> | string
    renterMessage?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancelledBy?: StringNullableFilter<"Booking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentIntentId?: StringNullableFilter<"Booking"> | string | null
    depositHoldId?: StringNullableFilter<"Booking"> | string | null
    depositReleased?: BoolFilter<"Booking"> | boolean
    depositReleasedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkInTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    categoryData?: JsonFilter<"Booking">
    renterNotes?: StringNullableFilter<"Booking"> | string | null
    ownerNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
    renter?: XOR<UserScalarRelationFilter, UserWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    stateHistory?: BookingStateHistoryListRelationFilter
    ledgerEntries?: LedgerEntryListRelationFilter
    depositHold?: XOR<DepositHoldNullableScalarRelationFilter, DepositHoldWhereInput> | null
    payments?: PaymentListRelationFilter
    conditionReports?: ConditionReportListRelationFilter
    reviews?: ReviewListRelationFilter
    disputes?: DisputeListRelationFilter
    conversations?: ConversationListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    renterId?: SortOrder
    ownerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
    currency?: SortOrder
    renterMessage?: SortOrderInput | SortOrder
    status?: SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    cancelledBy?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    paymentIntentId?: SortOrderInput | SortOrder
    depositHoldId?: SortOrderInput | SortOrder
    depositReleased?: SortOrder
    depositReleasedAt?: SortOrderInput | SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    actualReturnTime?: SortOrderInput | SortOrder
    categoryData?: SortOrder
    renterNotes?: SortOrderInput | SortOrder
    ownerNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    listingId?: StringWithAggregatesFilter<"Booking"> | string
    renterId?: StringWithAggregatesFilter<"Booking"> | string
    ownerId?: StringWithAggregatesFilter<"Booking"> | string
    startDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    duration?: IntWithAggregatesFilter<"Booking"> | number
    guestCount?: IntWithAggregatesFilter<"Booking"> | number
    basePrice?: FloatWithAggregatesFilter<"Booking"> | number
    serviceFee?: FloatWithAggregatesFilter<"Booking"> | number
    tax?: FloatWithAggregatesFilter<"Booking"> | number
    depositAmount?: FloatWithAggregatesFilter<"Booking"> | number
    discountAmount?: FloatWithAggregatesFilter<"Booking"> | number
    totalPrice?: FloatWithAggregatesFilter<"Booking"> | number
    totalAmount?: FloatWithAggregatesFilter<"Booking"> | number
    ownerEarnings?: FloatWithAggregatesFilter<"Booking"> | number
    platformFee?: FloatWithAggregatesFilter<"Booking"> | number
    currency?: StringWithAggregatesFilter<"Booking"> | string
    renterMessage?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    cancellationReason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    cancelledBy?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    paymentIntentId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    depositHoldId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    depositReleased?: BoolWithAggregatesFilter<"Booking"> | boolean
    depositReleasedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    checkInTime?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    checkOutTime?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    actualReturnTime?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    categoryData?: JsonWithAggregatesFilter<"Booking">
    renterNotes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    ownerNotes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    confirmedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
  }

  export type BookingStateHistoryWhereInput = {
    AND?: BookingStateHistoryWhereInput | BookingStateHistoryWhereInput[]
    OR?: BookingStateHistoryWhereInput[]
    NOT?: BookingStateHistoryWhereInput | BookingStateHistoryWhereInput[]
    id?: StringFilter<"BookingStateHistory"> | string
    bookingId?: StringFilter<"BookingStateHistory"> | string
    fromState?: EnumBookingStatusNullableFilter<"BookingStateHistory"> | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFilter<"BookingStateHistory"> | $Enums.BookingStatus
    reason?: StringNullableFilter<"BookingStateHistory"> | string | null
    metadata?: JsonFilter<"BookingStateHistory">
    changedBy?: StringNullableFilter<"BookingStateHistory"> | string | null
    createdAt?: DateTimeFilter<"BookingStateHistory"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type BookingStateHistoryOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fromState?: SortOrderInput | SortOrder
    toState?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type BookingStateHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingStateHistoryWhereInput | BookingStateHistoryWhereInput[]
    OR?: BookingStateHistoryWhereInput[]
    NOT?: BookingStateHistoryWhereInput | BookingStateHistoryWhereInput[]
    bookingId?: StringFilter<"BookingStateHistory"> | string
    fromState?: EnumBookingStatusNullableFilter<"BookingStateHistory"> | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFilter<"BookingStateHistory"> | $Enums.BookingStatus
    reason?: StringNullableFilter<"BookingStateHistory"> | string | null
    metadata?: JsonFilter<"BookingStateHistory">
    changedBy?: StringNullableFilter<"BookingStateHistory"> | string | null
    createdAt?: DateTimeFilter<"BookingStateHistory"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type BookingStateHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fromState?: SortOrderInput | SortOrder
    toState?: SortOrder
    reason?: SortOrderInput | SortOrder
    metadata?: SortOrder
    changedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BookingStateHistoryCountOrderByAggregateInput
    _max?: BookingStateHistoryMaxOrderByAggregateInput
    _min?: BookingStateHistoryMinOrderByAggregateInput
  }

  export type BookingStateHistoryScalarWhereWithAggregatesInput = {
    AND?: BookingStateHistoryScalarWhereWithAggregatesInput | BookingStateHistoryScalarWhereWithAggregatesInput[]
    OR?: BookingStateHistoryScalarWhereWithAggregatesInput[]
    NOT?: BookingStateHistoryScalarWhereWithAggregatesInput | BookingStateHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BookingStateHistory"> | string
    bookingId?: StringWithAggregatesFilter<"BookingStateHistory"> | string
    fromState?: EnumBookingStatusNullableWithAggregatesFilter<"BookingStateHistory"> | $Enums.BookingStatus | null
    toState?: EnumBookingStatusWithAggregatesFilter<"BookingStateHistory"> | $Enums.BookingStatus
    reason?: StringNullableWithAggregatesFilter<"BookingStateHistory"> | string | null
    metadata?: JsonWithAggregatesFilter<"BookingStateHistory">
    changedBy?: StringNullableWithAggregatesFilter<"BookingStateHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BookingStateHistory"> | Date | string
  }

  export type LedgerEntryWhereInput = {
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    bookingId?: StringFilter<"LedgerEntry"> | string
    accountType?: StringFilter<"LedgerEntry"> | string
    side?: EnumLedgerSideFilter<"LedgerEntry"> | $Enums.LedgerSide
    amount?: FloatFilter<"LedgerEntry"> | number
    currency?: StringFilter<"LedgerEntry"> | string
    transactionType?: StringFilter<"LedgerEntry"> | string
    description?: StringFilter<"LedgerEntry"> | string
    referenceId?: StringNullableFilter<"LedgerEntry"> | string | null
    status?: EnumLedgerEntryStatusFilter<"LedgerEntry"> | $Enums.LedgerEntryStatus
    metadata?: JsonFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    settledAt?: DateTimeNullableFilter<"LedgerEntry"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type LedgerEntryOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    accountType?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type LedgerEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    OR?: LedgerEntryWhereInput[]
    NOT?: LedgerEntryWhereInput | LedgerEntryWhereInput[]
    bookingId?: StringFilter<"LedgerEntry"> | string
    accountType?: StringFilter<"LedgerEntry"> | string
    side?: EnumLedgerSideFilter<"LedgerEntry"> | $Enums.LedgerSide
    amount?: FloatFilter<"LedgerEntry"> | number
    currency?: StringFilter<"LedgerEntry"> | string
    transactionType?: StringFilter<"LedgerEntry"> | string
    description?: StringFilter<"LedgerEntry"> | string
    referenceId?: StringNullableFilter<"LedgerEntry"> | string | null
    status?: EnumLedgerEntryStatusFilter<"LedgerEntry"> | $Enums.LedgerEntryStatus
    metadata?: JsonFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    settledAt?: DateTimeNullableFilter<"LedgerEntry"> | Date | string | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type LedgerEntryOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    accountType?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    referenceId?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrderInput | SortOrder
    _count?: LedgerEntryCountOrderByAggregateInput
    _avg?: LedgerEntryAvgOrderByAggregateInput
    _max?: LedgerEntryMaxOrderByAggregateInput
    _min?: LedgerEntryMinOrderByAggregateInput
    _sum?: LedgerEntrySumOrderByAggregateInput
  }

  export type LedgerEntryScalarWhereWithAggregatesInput = {
    AND?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    OR?: LedgerEntryScalarWhereWithAggregatesInput[]
    NOT?: LedgerEntryScalarWhereWithAggregatesInput | LedgerEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LedgerEntry"> | string
    bookingId?: StringWithAggregatesFilter<"LedgerEntry"> | string
    accountType?: StringWithAggregatesFilter<"LedgerEntry"> | string
    side?: EnumLedgerSideWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerSide
    amount?: FloatWithAggregatesFilter<"LedgerEntry"> | number
    currency?: StringWithAggregatesFilter<"LedgerEntry"> | string
    transactionType?: StringWithAggregatesFilter<"LedgerEntry"> | string
    description?: StringWithAggregatesFilter<"LedgerEntry"> | string
    referenceId?: StringNullableWithAggregatesFilter<"LedgerEntry"> | string | null
    status?: EnumLedgerEntryStatusWithAggregatesFilter<"LedgerEntry"> | $Enums.LedgerEntryStatus
    metadata?: JsonWithAggregatesFilter<"LedgerEntry">
    createdAt?: DateTimeWithAggregatesFilter<"LedgerEntry"> | Date | string
    settledAt?: DateTimeNullableWithAggregatesFilter<"LedgerEntry"> | Date | string | null
  }

  export type DepositHoldWhereInput = {
    AND?: DepositHoldWhereInput | DepositHoldWhereInput[]
    OR?: DepositHoldWhereInput[]
    NOT?: DepositHoldWhereInput | DepositHoldWhereInput[]
    id?: StringFilter<"DepositHold"> | string
    bookingId?: StringNullableFilter<"DepositHold"> | string | null
    amount?: FloatFilter<"DepositHold"> | number
    currency?: StringFilter<"DepositHold"> | string
    paymentIntentId?: StringFilter<"DepositHold"> | string
    status?: EnumDepositStatusFilter<"DepositHold"> | $Enums.DepositStatus
    authorizedAt?: DateTimeFilter<"DepositHold"> | Date | string
    capturedAt?: DateTimeNullableFilter<"DepositHold"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DepositHold"> | Date | string | null
    deductedAmount?: FloatFilter<"DepositHold"> | number
    deductionReason?: StringNullableFilter<"DepositHold"> | string | null
    createdAt?: DateTimeFilter<"DepositHold"> | Date | string
    expiresAt?: DateTimeFilter<"DepositHold"> | Date | string
    bookings?: BookingListRelationFilter
  }

  export type DepositHoldOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentIntentId?: SortOrder
    status?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    deductedAmount?: SortOrder
    deductionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type DepositHoldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    paymentIntentId?: string
    AND?: DepositHoldWhereInput | DepositHoldWhereInput[]
    OR?: DepositHoldWhereInput[]
    NOT?: DepositHoldWhereInput | DepositHoldWhereInput[]
    bookingId?: StringNullableFilter<"DepositHold"> | string | null
    amount?: FloatFilter<"DepositHold"> | number
    currency?: StringFilter<"DepositHold"> | string
    status?: EnumDepositStatusFilter<"DepositHold"> | $Enums.DepositStatus
    authorizedAt?: DateTimeFilter<"DepositHold"> | Date | string
    capturedAt?: DateTimeNullableFilter<"DepositHold"> | Date | string | null
    releasedAt?: DateTimeNullableFilter<"DepositHold"> | Date | string | null
    deductedAmount?: FloatFilter<"DepositHold"> | number
    deductionReason?: StringNullableFilter<"DepositHold"> | string | null
    createdAt?: DateTimeFilter<"DepositHold"> | Date | string
    expiresAt?: DateTimeFilter<"DepositHold"> | Date | string
    bookings?: BookingListRelationFilter
  }, "id" | "paymentIntentId">

  export type DepositHoldOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentIntentId?: SortOrder
    status?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrderInput | SortOrder
    releasedAt?: SortOrderInput | SortOrder
    deductedAmount?: SortOrder
    deductionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: DepositHoldCountOrderByAggregateInput
    _avg?: DepositHoldAvgOrderByAggregateInput
    _max?: DepositHoldMaxOrderByAggregateInput
    _min?: DepositHoldMinOrderByAggregateInput
    _sum?: DepositHoldSumOrderByAggregateInput
  }

  export type DepositHoldScalarWhereWithAggregatesInput = {
    AND?: DepositHoldScalarWhereWithAggregatesInput | DepositHoldScalarWhereWithAggregatesInput[]
    OR?: DepositHoldScalarWhereWithAggregatesInput[]
    NOT?: DepositHoldScalarWhereWithAggregatesInput | DepositHoldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DepositHold"> | string
    bookingId?: StringNullableWithAggregatesFilter<"DepositHold"> | string | null
    amount?: FloatWithAggregatesFilter<"DepositHold"> | number
    currency?: StringWithAggregatesFilter<"DepositHold"> | string
    paymentIntentId?: StringWithAggregatesFilter<"DepositHold"> | string
    status?: EnumDepositStatusWithAggregatesFilter<"DepositHold"> | $Enums.DepositStatus
    authorizedAt?: DateTimeWithAggregatesFilter<"DepositHold"> | Date | string
    capturedAt?: DateTimeNullableWithAggregatesFilter<"DepositHold"> | Date | string | null
    releasedAt?: DateTimeNullableWithAggregatesFilter<"DepositHold"> | Date | string | null
    deductedAmount?: FloatWithAggregatesFilter<"DepositHold"> | number
    deductionReason?: StringNullableWithAggregatesFilter<"DepositHold"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DepositHold"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"DepositHold"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    failureReason?: StringNullableFilter<"Payment"> | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    stripePaymentIntentId?: string
    stripeChargeId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    failureReason?: StringNullableFilter<"Payment"> | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id" | "stripePaymentIntentId" | "stripeChargeId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    failureReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RefundWhereInput = {
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    id?: StringFilter<"Refund"> | string
    bookingId?: StringFilter<"Refund"> | string
    amount?: FloatFilter<"Refund"> | number
    currency?: StringFilter<"Refund"> | string
    reason?: StringFilter<"Refund"> | string
    refundId?: StringFilter<"Refund"> | string
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeFilter<"Refund"> | Date | string
  }

  export type RefundOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    refundId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type RefundWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    refundId?: string
    AND?: RefundWhereInput | RefundWhereInput[]
    OR?: RefundWhereInput[]
    NOT?: RefundWhereInput | RefundWhereInput[]
    bookingId?: StringFilter<"Refund"> | string
    amount?: FloatFilter<"Refund"> | number
    currency?: StringFilter<"Refund"> | string
    reason?: StringFilter<"Refund"> | string
    status?: EnumRefundStatusFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeFilter<"Refund"> | Date | string
  }, "id" | "refundId">

  export type RefundOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    refundId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RefundCountOrderByAggregateInput
    _avg?: RefundAvgOrderByAggregateInput
    _max?: RefundMaxOrderByAggregateInput
    _min?: RefundMinOrderByAggregateInput
    _sum?: RefundSumOrderByAggregateInput
  }

  export type RefundScalarWhereWithAggregatesInput = {
    AND?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    OR?: RefundScalarWhereWithAggregatesInput[]
    NOT?: RefundScalarWhereWithAggregatesInput | RefundScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Refund"> | string
    bookingId?: StringWithAggregatesFilter<"Refund"> | string
    amount?: FloatWithAggregatesFilter<"Refund"> | number
    currency?: StringWithAggregatesFilter<"Refund"> | string
    reason?: StringWithAggregatesFilter<"Refund"> | string
    refundId?: StringWithAggregatesFilter<"Refund"> | string
    status?: EnumRefundStatusWithAggregatesFilter<"Refund"> | $Enums.RefundStatus
    processedAt?: DateTimeNullableWithAggregatesFilter<"Refund"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Refund"> | Date | string
  }

  export type PayoutWhereInput = {
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    id?: StringFilter<"Payout"> | string
    ownerId?: StringFilter<"Payout"> | string
    amount?: FloatFilter<"Payout"> | number
    currency?: StringFilter<"Payout"> | string
    transferId?: StringNullableFilter<"Payout"> | string | null
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    failureReason?: StringNullableFilter<"Payout"> | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
  }

  export type PayoutOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transferId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
  }

  export type PayoutWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transferId?: string
    AND?: PayoutWhereInput | PayoutWhereInput[]
    OR?: PayoutWhereInput[]
    NOT?: PayoutWhereInput | PayoutWhereInput[]
    ownerId?: StringFilter<"Payout"> | string
    amount?: FloatFilter<"Payout"> | number
    currency?: StringFilter<"Payout"> | string
    status?: EnumPayoutStatusFilter<"Payout"> | $Enums.PayoutStatus
    failureReason?: StringNullableFilter<"Payout"> | string | null
    createdAt?: DateTimeFilter<"Payout"> | Date | string
    processedAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
    paidAt?: DateTimeNullableFilter<"Payout"> | Date | string | null
  }, "id" | "transferId">

  export type PayoutOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transferId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    _count?: PayoutCountOrderByAggregateInput
    _avg?: PayoutAvgOrderByAggregateInput
    _max?: PayoutMaxOrderByAggregateInput
    _min?: PayoutMinOrderByAggregateInput
    _sum?: PayoutSumOrderByAggregateInput
  }

  export type PayoutScalarWhereWithAggregatesInput = {
    AND?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    OR?: PayoutScalarWhereWithAggregatesInput[]
    NOT?: PayoutScalarWhereWithAggregatesInput | PayoutScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payout"> | string
    ownerId?: StringWithAggregatesFilter<"Payout"> | string
    amount?: FloatWithAggregatesFilter<"Payout"> | number
    currency?: StringWithAggregatesFilter<"Payout"> | string
    transferId?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    status?: EnumPayoutStatusWithAggregatesFilter<"Payout"> | $Enums.PayoutStatus
    failureReason?: StringNullableWithAggregatesFilter<"Payout"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payout"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payout"> | Date | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payout"> | Date | string | null
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    listingId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    overallRating?: FloatFilter<"Review"> | number
    accuracyRating?: FloatNullableFilter<"Review"> | number | null
    communicationRating?: FloatNullableFilter<"Review"> | number | null
    cleanlinessRating?: FloatNullableFilter<"Review"> | number | null
    valueRating?: FloatNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    content?: StringFilter<"Review"> | string
    response?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    flagged?: BoolFilter<"Review"> | boolean
    flagReason?: StringNullableFilter<"Review"> | string | null
    moderatedBy?: StringNullableFilter<"Review"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    type?: SortOrder
    overallRating?: SortOrder
    accuracyRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    reviewee?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId_reviewerId_type?: ReviewBookingIdReviewerIdTypeCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    bookingId?: StringFilter<"Review"> | string
    listingId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    overallRating?: FloatFilter<"Review"> | number
    accuracyRating?: FloatNullableFilter<"Review"> | number | null
    communicationRating?: FloatNullableFilter<"Review"> | number | null
    cleanlinessRating?: FloatNullableFilter<"Review"> | number | null
    valueRating?: FloatNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    content?: StringFilter<"Review"> | string
    response?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    flagged?: BoolFilter<"Review"> | boolean
    flagReason?: StringNullableFilter<"Review"> | string | null
    moderatedBy?: StringNullableFilter<"Review"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    listing?: XOR<ListingScalarRelationFilter, ListingWhereInput>
    reviewer?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bookingId_reviewerId_type">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    type?: SortOrder
    overallRating?: SortOrder
    accuracyRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    response?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrderInput | SortOrder
    moderatedBy?: SortOrderInput | SortOrder
    moderatedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    bookingId?: StringWithAggregatesFilter<"Review"> | string
    listingId?: StringWithAggregatesFilter<"Review"> | string
    reviewerId?: StringWithAggregatesFilter<"Review"> | string
    revieweeId?: StringWithAggregatesFilter<"Review"> | string
    type?: EnumReviewTypeWithAggregatesFilter<"Review"> | $Enums.ReviewType
    overallRating?: FloatWithAggregatesFilter<"Review"> | number
    accuracyRating?: FloatNullableWithAggregatesFilter<"Review"> | number | null
    communicationRating?: FloatNullableWithAggregatesFilter<"Review"> | number | null
    cleanlinessRating?: FloatNullableWithAggregatesFilter<"Review"> | number | null
    valueRating?: FloatNullableWithAggregatesFilter<"Review"> | number | null
    title?: StringNullableWithAggregatesFilter<"Review"> | string | null
    content?: StringWithAggregatesFilter<"Review"> | string
    response?: StringNullableWithAggregatesFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    status?: EnumReviewStatusWithAggregatesFilter<"Review"> | $Enums.ReviewStatus
    flagged?: BoolWithAggregatesFilter<"Review"> | boolean
    flagReason?: StringNullableWithAggregatesFilter<"Review"> | string | null
    moderatedBy?: StringNullableWithAggregatesFilter<"Review"> | string | null
    moderatedAt?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    bookingId?: StringNullableFilter<"Conversation"> | string | null
    listingId?: StringNullableFilter<"Conversation"> | string | null
    type?: EnumConversationTypeFilter<"Conversation"> | $Enums.ConversationType
    subject?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessagePreview?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    listingId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessagePreview?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    bookingId?: StringNullableFilter<"Conversation"> | string | null
    listingId?: StringNullableFilter<"Conversation"> | string | null
    type?: EnumConversationTypeFilter<"Conversation"> | $Enums.ConversationType
    subject?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessagePreview?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    listingId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    lastMessageAt?: SortOrderInput | SortOrder
    lastMessagePreview?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    bookingId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    listingId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    type?: EnumConversationTypeWithAggregatesFilter<"Conversation"> | $Enums.ConversationType
    subject?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeNullableWithAggregatesFilter<"Conversation"> | Date | string | null
    lastMessagePreview?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    status?: EnumConversationStatusWithAggregatesFilter<"Conversation"> | $Enums.ConversationStatus
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    muted?: BoolFilter<"ConversationParticipant"> | boolean
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    muted?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_userId?: ConversationParticipantConversationIdUserIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    muted?: BoolFilter<"ConversationParticipant"> | boolean
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "conversationId_userId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    muted?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    conversationId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    userId?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    muted?: BoolWithAggregatesFilter<"ConversationParticipant"> | boolean
    lastReadAt?: DateTimeNullableWithAggregatesFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    attachments?: JsonFilter<"Message">
    metadata?: JsonFilter<"Message">
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    readReceipts?: MessageReadReceiptListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
    readReceipts?: MessageReadReceiptOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    attachments?: JsonFilter<"Message">
    metadata?: JsonFilter<"Message">
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    readReceipts?: MessageReadReceiptListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    content?: StringWithAggregatesFilter<"Message"> | string
    attachments?: JsonWithAggregatesFilter<"Message">
    metadata?: JsonWithAggregatesFilter<"Message">
    status?: EnumMessageStatusWithAggregatesFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type MessageReadReceiptWhereInput = {
    AND?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    OR?: MessageReadReceiptWhereInput[]
    NOT?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    id?: StringFilter<"MessageReadReceipt"> | string
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }

  export type MessageReadReceiptOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
  }

  export type MessageReadReceiptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageReadReceiptMessageIdUserIdCompoundUniqueInput
    AND?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    OR?: MessageReadReceiptWhereInput[]
    NOT?: MessageReadReceiptWhereInput | MessageReadReceiptWhereInput[]
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
  }, "id" | "messageId_userId">

  export type MessageReadReceiptOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadReceiptCountOrderByAggregateInput
    _max?: MessageReadReceiptMaxOrderByAggregateInput
    _min?: MessageReadReceiptMinOrderByAggregateInput
  }

  export type MessageReadReceiptScalarWhereWithAggregatesInput = {
    AND?: MessageReadReceiptScalarWhereWithAggregatesInput | MessageReadReceiptScalarWhereWithAggregatesInput[]
    OR?: MessageReadReceiptScalarWhereWithAggregatesInput[]
    NOT?: MessageReadReceiptScalarWhereWithAggregatesInput | MessageReadReceiptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    messageId?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    userId?: StringWithAggregatesFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageReadReceipt"> | Date | string
  }

  export type ConditionReportWhereInput = {
    AND?: ConditionReportWhereInput | ConditionReportWhereInput[]
    OR?: ConditionReportWhereInput[]
    NOT?: ConditionReportWhereInput | ConditionReportWhereInput[]
    id?: StringFilter<"ConditionReport"> | string
    bookingId?: StringFilter<"ConditionReport"> | string
    reportType?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    type?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    reportedBy?: StringFilter<"ConditionReport"> | string
    reportedAt?: DateTimeFilter<"ConditionReport"> | Date | string
    checklistData?: JsonFilter<"ConditionReport">
    overallCondition?: StringNullableFilter<"ConditionReport"> | string | null
    condition?: StringNullableFilter<"ConditionReport"> | string | null
    notes?: StringNullableFilter<"ConditionReport"> | string | null
    damages?: JsonNullableFilter<"ConditionReport">
    issuesFound?: BoolFilter<"ConditionReport"> | boolean
    damageAmount?: FloatNullableFilter<"ConditionReport"> | number | null
    acknowledgedBy?: StringNullableFilter<"ConditionReport"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
    disputeRaised?: BoolFilter<"ConditionReport"> | boolean
    status?: EnumReportStatusFilter<"ConditionReport"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"ConditionReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
    photos?: ReportPhotoListRelationFilter
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    reportedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    dispute?: XOR<DisputeNullableScalarRelationFilter, DisputeWhereInput> | null
  }

  export type ConditionReportOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reportType?: SortOrder
    type?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    checklistData?: SortOrder
    overallCondition?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    damages?: SortOrderInput | SortOrder
    issuesFound?: SortOrder
    damageAmount?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    disputeRaised?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    photos?: ReportPhotoOrderByRelationAggregateInput
    booking?: BookingOrderByWithRelationInput
    reportedByUser?: UserOrderByWithRelationInput
    dispute?: DisputeOrderByWithRelationInput
  }

  export type ConditionReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConditionReportWhereInput | ConditionReportWhereInput[]
    OR?: ConditionReportWhereInput[]
    NOT?: ConditionReportWhereInput | ConditionReportWhereInput[]
    bookingId?: StringFilter<"ConditionReport"> | string
    reportType?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    type?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    reportedBy?: StringFilter<"ConditionReport"> | string
    reportedAt?: DateTimeFilter<"ConditionReport"> | Date | string
    checklistData?: JsonFilter<"ConditionReport">
    overallCondition?: StringNullableFilter<"ConditionReport"> | string | null
    condition?: StringNullableFilter<"ConditionReport"> | string | null
    notes?: StringNullableFilter<"ConditionReport"> | string | null
    damages?: JsonNullableFilter<"ConditionReport">
    issuesFound?: BoolFilter<"ConditionReport"> | boolean
    damageAmount?: FloatNullableFilter<"ConditionReport"> | number | null
    acknowledgedBy?: StringNullableFilter<"ConditionReport"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
    disputeRaised?: BoolFilter<"ConditionReport"> | boolean
    status?: EnumReportStatusFilter<"ConditionReport"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"ConditionReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
    photos?: ReportPhotoListRelationFilter
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    reportedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
    dispute?: XOR<DisputeNullableScalarRelationFilter, DisputeWhereInput> | null
  }, "id">

  export type ConditionReportOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reportType?: SortOrder
    type?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    checklistData?: SortOrder
    overallCondition?: SortOrderInput | SortOrder
    condition?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    damages?: SortOrderInput | SortOrder
    issuesFound?: SortOrder
    damageAmount?: SortOrderInput | SortOrder
    acknowledgedBy?: SortOrderInput | SortOrder
    acknowledgedAt?: SortOrderInput | SortOrder
    disputeRaised?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: ConditionReportCountOrderByAggregateInput
    _avg?: ConditionReportAvgOrderByAggregateInput
    _max?: ConditionReportMaxOrderByAggregateInput
    _min?: ConditionReportMinOrderByAggregateInput
    _sum?: ConditionReportSumOrderByAggregateInput
  }

  export type ConditionReportScalarWhereWithAggregatesInput = {
    AND?: ConditionReportScalarWhereWithAggregatesInput | ConditionReportScalarWhereWithAggregatesInput[]
    OR?: ConditionReportScalarWhereWithAggregatesInput[]
    NOT?: ConditionReportScalarWhereWithAggregatesInput | ConditionReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ConditionReport"> | string
    bookingId?: StringWithAggregatesFilter<"ConditionReport"> | string
    reportType?: EnumReportTypeWithAggregatesFilter<"ConditionReport"> | $Enums.ReportType
    type?: EnumReportTypeWithAggregatesFilter<"ConditionReport"> | $Enums.ReportType
    reportedBy?: StringWithAggregatesFilter<"ConditionReport"> | string
    reportedAt?: DateTimeWithAggregatesFilter<"ConditionReport"> | Date | string
    checklistData?: JsonWithAggregatesFilter<"ConditionReport">
    overallCondition?: StringNullableWithAggregatesFilter<"ConditionReport"> | string | null
    condition?: StringNullableWithAggregatesFilter<"ConditionReport"> | string | null
    notes?: StringNullableWithAggregatesFilter<"ConditionReport"> | string | null
    damages?: JsonNullableWithAggregatesFilter<"ConditionReport">
    issuesFound?: BoolWithAggregatesFilter<"ConditionReport"> | boolean
    damageAmount?: FloatNullableWithAggregatesFilter<"ConditionReport"> | number | null
    acknowledgedBy?: StringNullableWithAggregatesFilter<"ConditionReport"> | string | null
    acknowledgedAt?: DateTimeNullableWithAggregatesFilter<"ConditionReport"> | Date | string | null
    disputeRaised?: BoolWithAggregatesFilter<"ConditionReport"> | boolean
    status?: EnumReportStatusWithAggregatesFilter<"ConditionReport"> | $Enums.ReportStatus
    createdAt?: DateTimeWithAggregatesFilter<"ConditionReport"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ConditionReport"> | Date | string | null
  }

  export type ReportPhotoWhereInput = {
    AND?: ReportPhotoWhereInput | ReportPhotoWhereInput[]
    OR?: ReportPhotoWhereInput[]
    NOT?: ReportPhotoWhereInput | ReportPhotoWhereInput[]
    id?: StringFilter<"ReportPhoto"> | string
    reportId?: StringFilter<"ReportPhoto"> | string
    url?: StringFilter<"ReportPhoto"> | string
    thumbnailUrl?: StringNullableFilter<"ReportPhoto"> | string | null
    caption?: StringNullableFilter<"ReportPhoto"> | string | null
    tags?: JsonFilter<"ReportPhoto">
    metadata?: JsonFilter<"ReportPhoto">
    order?: IntFilter<"ReportPhoto"> | number
    uploadedAt?: DateTimeFilter<"ReportPhoto"> | Date | string
    report?: XOR<ConditionReportScalarRelationFilter, ConditionReportWhereInput>
  }

  export type ReportPhotoOrderByWithRelationInput = {
    id?: SortOrder
    reportId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    order?: SortOrder
    uploadedAt?: SortOrder
    report?: ConditionReportOrderByWithRelationInput
  }

  export type ReportPhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportPhotoWhereInput | ReportPhotoWhereInput[]
    OR?: ReportPhotoWhereInput[]
    NOT?: ReportPhotoWhereInput | ReportPhotoWhereInput[]
    reportId?: StringFilter<"ReportPhoto"> | string
    url?: StringFilter<"ReportPhoto"> | string
    thumbnailUrl?: StringNullableFilter<"ReportPhoto"> | string | null
    caption?: StringNullableFilter<"ReportPhoto"> | string | null
    tags?: JsonFilter<"ReportPhoto">
    metadata?: JsonFilter<"ReportPhoto">
    order?: IntFilter<"ReportPhoto"> | number
    uploadedAt?: DateTimeFilter<"ReportPhoto"> | Date | string
    report?: XOR<ConditionReportScalarRelationFilter, ConditionReportWhereInput>
  }, "id">

  export type ReportPhotoOrderByWithAggregationInput = {
    id?: SortOrder
    reportId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    caption?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    order?: SortOrder
    uploadedAt?: SortOrder
    _count?: ReportPhotoCountOrderByAggregateInput
    _avg?: ReportPhotoAvgOrderByAggregateInput
    _max?: ReportPhotoMaxOrderByAggregateInput
    _min?: ReportPhotoMinOrderByAggregateInput
    _sum?: ReportPhotoSumOrderByAggregateInput
  }

  export type ReportPhotoScalarWhereWithAggregatesInput = {
    AND?: ReportPhotoScalarWhereWithAggregatesInput | ReportPhotoScalarWhereWithAggregatesInput[]
    OR?: ReportPhotoScalarWhereWithAggregatesInput[]
    NOT?: ReportPhotoScalarWhereWithAggregatesInput | ReportPhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReportPhoto"> | string
    reportId?: StringWithAggregatesFilter<"ReportPhoto"> | string
    url?: StringWithAggregatesFilter<"ReportPhoto"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"ReportPhoto"> | string | null
    caption?: StringNullableWithAggregatesFilter<"ReportPhoto"> | string | null
    tags?: JsonWithAggregatesFilter<"ReportPhoto">
    metadata?: JsonWithAggregatesFilter<"ReportPhoto">
    order?: IntWithAggregatesFilter<"ReportPhoto"> | number
    uploadedAt?: DateTimeWithAggregatesFilter<"ReportPhoto"> | Date | string
  }

  export type DisputeWhereInput = {
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    id?: StringFilter<"Dispute"> | string
    bookingId?: StringFilter<"Dispute"> | string
    conditionReportId?: StringNullableFilter<"Dispute"> | string | null
    initiatorId?: StringFilter<"Dispute"> | string
    defendantId?: StringFilter<"Dispute"> | string
    type?: EnumDisputeTypeFilter<"Dispute"> | $Enums.DisputeType
    title?: StringFilter<"Dispute"> | string
    description?: StringFilter<"Dispute"> | string
    amount?: FloatNullableFilter<"Dispute"> | number | null
    currency?: StringFilter<"Dispute"> | string
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFilter<"Dispute"> | $Enums.DisputePriority
    slaDeadline?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    assignedTo?: StringNullableFilter<"Dispute"> | string | null
    assignedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    resolution?: XOR<DisputeResolutionNullableScalarRelationFilter, DisputeResolutionWhereInput> | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    conditionReport?: XOR<ConditionReportNullableScalarRelationFilter, ConditionReportWhereInput> | null
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
    defendant?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: DisputeResponseListRelationFilter
    evidence?: DisputeEvidenceListRelationFilter
    timeline?: DisputeTimelineEventListRelationFilter
  }

  export type DisputeOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    conditionReportId?: SortOrderInput | SortOrder
    initiatorId?: SortOrder
    defendantId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDeadline?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolution?: DisputeResolutionOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    conditionReport?: ConditionReportOrderByWithRelationInput
    initiator?: UserOrderByWithRelationInput
    defendant?: UserOrderByWithRelationInput
    responses?: DisputeResponseOrderByRelationAggregateInput
    evidence?: DisputeEvidenceOrderByRelationAggregateInput
    timeline?: DisputeTimelineEventOrderByRelationAggregateInput
  }

  export type DisputeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conditionReportId?: string
    AND?: DisputeWhereInput | DisputeWhereInput[]
    OR?: DisputeWhereInput[]
    NOT?: DisputeWhereInput | DisputeWhereInput[]
    bookingId?: StringFilter<"Dispute"> | string
    initiatorId?: StringFilter<"Dispute"> | string
    defendantId?: StringFilter<"Dispute"> | string
    type?: EnumDisputeTypeFilter<"Dispute"> | $Enums.DisputeType
    title?: StringFilter<"Dispute"> | string
    description?: StringFilter<"Dispute"> | string
    amount?: FloatNullableFilter<"Dispute"> | number | null
    currency?: StringFilter<"Dispute"> | string
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFilter<"Dispute"> | $Enums.DisputePriority
    slaDeadline?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    assignedTo?: StringNullableFilter<"Dispute"> | string | null
    assignedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
    resolution?: XOR<DisputeResolutionNullableScalarRelationFilter, DisputeResolutionWhereInput> | null
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    conditionReport?: XOR<ConditionReportNullableScalarRelationFilter, ConditionReportWhereInput> | null
    initiator?: XOR<UserScalarRelationFilter, UserWhereInput>
    defendant?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: DisputeResponseListRelationFilter
    evidence?: DisputeEvidenceListRelationFilter
    timeline?: DisputeTimelineEventListRelationFilter
  }, "id" | "conditionReportId">

  export type DisputeOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    conditionReportId?: SortOrderInput | SortOrder
    initiatorId?: SortOrder
    defendantId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrderInput | SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDeadline?: SortOrderInput | SortOrder
    respondedAt?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DisputeCountOrderByAggregateInput
    _avg?: DisputeAvgOrderByAggregateInput
    _max?: DisputeMaxOrderByAggregateInput
    _min?: DisputeMinOrderByAggregateInput
    _sum?: DisputeSumOrderByAggregateInput
  }

  export type DisputeScalarWhereWithAggregatesInput = {
    AND?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    OR?: DisputeScalarWhereWithAggregatesInput[]
    NOT?: DisputeScalarWhereWithAggregatesInput | DisputeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dispute"> | string
    bookingId?: StringWithAggregatesFilter<"Dispute"> | string
    conditionReportId?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    initiatorId?: StringWithAggregatesFilter<"Dispute"> | string
    defendantId?: StringWithAggregatesFilter<"Dispute"> | string
    type?: EnumDisputeTypeWithAggregatesFilter<"Dispute"> | $Enums.DisputeType
    title?: StringWithAggregatesFilter<"Dispute"> | string
    description?: StringWithAggregatesFilter<"Dispute"> | string
    amount?: FloatNullableWithAggregatesFilter<"Dispute"> | number | null
    currency?: StringWithAggregatesFilter<"Dispute"> | string
    status?: EnumDisputeStatusWithAggregatesFilter<"Dispute"> | $Enums.DisputeStatus
    priority?: EnumDisputePriorityWithAggregatesFilter<"Dispute"> | $Enums.DisputePriority
    slaDeadline?: DateTimeNullableWithAggregatesFilter<"Dispute"> | Date | string | null
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Dispute"> | Date | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Dispute"> | Date | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Dispute"> | string | null
    assignedAt?: DateTimeNullableWithAggregatesFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dispute"> | Date | string
  }

  export type DisputeResponseWhereInput = {
    AND?: DisputeResponseWhereInput | DisputeResponseWhereInput[]
    OR?: DisputeResponseWhereInput[]
    NOT?: DisputeResponseWhereInput | DisputeResponseWhereInput[]
    id?: StringFilter<"DisputeResponse"> | string
    disputeId?: StringFilter<"DisputeResponse"> | string
    userId?: StringFilter<"DisputeResponse"> | string
    content?: StringFilter<"DisputeResponse"> | string
    attachments?: JsonFilter<"DisputeResponse">
    createdAt?: DateTimeFilter<"DisputeResponse"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DisputeResponseOrderByWithRelationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    dispute?: DisputeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type DisputeResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisputeResponseWhereInput | DisputeResponseWhereInput[]
    OR?: DisputeResponseWhereInput[]
    NOT?: DisputeResponseWhereInput | DisputeResponseWhereInput[]
    disputeId?: StringFilter<"DisputeResponse"> | string
    userId?: StringFilter<"DisputeResponse"> | string
    content?: StringFilter<"DisputeResponse"> | string
    attachments?: JsonFilter<"DisputeResponse">
    createdAt?: DateTimeFilter<"DisputeResponse"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DisputeResponseOrderByWithAggregationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    _count?: DisputeResponseCountOrderByAggregateInput
    _max?: DisputeResponseMaxOrderByAggregateInput
    _min?: DisputeResponseMinOrderByAggregateInput
  }

  export type DisputeResponseScalarWhereWithAggregatesInput = {
    AND?: DisputeResponseScalarWhereWithAggregatesInput | DisputeResponseScalarWhereWithAggregatesInput[]
    OR?: DisputeResponseScalarWhereWithAggregatesInput[]
    NOT?: DisputeResponseScalarWhereWithAggregatesInput | DisputeResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisputeResponse"> | string
    disputeId?: StringWithAggregatesFilter<"DisputeResponse"> | string
    userId?: StringWithAggregatesFilter<"DisputeResponse"> | string
    content?: StringWithAggregatesFilter<"DisputeResponse"> | string
    attachments?: JsonWithAggregatesFilter<"DisputeResponse">
    createdAt?: DateTimeWithAggregatesFilter<"DisputeResponse"> | Date | string
  }

  export type DisputeEvidenceWhereInput = {
    AND?: DisputeEvidenceWhereInput | DisputeEvidenceWhereInput[]
    OR?: DisputeEvidenceWhereInput[]
    NOT?: DisputeEvidenceWhereInput | DisputeEvidenceWhereInput[]
    id?: StringFilter<"DisputeEvidence"> | string
    disputeId?: StringFilter<"DisputeEvidence"> | string
    uploadedBy?: StringFilter<"DisputeEvidence"> | string
    type?: EnumEvidenceTypeFilter<"DisputeEvidence"> | $Enums.EvidenceType
    url?: StringFilter<"DisputeEvidence"> | string
    description?: StringNullableFilter<"DisputeEvidence"> | string | null
    metadata?: JsonFilter<"DisputeEvidence">
    uploadedAt?: DateTimeFilter<"DisputeEvidence"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }

  export type DisputeEvidenceOrderByWithRelationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    uploadedBy?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrder
    uploadedAt?: SortOrder
    dispute?: DisputeOrderByWithRelationInput
  }

  export type DisputeEvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisputeEvidenceWhereInput | DisputeEvidenceWhereInput[]
    OR?: DisputeEvidenceWhereInput[]
    NOT?: DisputeEvidenceWhereInput | DisputeEvidenceWhereInput[]
    disputeId?: StringFilter<"DisputeEvidence"> | string
    uploadedBy?: StringFilter<"DisputeEvidence"> | string
    type?: EnumEvidenceTypeFilter<"DisputeEvidence"> | $Enums.EvidenceType
    url?: StringFilter<"DisputeEvidence"> | string
    description?: StringNullableFilter<"DisputeEvidence"> | string | null
    metadata?: JsonFilter<"DisputeEvidence">
    uploadedAt?: DateTimeFilter<"DisputeEvidence"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }, "id">

  export type DisputeEvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    uploadedBy?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrder
    uploadedAt?: SortOrder
    _count?: DisputeEvidenceCountOrderByAggregateInput
    _max?: DisputeEvidenceMaxOrderByAggregateInput
    _min?: DisputeEvidenceMinOrderByAggregateInput
  }

  export type DisputeEvidenceScalarWhereWithAggregatesInput = {
    AND?: DisputeEvidenceScalarWhereWithAggregatesInput | DisputeEvidenceScalarWhereWithAggregatesInput[]
    OR?: DisputeEvidenceScalarWhereWithAggregatesInput[]
    NOT?: DisputeEvidenceScalarWhereWithAggregatesInput | DisputeEvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisputeEvidence"> | string
    disputeId?: StringWithAggregatesFilter<"DisputeEvidence"> | string
    uploadedBy?: StringWithAggregatesFilter<"DisputeEvidence"> | string
    type?: EnumEvidenceTypeWithAggregatesFilter<"DisputeEvidence"> | $Enums.EvidenceType
    url?: StringWithAggregatesFilter<"DisputeEvidence"> | string
    description?: StringNullableWithAggregatesFilter<"DisputeEvidence"> | string | null
    metadata?: JsonWithAggregatesFilter<"DisputeEvidence">
    uploadedAt?: DateTimeWithAggregatesFilter<"DisputeEvidence"> | Date | string
  }

  export type DisputeTimelineEventWhereInput = {
    AND?: DisputeTimelineEventWhereInput | DisputeTimelineEventWhereInput[]
    OR?: DisputeTimelineEventWhereInput[]
    NOT?: DisputeTimelineEventWhereInput | DisputeTimelineEventWhereInput[]
    id?: StringFilter<"DisputeTimelineEvent"> | string
    disputeId?: StringFilter<"DisputeTimelineEvent"> | string
    eventType?: StringFilter<"DisputeTimelineEvent"> | string
    description?: StringFilter<"DisputeTimelineEvent"> | string
    metadata?: JsonFilter<"DisputeTimelineEvent">
    createdAt?: DateTimeFilter<"DisputeTimelineEvent"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }

  export type DisputeTimelineEventOrderByWithRelationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    dispute?: DisputeOrderByWithRelationInput
  }

  export type DisputeTimelineEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisputeTimelineEventWhereInput | DisputeTimelineEventWhereInput[]
    OR?: DisputeTimelineEventWhereInput[]
    NOT?: DisputeTimelineEventWhereInput | DisputeTimelineEventWhereInput[]
    disputeId?: StringFilter<"DisputeTimelineEvent"> | string
    eventType?: StringFilter<"DisputeTimelineEvent"> | string
    description?: StringFilter<"DisputeTimelineEvent"> | string
    metadata?: JsonFilter<"DisputeTimelineEvent">
    createdAt?: DateTimeFilter<"DisputeTimelineEvent"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }, "id">

  export type DisputeTimelineEventOrderByWithAggregationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: DisputeTimelineEventCountOrderByAggregateInput
    _max?: DisputeTimelineEventMaxOrderByAggregateInput
    _min?: DisputeTimelineEventMinOrderByAggregateInput
  }

  export type DisputeTimelineEventScalarWhereWithAggregatesInput = {
    AND?: DisputeTimelineEventScalarWhereWithAggregatesInput | DisputeTimelineEventScalarWhereWithAggregatesInput[]
    OR?: DisputeTimelineEventScalarWhereWithAggregatesInput[]
    NOT?: DisputeTimelineEventScalarWhereWithAggregatesInput | DisputeTimelineEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisputeTimelineEvent"> | string
    disputeId?: StringWithAggregatesFilter<"DisputeTimelineEvent"> | string
    eventType?: StringWithAggregatesFilter<"DisputeTimelineEvent"> | string
    description?: StringWithAggregatesFilter<"DisputeTimelineEvent"> | string
    metadata?: JsonWithAggregatesFilter<"DisputeTimelineEvent">
    createdAt?: DateTimeWithAggregatesFilter<"DisputeTimelineEvent"> | Date | string
  }

  export type DisputeResolutionWhereInput = {
    AND?: DisputeResolutionWhereInput | DisputeResolutionWhereInput[]
    OR?: DisputeResolutionWhereInput[]
    NOT?: DisputeResolutionWhereInput | DisputeResolutionWhereInput[]
    id?: StringFilter<"DisputeResolution"> | string
    disputeId?: StringFilter<"DisputeResolution"> | string
    outcome?: EnumResolutionOutcomeFilter<"DisputeResolution"> | $Enums.ResolutionOutcome
    summary?: StringFilter<"DisputeResolution"> | string
    refundAmount?: FloatNullableFilter<"DisputeResolution"> | number | null
    payoutAdjustment?: FloatNullableFilter<"DisputeResolution"> | number | null
    actionsTaken?: JsonFilter<"DisputeResolution">
    resolvedBy?: StringFilter<"DisputeResolution"> | string
    resolvedAt?: DateTimeFilter<"DisputeResolution"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }

  export type DisputeResolutionOrderByWithRelationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    outcome?: SortOrder
    summary?: SortOrder
    refundAmount?: SortOrderInput | SortOrder
    payoutAdjustment?: SortOrderInput | SortOrder
    actionsTaken?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    dispute?: DisputeOrderByWithRelationInput
  }

  export type DisputeResolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    disputeId?: string
    AND?: DisputeResolutionWhereInput | DisputeResolutionWhereInput[]
    OR?: DisputeResolutionWhereInput[]
    NOT?: DisputeResolutionWhereInput | DisputeResolutionWhereInput[]
    outcome?: EnumResolutionOutcomeFilter<"DisputeResolution"> | $Enums.ResolutionOutcome
    summary?: StringFilter<"DisputeResolution"> | string
    refundAmount?: FloatNullableFilter<"DisputeResolution"> | number | null
    payoutAdjustment?: FloatNullableFilter<"DisputeResolution"> | number | null
    actionsTaken?: JsonFilter<"DisputeResolution">
    resolvedBy?: StringFilter<"DisputeResolution"> | string
    resolvedAt?: DateTimeFilter<"DisputeResolution"> | Date | string
    dispute?: XOR<DisputeScalarRelationFilter, DisputeWhereInput>
  }, "id" | "disputeId">

  export type DisputeResolutionOrderByWithAggregationInput = {
    id?: SortOrder
    disputeId?: SortOrder
    outcome?: SortOrder
    summary?: SortOrder
    refundAmount?: SortOrderInput | SortOrder
    payoutAdjustment?: SortOrderInput | SortOrder
    actionsTaken?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
    _count?: DisputeResolutionCountOrderByAggregateInput
    _avg?: DisputeResolutionAvgOrderByAggregateInput
    _max?: DisputeResolutionMaxOrderByAggregateInput
    _min?: DisputeResolutionMinOrderByAggregateInput
    _sum?: DisputeResolutionSumOrderByAggregateInput
  }

  export type DisputeResolutionScalarWhereWithAggregatesInput = {
    AND?: DisputeResolutionScalarWhereWithAggregatesInput | DisputeResolutionScalarWhereWithAggregatesInput[]
    OR?: DisputeResolutionScalarWhereWithAggregatesInput[]
    NOT?: DisputeResolutionScalarWhereWithAggregatesInput | DisputeResolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisputeResolution"> | string
    disputeId?: StringWithAggregatesFilter<"DisputeResolution"> | string
    outcome?: EnumResolutionOutcomeWithAggregatesFilter<"DisputeResolution"> | $Enums.ResolutionOutcome
    summary?: StringWithAggregatesFilter<"DisputeResolution"> | string
    refundAmount?: FloatNullableWithAggregatesFilter<"DisputeResolution"> | number | null
    payoutAdjustment?: FloatNullableWithAggregatesFilter<"DisputeResolution"> | number | null
    actionsTaken?: JsonWithAggregatesFilter<"DisputeResolution">
    resolvedBy?: StringWithAggregatesFilter<"DisputeResolution"> | string
    resolvedAt?: DateTimeWithAggregatesFilter<"DisputeResolution"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    relatedId?: StringNullableFilter<"Notification"> | string | null
    relatedType?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: StringNullableFilter<"Notification"> | string | null
    sentViaEmail?: BoolFilter<"Notification"> | boolean
    sentViaPush?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    relatedType?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sentViaEmail?: SortOrder
    sentViaPush?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    relatedId?: StringNullableFilter<"Notification"> | string | null
    relatedType?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: StringNullableFilter<"Notification"> | string | null
    sentViaEmail?: BoolFilter<"Notification"> | boolean
    sentViaPush?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    relatedType?: SortOrderInput | SortOrder
    actionUrl?: SortOrderInput | SortOrder
    actionLabel?: SortOrderInput | SortOrder
    read?: SortOrder
    readAt?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    sentViaEmail?: SortOrder
    sentViaPush?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    relatedId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    actionLabel?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    sentViaEmail?: BoolWithAggregatesFilter<"Notification"> | boolean
    sentViaPush?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    newValues?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type InsurancePolicyWhereInput = {
    AND?: InsurancePolicyWhereInput | InsurancePolicyWhereInput[]
    OR?: InsurancePolicyWhereInput[]
    NOT?: InsurancePolicyWhereInput | InsurancePolicyWhereInput[]
    id?: StringFilter<"InsurancePolicy"> | string
    userId?: StringFilter<"InsurancePolicy"> | string
    listingId?: StringNullableFilter<"InsurancePolicy"> | string | null
    policyNumber?: StringFilter<"InsurancePolicy"> | string
    provider?: StringFilter<"InsurancePolicy"> | string
    type?: StringFilter<"InsurancePolicy"> | string
    coverageAmount?: IntFilter<"InsurancePolicy"> | number
    effectiveDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    expirationDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    documentUrl?: StringFilter<"InsurancePolicy"> | string
    certificateUrl?: StringNullableFilter<"InsurancePolicy"> | string | null
    status?: EnumInsuranceStatusFilter<"InsurancePolicy"> | $Enums.InsuranceStatus
    verificationDate?: DateTimeNullableFilter<"InsurancePolicy"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsurancePolicy"> | string | null
    notes?: StringNullableFilter<"InsurancePolicy"> | string | null
    metadata?: JsonNullableFilter<"InsurancePolicy">
    createdAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<ListingNullableScalarRelationFilter, ListingWhereInput> | null
  }

  export type InsurancePolicyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrderInput | SortOrder
    policyNumber?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    coverageAmount?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    documentUrl?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
  }

  export type InsurancePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    policyNumber?: string
    AND?: InsurancePolicyWhereInput | InsurancePolicyWhereInput[]
    OR?: InsurancePolicyWhereInput[]
    NOT?: InsurancePolicyWhereInput | InsurancePolicyWhereInput[]
    userId?: StringFilter<"InsurancePolicy"> | string
    listingId?: StringNullableFilter<"InsurancePolicy"> | string | null
    provider?: StringFilter<"InsurancePolicy"> | string
    type?: StringFilter<"InsurancePolicy"> | string
    coverageAmount?: IntFilter<"InsurancePolicy"> | number
    effectiveDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    expirationDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    documentUrl?: StringFilter<"InsurancePolicy"> | string
    certificateUrl?: StringNullableFilter<"InsurancePolicy"> | string | null
    status?: EnumInsuranceStatusFilter<"InsurancePolicy"> | $Enums.InsuranceStatus
    verificationDate?: DateTimeNullableFilter<"InsurancePolicy"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsurancePolicy"> | string | null
    notes?: StringNullableFilter<"InsurancePolicy"> | string | null
    metadata?: JsonNullableFilter<"InsurancePolicy">
    createdAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    listing?: XOR<ListingNullableScalarRelationFilter, ListingWhereInput> | null
  }, "id" | "policyNumber">

  export type InsurancePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrderInput | SortOrder
    policyNumber?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    coverageAmount?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    documentUrl?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    verificationDate?: SortOrderInput | SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsurancePolicyCountOrderByAggregateInput
    _avg?: InsurancePolicyAvgOrderByAggregateInput
    _max?: InsurancePolicyMaxOrderByAggregateInput
    _min?: InsurancePolicyMinOrderByAggregateInput
    _sum?: InsurancePolicySumOrderByAggregateInput
  }

  export type InsurancePolicyScalarWhereWithAggregatesInput = {
    AND?: InsurancePolicyScalarWhereWithAggregatesInput | InsurancePolicyScalarWhereWithAggregatesInput[]
    OR?: InsurancePolicyScalarWhereWithAggregatesInput[]
    NOT?: InsurancePolicyScalarWhereWithAggregatesInput | InsurancePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    userId?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    listingId?: StringNullableWithAggregatesFilter<"InsurancePolicy"> | string | null
    policyNumber?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    provider?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    type?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    coverageAmount?: IntWithAggregatesFilter<"InsurancePolicy"> | number
    effectiveDate?: DateTimeWithAggregatesFilter<"InsurancePolicy"> | Date | string
    expirationDate?: DateTimeWithAggregatesFilter<"InsurancePolicy"> | Date | string
    documentUrl?: StringWithAggregatesFilter<"InsurancePolicy"> | string
    certificateUrl?: StringNullableWithAggregatesFilter<"InsurancePolicy"> | string | null
    status?: EnumInsuranceStatusWithAggregatesFilter<"InsurancePolicy"> | $Enums.InsuranceStatus
    verificationDate?: DateTimeNullableWithAggregatesFilter<"InsurancePolicy"> | Date | string | null
    verifiedBy?: StringNullableWithAggregatesFilter<"InsurancePolicy"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InsurancePolicy"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"InsurancePolicy">
    createdAt?: DateTimeWithAggregatesFilter<"InsurancePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InsurancePolicy"> | Date | string
  }

  export type DeviceTokenWhereInput = {
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    active?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    userId?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    active?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type DeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DeviceTokenCountOrderByAggregateInput
    _max?: DeviceTokenMaxOrderByAggregateInput
    _min?: DeviceTokenMinOrderByAggregateInput
  }

  export type DeviceTokenScalarWhereWithAggregatesInput = {
    AND?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    OR?: DeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceToken"> | string
    userId?: StringWithAggregatesFilter<"DeviceToken"> | string
    token?: StringWithAggregatesFilter<"DeviceToken"> | string
    platform?: StringWithAggregatesFilter<"DeviceToken"> | string
    active?: BoolWithAggregatesFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    preferences?: JsonFilter<"UserPreferences">
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    preferences?: JsonFilter<"UserPreferences">
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    preferences?: JsonWithAggregatesFilter<"UserPreferences">
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
    listings?: ListingCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
    listings?: ListingUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
    listings?: ListingUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateInput = {
    id?: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationMemberUncheckedCreateInput = {
    id?: string
    organizationId: string
    userId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberCreateManyInput = {
    id?: string
    organizationId: string
    userId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type OrganizationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    iconUrl?: string | null
    order?: number
    active?: boolean
    templateSchema: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: $Enums.PricingMode
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: number
    insuranceRequired?: boolean
    minimumInsuranceAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    iconUrl?: string | null
    order?: number
    active?: boolean
    templateSchema: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: $Enums.PricingMode
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: number
    insuranceRequired?: boolean
    minimumInsuranceAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    iconUrl?: string | null
    order?: number
    active?: boolean
    templateSchema: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: $Enums.PricingMode
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: number
    insuranceRequired?: boolean
    minimumInsuranceAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingCreateManyInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CancellationPolicyCreateInput = {
    id?: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingCreateNestedManyWithoutCancellationPolicyInput
  }

  export type CancellationPolicyUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutCancellationPolicyInput
  }

  export type CancellationPolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutCancellationPolicyNestedInput
  }

  export type CancellationPolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutCancellationPolicyNestedInput
  }

  export type CancellationPolicyCreateManyInput = {
    id?: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationPolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    listing: ListingCreateNestedOneWithoutAvailabilityInput
  }

  export type AvailabilityUncheckedCreateInput = {
    id?: string
    listingId: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
  }

  export type AvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type AvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityCreateManyInput = {
    id?: string
    listingId: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
  }

  export type AvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteListingsInput
    listing: ListingCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteListingUncheckedCreateInput = {
    id?: string
    userId: string
    listingId: string
    createdAt?: Date | string
  }

  export type FavoriteListingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteListingsNestedInput
    listing?: ListingUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteListingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingCreateManyInput = {
    id?: string
    userId: string
    listingId: string
    createdAt?: Date | string
  }

  export type FavoriteListingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingStateHistoryCreateInput = {
    id?: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutStateHistoryInput
  }

  export type BookingStateHistoryUncheckedCreateInput = {
    id?: string
    bookingId: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type BookingStateHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutStateHistoryNestedInput
  }

  export type BookingStateHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStateHistoryCreateManyInput = {
    id?: string
    bookingId: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type BookingStateHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStateHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryCreateInput = {
    id?: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutLedgerEntriesInput
  }

  export type LedgerEntryUncheckedCreateInput = {
    id?: string
    bookingId: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type LedgerEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutLedgerEntriesNestedInput
  }

  export type LedgerEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryCreateManyInput = {
    id?: string
    bookingId: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type LedgerEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DepositHoldCreateInput = {
    id?: string
    bookingId?: string | null
    amount: number
    currency?: string
    paymentIntentId: string
    status?: $Enums.DepositStatus
    authorizedAt?: Date | string
    capturedAt?: Date | string | null
    releasedAt?: Date | string | null
    deductedAmount?: number
    deductionReason?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    bookings?: BookingCreateNestedManyWithoutDepositHoldInput
  }

  export type DepositHoldUncheckedCreateInput = {
    id?: string
    bookingId?: string | null
    amount: number
    currency?: string
    paymentIntentId: string
    status?: $Enums.DepositStatus
    authorizedAt?: Date | string
    capturedAt?: Date | string | null
    releasedAt?: Date | string | null
    deductedAmount?: number
    deductionReason?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDepositHoldInput
  }

  export type DepositHoldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutDepositHoldNestedInput
  }

  export type DepositHoldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDepositHoldNestedInput
  }

  export type DepositHoldCreateManyInput = {
    id?: string
    bookingId?: string | null
    amount: number
    currency?: string
    paymentIntentId: string
    status?: $Enums.DepositStatus
    authorizedAt?: Date | string
    capturedAt?: Date | string | null
    releasedAt?: Date | string | null
    deductedAmount?: number
    deductionReason?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DepositHoldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositHoldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    reason: string
    refundId: string
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RefundUncheckedCreateInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    reason: string
    refundId: string
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RefundUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundCreateManyInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    reason: string
    refundId: string
    status?: $Enums.RefundStatus
    processedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type RefundUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefundUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    refundId?: StringFieldUpdateOperationsInput | string
    status?: EnumRefundStatusFieldUpdateOperationsInput | $Enums.RefundStatus
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayoutCreateInput = {
    id?: string
    ownerId: string
    amount: number
    currency?: string
    transferId?: string | null
    status?: $Enums.PayoutStatus
    failureReason?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
  }

  export type PayoutUncheckedCreateInput = {
    id?: string
    ownerId: string
    amount: number
    currency?: string
    transferId?: string | null
    status?: $Enums.PayoutStatus
    failureReason?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
  }

  export type PayoutUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayoutUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayoutCreateManyInput = {
    id?: string
    ownerId: string
    amount: number
    currency?: string
    transferId?: string | null
    status?: $Enums.PayoutStatus
    failureReason?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    paidAt?: Date | string | null
  }

  export type PayoutUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PayoutUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transferId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPayoutStatusFieldUpdateOperationsInput | $Enums.PayoutStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateInput = {
    id?: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewsInput
    listing: ListingCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewee: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    bookingId: string
    listingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    listing?: ListingUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    bookingId: string
    listingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    bookingId?: string | null
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    bookingId?: string | null
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    id?: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    user: UserCreateNestedOneWithoutConversationParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    userId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    user?: UserUpdateOneRequiredWithoutConversationParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    userId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageReadReceiptCreateInput = {
    id?: string
    userId: string
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadReceiptsInput
  }

  export type MessageReadReceiptUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadReceiptsNestedInput
  }

  export type MessageReadReceiptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionReportCreateInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoCreateNestedManyWithoutReportInput
    booking: BookingCreateNestedOneWithoutConditionReportsInput
    reportedByUser: UserCreateNestedOneWithoutConditionReportsReportedInput
    dispute?: DisputeCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportUncheckedCreateInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoUncheckedCreateNestedManyWithoutReportInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUpdateManyWithoutReportNestedInput
    booking?: BookingUpdateOneRequiredWithoutConditionReportsNestedInput
    reportedByUser?: UserUpdateOneRequiredWithoutConditionReportsReportedNestedInput
    dispute?: DisputeUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUncheckedUpdateManyWithoutReportNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportCreateManyInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ConditionReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConditionReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportPhotoCreateInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
    report: ConditionReportCreateNestedOneWithoutPhotosInput
  }

  export type ReportPhotoUncheckedCreateInput = {
    id?: string
    reportId: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
  }

  export type ReportPhotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ConditionReportUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ReportPhotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPhotoCreateManyInput = {
    id?: string
    reportId: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
  }

  export type ReportPhotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPhotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeCreateInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeCreateManyInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseCreateInput = {
    id?: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    dispute: DisputeCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutDisputeResponsesInput
  }

  export type DisputeResponseUncheckedCreateInput = {
    id?: string
    disputeId: string
    userId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispute?: DisputeUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutDisputeResponsesNestedInput
  }

  export type DisputeResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseCreateManyInput = {
    id?: string
    disputeId: string
    userId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceCreateInput = {
    id?: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
    dispute: DisputeCreateNestedOneWithoutEvidenceInput
  }

  export type DisputeEvidenceUncheckedCreateInput = {
    id?: string
    disputeId: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
  }

  export type DisputeEvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispute?: DisputeUpdateOneRequiredWithoutEvidenceNestedInput
  }

  export type DisputeEvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceCreateManyInput = {
    id?: string
    disputeId: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
  }

  export type DisputeEvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventCreateInput = {
    id?: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    dispute: DisputeCreateNestedOneWithoutTimelineInput
  }

  export type DisputeTimelineEventUncheckedCreateInput = {
    id?: string
    disputeId: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeTimelineEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispute?: DisputeUpdateOneRequiredWithoutTimelineNestedInput
  }

  export type DisputeTimelineEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventCreateManyInput = {
    id?: string
    disputeId: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeTimelineEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResolutionCreateInput = {
    id?: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount?: number | null
    payoutAdjustment?: number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy: string
    resolvedAt?: Date | string
    dispute: DisputeCreateNestedOneWithoutResolutionInput
  }

  export type DisputeResolutionUncheckedCreateInput = {
    id?: string
    disputeId: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount?: number | null
    payoutAdjustment?: number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy: string
    resolvedAt?: Date | string
  }

  export type DisputeResolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispute?: DisputeUpdateOneRequiredWithoutResolutionNestedInput
  }

  export type DisputeResolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResolutionCreateManyInput = {
    id?: string
    disputeId: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount?: number | null
    payoutAdjustment?: number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy: string
    resolvedAt?: Date | string
  }

  export type DisputeResolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyCreateInput = {
    id?: string
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsurancePoliciesInput
    listing?: ListingCreateNestedOneWithoutInsurancePoliciesInput
  }

  export type InsurancePolicyUncheckedCreateInput = {
    id?: string
    userId: string
    listingId?: string | null
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsurancePoliciesNestedInput
    listing?: ListingUpdateOneWithoutInsurancePoliciesNestedInput
  }

  export type InsurancePolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyCreateManyInput = {
    id?: string
    userId: string
    listingId?: string | null
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateInput = {
    id?: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDeviceTokensInput
  }

  export type DeviceTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type DeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type EnumGovernmentIdTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernmentIdType | EnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel> | $Enums.GovernmentIdType | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type ListingListRelationFilter = {
    every?: ListingWhereInput
    some?: ListingWhereInput
    none?: ListingWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type DisputeListRelationFilter = {
    every?: DisputeWhereInput
    some?: DisputeWhereInput
    none?: DisputeWhereInput
  }

  export type DisputeResponseListRelationFilter = {
    every?: DisputeResponseWhereInput
    some?: DisputeResponseWhereInput
    none?: DisputeResponseWhereInput
  }

  export type OrganizationMemberListRelationFilter = {
    every?: OrganizationMemberWhereInput
    some?: OrganizationMemberWhereInput
    none?: OrganizationMemberWhereInput
  }

  export type FavoriteListingListRelationFilter = {
    every?: FavoriteListingWhereInput
    some?: FavoriteListingWhereInput
    none?: FavoriteListingWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type InsurancePolicyListRelationFilter = {
    every?: InsurancePolicyWhereInput
    some?: InsurancePolicyWhereInput
    none?: InsurancePolicyWhereInput
  }

  export type DeviceTokenListRelationFilter = {
    every?: DeviceTokenWhereInput
    some?: DeviceTokenWhereInput
    none?: DeviceTokenWhereInput
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type ConditionReportListRelationFilter = {
    every?: ConditionReportWhereInput
    some?: ConditionReportWhereInput
    none?: ConditionReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisputeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisputeResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsurancePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConditionReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    dateOfBirth?: SortOrder
    profilePhotoUrl?: SortOrder
    bio?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    idVerificationStatus?: SortOrder
    idVerificationUrl?: SortOrder
    governmentIdUrl?: SortOrder
    governmentIdType?: SortOrder
    governmentIdNumber?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnectId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    role?: SortOrder
    status?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    timezone?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    dateOfBirth?: SortOrder
    profilePhotoUrl?: SortOrder
    bio?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    idVerificationStatus?: SortOrder
    idVerificationUrl?: SortOrder
    governmentIdUrl?: SortOrder
    governmentIdType?: SortOrder
    governmentIdNumber?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnectId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    role?: SortOrder
    status?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    timezone?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordHash?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phoneNumber?: SortOrder
    phone?: SortOrder
    phoneVerified?: SortOrder
    dateOfBirth?: SortOrder
    profilePhotoUrl?: SortOrder
    bio?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    idVerificationStatus?: SortOrder
    idVerificationUrl?: SortOrder
    governmentIdUrl?: SortOrder
    governmentIdType?: SortOrder
    governmentIdNumber?: SortOrder
    stripeCustomerId?: SortOrder
    stripeConnectId?: SortOrder
    stripeOnboardingComplete?: SortOrder
    stripeChargesEnabled?: SortOrder
    stripePayoutsEnabled?: SortOrder
    role?: SortOrder
    status?: SortOrder
    preferredLanguage?: SortOrder
    preferredCurrency?: SortOrder
    timezone?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    lastLoginIp?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    averageRating?: SortOrder
    totalReviews?: SortOrder
    responseRate?: SortOrder
    responseTime?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type EnumGovernmentIdTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernmentIdType | EnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGovernmentIdTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GovernmentIdType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOrganizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationStatus | EnumOrganizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationStatusFilter<$PrismaModel> | $Enums.OrganizationStatus
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    websiteUrl?: SortOrder
    businessType?: SortOrder
    taxId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    stripeConnectId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    websiteUrl?: SortOrder
    businessType?: SortOrder
    taxId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    stripeConnectId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    logoUrl?: SortOrder
    websiteUrl?: SortOrder
    businessType?: SortOrder
    taxId?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    stripeConnectId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrganizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationStatus | EnumOrganizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrganizationStatusFilter<$PrismaModel>
  }

  export type EnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type OrganizationMemberOrganizationIdUserIdCompoundUniqueInput = {
    organizationId: string
    userId: string
  }

  export type OrganizationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }

  export type OrganizationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumPricingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingMode | EnumPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModeFilter<$PrismaModel> | $Enums.PricingMode
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    order?: SortOrder
    active?: SortOrder
    templateSchema?: SortOrder
    searchableFields?: SortOrder
    requiredFields?: SortOrder
    defaultPricingMode?: SortOrder
    allowInstantBook?: SortOrder
    requiresDepositDefault?: SortOrder
    defaultDepositPercentage?: SortOrder
    insuranceRequired?: SortOrder
    minimumInsuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    order?: SortOrder
    defaultDepositPercentage?: SortOrder
    minimumInsuranceAmount?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    order?: SortOrder
    active?: SortOrder
    defaultPricingMode?: SortOrder
    allowInstantBook?: SortOrder
    requiresDepositDefault?: SortOrder
    defaultDepositPercentage?: SortOrder
    insuranceRequired?: SortOrder
    minimumInsuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    iconUrl?: SortOrder
    order?: SortOrder
    active?: SortOrder
    defaultPricingMode?: SortOrder
    allowInstantBook?: SortOrder
    requiresDepositDefault?: SortOrder
    defaultDepositPercentage?: SortOrder
    insuranceRequired?: SortOrder
    minimumInsuranceAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    order?: SortOrder
    defaultDepositPercentage?: SortOrder
    minimumInsuranceAmount?: SortOrder
  }

  export type EnumPricingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingMode | EnumPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModeWithAggregatesFilter<$PrismaModel> | $Enums.PricingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModeFilter<$PrismaModel>
    _max?: NestedEnumPricingModeFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumDepositTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepositTypeNullableFilter<$PrismaModel> | $Enums.DepositType | null
  }

  export type EnumBookingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMode | EnumBookingModeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingModeFilter<$PrismaModel> | $Enums.BookingMode
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumListingConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingCondition | EnumListingConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingConditionNullableFilter<$PrismaModel> | $Enums.ListingCondition | null
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type OrganizationNullableScalarRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type CategoryScalarRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type CancellationPolicyNullableScalarRelationFilter = {
    is?: CancellationPolicyWhereInput | null
    isNot?: CancellationPolicyWhereInput | null
  }

  export type AvailabilityListRelationFilter = {
    every?: AvailabilityWhereInput
    some?: AvailabilityWhereInput
    none?: AvailabilityWhereInput
  }

  export type AvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    photos?: SortOrder
    videos?: SortOrder
    documents?: SortOrder
    pricingMode?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrder
    dailyPrice?: SortOrder
    weeklyPrice?: SortOrder
    monthlyPrice?: SortOrder
    currency?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    depositType?: SortOrder
    bookingMode?: SortOrder
    minBookingHours?: SortOrder
    maxBookingDays?: SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrder
    categorySpecificData?: SortOrder
    condition?: SortOrder
    features?: SortOrder
    amenities?: SortOrder
    cancellationPolicyId?: SortOrder
    rules?: SortOrder
    insurancePolicyId?: SortOrder
    insuranceVerified?: SortOrder
    insuranceVerifiedAt?: SortOrder
    insuranceExpiresAt?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    rejectionReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ListingAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrder
    dailyPrice?: SortOrder
    weeklyPrice?: SortOrder
    monthlyPrice?: SortOrder
    depositAmount?: SortOrder
    minBookingHours?: SortOrder
    maxBookingDays?: SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type ListingMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    pricingMode?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrder
    dailyPrice?: SortOrder
    weeklyPrice?: SortOrder
    monthlyPrice?: SortOrder
    currency?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    depositType?: SortOrder
    bookingMode?: SortOrder
    minBookingHours?: SortOrder
    maxBookingDays?: SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrder
    condition?: SortOrder
    cancellationPolicyId?: SortOrder
    insurancePolicyId?: SortOrder
    insuranceVerified?: SortOrder
    insuranceVerifiedAt?: SortOrder
    insuranceExpiresAt?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    rejectionReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ListingMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    organizationId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    addressLine1?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    pricingMode?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrder
    dailyPrice?: SortOrder
    weeklyPrice?: SortOrder
    monthlyPrice?: SortOrder
    currency?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    depositType?: SortOrder
    bookingMode?: SortOrder
    minBookingHours?: SortOrder
    maxBookingDays?: SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrder
    condition?: SortOrder
    cancellationPolicyId?: SortOrder
    insurancePolicyId?: SortOrder
    insuranceVerified?: SortOrder
    insuranceVerifiedAt?: SortOrder
    insuranceExpiresAt?: SortOrder
    status?: SortOrder
    verificationStatus?: SortOrder
    rejectionReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ListingSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    basePrice?: SortOrder
    hourlyPrice?: SortOrder
    dailyPrice?: SortOrder
    weeklyPrice?: SortOrder
    monthlyPrice?: SortOrder
    depositAmount?: SortOrder
    minBookingHours?: SortOrder
    maxBookingDays?: SortOrder
    leadTime?: SortOrder
    advanceNotice?: SortOrder
    capacity?: SortOrder
    viewCount?: SortOrder
    bookingCount?: SortOrder
    favoriteCount?: SortOrder
    averageRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type EnumDepositTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepositTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DepositType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDepositTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDepositTypeNullableFilter<$PrismaModel>
  }

  export type EnumBookingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMode | EnumBookingModeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingModeWithAggregatesFilter<$PrismaModel> | $Enums.BookingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingModeFilter<$PrismaModel>
    _max?: NestedEnumBookingModeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumListingConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingCondition | EnumListingConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListingCondition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListingConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumListingConditionNullableFilter<$PrismaModel>
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type EnumCancellationPolicyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicyType | EnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel> | $Enums.CancellationPolicyType
  }

  export type CancellationPolicyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    rules?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationPolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationPolicyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCancellationPolicyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicyType | EnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationPolicyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CancellationPolicyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel>
    _max?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel>
  }

  export type ListingScalarRelationFilter = {
    is?: ListingWhereInput
    isNot?: ListingWhereInput
  }

  export type AvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilityAvgOrderByAggregateInput = {
    price?: SortOrder
    minStay?: SortOrder
  }

  export type AvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
  }

  export type AvailabilitySumOrderByAggregateInput = {
    price?: SortOrder
    minStay?: SortOrder
  }

  export type FavoriteListingUserIdListingIdCompoundUniqueInput = {
    userId: string
    listingId: string
  }

  export type FavoriteListingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteListingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteListingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type BookingStateHistoryListRelationFilter = {
    every?: BookingStateHistoryWhereInput
    some?: BookingStateHistoryWhereInput
    none?: BookingStateHistoryWhereInput
  }

  export type LedgerEntryListRelationFilter = {
    every?: LedgerEntryWhereInput
    some?: LedgerEntryWhereInput
    none?: LedgerEntryWhereInput
  }

  export type DepositHoldNullableScalarRelationFilter = {
    is?: DepositHoldWhereInput | null
    isNot?: DepositHoldWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type BookingStateHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LedgerEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    renterId?: SortOrder
    ownerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
    currency?: SortOrder
    renterMessage?: SortOrder
    status?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    cancelledAt?: SortOrder
    paymentIntentId?: SortOrder
    depositHoldId?: SortOrder
    depositReleased?: SortOrder
    depositReleasedAt?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    actualReturnTime?: SortOrder
    categoryData?: SortOrder
    renterNotes?: SortOrder
    ownerNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    renterId?: SortOrder
    ownerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
    currency?: SortOrder
    renterMessage?: SortOrder
    status?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    cancelledAt?: SortOrder
    paymentIntentId?: SortOrder
    depositHoldId?: SortOrder
    depositReleased?: SortOrder
    depositReleasedAt?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    actualReturnTime?: SortOrder
    renterNotes?: SortOrder
    ownerNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    renterId?: SortOrder
    ownerId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
    currency?: SortOrder
    renterMessage?: SortOrder
    status?: SortOrder
    cancellationReason?: SortOrder
    cancelledBy?: SortOrder
    cancelledAt?: SortOrder
    paymentIntentId?: SortOrder
    depositHoldId?: SortOrder
    depositReleased?: SortOrder
    depositReleasedAt?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    actualReturnTime?: SortOrder
    renterNotes?: SortOrder
    ownerNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    confirmedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    duration?: SortOrder
    guestCount?: SortOrder
    basePrice?: SortOrder
    serviceFee?: SortOrder
    tax?: SortOrder
    depositAmount?: SortOrder
    discountAmount?: SortOrder
    totalPrice?: SortOrder
    totalAmount?: SortOrder
    ownerEarnings?: SortOrder
    platformFee?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type BookingStateHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fromState?: SortOrder
    toState?: SortOrder
    reason?: SortOrder
    metadata?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingStateHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fromState?: SortOrder
    toState?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingStateHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    fromState?: SortOrder
    toState?: SortOrder
    reason?: SortOrder
    changedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type EnumLedgerSideFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerSide | EnumLedgerSideFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerSideFilter<$PrismaModel> | $Enums.LedgerSide
  }

  export type EnumLedgerEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryStatus | EnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryStatusFilter<$PrismaModel> | $Enums.LedgerEntryStatus
  }

  export type LedgerEntryCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    accountType?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
  }

  export type LedgerEntryAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type LedgerEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    accountType?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
  }

  export type LedgerEntryMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    accountType?: SortOrder
    side?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transactionType?: SortOrder
    description?: SortOrder
    referenceId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    settledAt?: SortOrder
  }

  export type LedgerEntrySumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumLedgerSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerSide | EnumLedgerSideFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerSideWithAggregatesFilter<$PrismaModel> | $Enums.LedgerSide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerSideFilter<$PrismaModel>
    _max?: NestedEnumLedgerSideFilter<$PrismaModel>
  }

  export type EnumLedgerEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryStatus | EnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryStatusFilter<$PrismaModel>
  }

  export type EnumDepositStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositStatusFilter<$PrismaModel> | $Enums.DepositStatus
  }

  export type DepositHoldCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentIntentId?: SortOrder
    status?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    releasedAt?: SortOrder
    deductedAmount?: SortOrder
    deductionReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DepositHoldAvgOrderByAggregateInput = {
    amount?: SortOrder
    deductedAmount?: SortOrder
  }

  export type DepositHoldMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentIntentId?: SortOrder
    status?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    releasedAt?: SortOrder
    deductedAmount?: SortOrder
    deductionReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DepositHoldMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    paymentIntentId?: SortOrder
    status?: SortOrder
    authorizedAt?: SortOrder
    capturedAt?: SortOrder
    releasedAt?: SortOrder
    deductedAmount?: SortOrder
    deductionReason?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type DepositHoldSumOrderByAggregateInput = {
    amount?: SortOrder
    deductedAmount?: SortOrder
  }

  export type EnumDepositStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type RefundCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    refundId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RefundMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    refundId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    refundId?: SortOrder
    status?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefundSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type EnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type PayoutCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transferId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type PayoutAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayoutMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transferId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type PayoutMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    transferId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
    paidAt?: SortOrder
  }

  export type PayoutSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type EnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }

  export type EnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type ReviewBookingIdReviewerIdTypeCompoundUniqueInput = {
    bookingId: string
    reviewerId: string
    type: $Enums.ReviewType
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    type?: SortOrder
    overallRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    cleanlinessRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    overallRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    cleanlinessRating?: SortOrder
    valueRating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    type?: SortOrder
    overallRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    cleanlinessRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    reviewerId?: SortOrder
    revieweeId?: SortOrder
    type?: SortOrder
    overallRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    cleanlinessRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    response?: SortOrder
    respondedAt?: SortOrder
    status?: SortOrder
    flagged?: SortOrder
    flagReason?: SortOrder
    moderatedBy?: SortOrder
    moderatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    overallRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    cleanlinessRating?: SortOrder
    valueRating?: SortOrder
  }

  export type EnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }

  export type EnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type EnumConversationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationType | EnumConversationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationTypeFilter<$PrismaModel> | $Enums.ConversationType
  }

  export type EnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    lastMessageAt?: SortOrder
    lastMessagePreview?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    lastMessageAt?: SortOrder
    lastMessagePreview?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    listingId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    lastMessageAt?: SortOrder
    lastMessagePreview?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumConversationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationType | EnumConversationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConversationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationTypeFilter<$PrismaModel>
    _max?: NestedEnumConversationTypeFilter<$PrismaModel>
  }

  export type EnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdUserIdCompoundUniqueInput = {
    conversationId: string
    userId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    muted?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    muted?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    muted?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type EnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type MessageReadReceiptListRelationFilter = {
    every?: MessageReadReceiptWhereInput
    some?: MessageReadReceiptWhereInput
    none?: MessageReadReceiptWhereInput
  }

  export type MessageReadReceiptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    metadata?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    content?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    editedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageReadReceiptMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageReadReceiptCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadReceiptMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadReceiptMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportPhotoListRelationFilter = {
    every?: ReportPhotoWhereInput
    some?: ReportPhotoWhereInput
    none?: ReportPhotoWhereInput
  }

  export type DisputeNullableScalarRelationFilter = {
    is?: DisputeWhereInput | null
    isNot?: DisputeWhereInput | null
  }

  export type ReportPhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConditionReportCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reportType?: SortOrder
    type?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    checklistData?: SortOrder
    overallCondition?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    damages?: SortOrder
    issuesFound?: SortOrder
    damageAmount?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    disputeRaised?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ConditionReportAvgOrderByAggregateInput = {
    damageAmount?: SortOrder
  }

  export type ConditionReportMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reportType?: SortOrder
    type?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    overallCondition?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    issuesFound?: SortOrder
    damageAmount?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    disputeRaised?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ConditionReportMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reportType?: SortOrder
    type?: SortOrder
    reportedBy?: SortOrder
    reportedAt?: SortOrder
    overallCondition?: SortOrder
    condition?: SortOrder
    notes?: SortOrder
    issuesFound?: SortOrder
    damageAmount?: SortOrder
    acknowledgedBy?: SortOrder
    acknowledgedAt?: SortOrder
    disputeRaised?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
  }

  export type ConditionReportSumOrderByAggregateInput = {
    damageAmount?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type ConditionReportScalarRelationFilter = {
    is?: ConditionReportWhereInput
    isNot?: ConditionReportWhereInput
  }

  export type ReportPhotoCountOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    order?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ReportPhotoAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ReportPhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ReportPhotoMinOrderByAggregateInput = {
    id?: SortOrder
    reportId?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    caption?: SortOrder
    order?: SortOrder
    uploadedAt?: SortOrder
  }

  export type ReportPhotoSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumDisputeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeFilter<$PrismaModel> | $Enums.DisputeType
  }

  export type EnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type EnumDisputePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputePriority | EnumDisputePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputePriorityFilter<$PrismaModel> | $Enums.DisputePriority
  }

  export type DisputeResolutionNullableScalarRelationFilter = {
    is?: DisputeResolutionWhereInput | null
    isNot?: DisputeResolutionWhereInput | null
  }

  export type ConditionReportNullableScalarRelationFilter = {
    is?: ConditionReportWhereInput | null
    isNot?: ConditionReportWhereInput | null
  }

  export type DisputeEvidenceListRelationFilter = {
    every?: DisputeEvidenceWhereInput
    some?: DisputeEvidenceWhereInput
    none?: DisputeEvidenceWhereInput
  }

  export type DisputeTimelineEventListRelationFilter = {
    every?: DisputeTimelineEventWhereInput
    some?: DisputeTimelineEventWhereInput
    none?: DisputeTimelineEventWhereInput
  }

  export type DisputeEvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisputeTimelineEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisputeCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    conditionReportId?: SortOrder
    initiatorId?: SortOrder
    defendantId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDeadline?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DisputeMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    conditionReportId?: SortOrder
    initiatorId?: SortOrder
    defendantId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDeadline?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    conditionReportId?: SortOrder
    initiatorId?: SortOrder
    defendantId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    slaDeadline?: SortOrder
    respondedAt?: SortOrder
    resolvedAt?: SortOrder
    assignedTo?: SortOrder
    assignedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DisputeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumDisputeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DisputeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeTypeFilter<$PrismaModel>
    _max?: NestedEnumDisputeTypeFilter<$PrismaModel>
  }

  export type EnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type EnumDisputePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputePriority | EnumDisputePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputePriorityWithAggregatesFilter<$PrismaModel> | $Enums.DisputePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputePriorityFilter<$PrismaModel>
    _max?: NestedEnumDisputePriorityFilter<$PrismaModel>
  }

  export type DisputeScalarRelationFilter = {
    is?: DisputeWhereInput
    isNot?: DisputeWhereInput
  }

  export type DisputeResponseCountOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
  }

  export type DisputeResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type DisputeResponseMinOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumEvidenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeFilter<$PrismaModel> | $Enums.EvidenceType
  }

  export type DisputeEvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    uploadedBy?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DisputeEvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    uploadedBy?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    uploadedAt?: SortOrder
  }

  export type DisputeEvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    uploadedBy?: SortOrder
    type?: SortOrder
    url?: SortOrder
    description?: SortOrder
    uploadedAt?: SortOrder
  }

  export type EnumEvidenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceTypeFilter<$PrismaModel>
    _max?: NestedEnumEvidenceTypeFilter<$PrismaModel>
  }

  export type DisputeTimelineEventCountOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type DisputeTimelineEventMaxOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type DisputeTimelineEventMinOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    eventType?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumResolutionOutcomeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResolutionOutcome | EnumResolutionOutcomeFieldRefInput<$PrismaModel>
    in?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    not?: NestedEnumResolutionOutcomeFilter<$PrismaModel> | $Enums.ResolutionOutcome
  }

  export type DisputeResolutionCountOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    outcome?: SortOrder
    summary?: SortOrder
    refundAmount?: SortOrder
    payoutAdjustment?: SortOrder
    actionsTaken?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type DisputeResolutionAvgOrderByAggregateInput = {
    refundAmount?: SortOrder
    payoutAdjustment?: SortOrder
  }

  export type DisputeResolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    outcome?: SortOrder
    summary?: SortOrder
    refundAmount?: SortOrder
    payoutAdjustment?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type DisputeResolutionMinOrderByAggregateInput = {
    id?: SortOrder
    disputeId?: SortOrder
    outcome?: SortOrder
    summary?: SortOrder
    refundAmount?: SortOrder
    payoutAdjustment?: SortOrder
    resolvedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type DisputeResolutionSumOrderByAggregateInput = {
    refundAmount?: SortOrder
    payoutAdjustment?: SortOrder
  }

  export type EnumResolutionOutcomeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResolutionOutcome | EnumResolutionOutcomeFieldRefInput<$PrismaModel>
    in?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    not?: NestedEnumResolutionOutcomeWithAggregatesFilter<$PrismaModel> | $Enums.ResolutionOutcome
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResolutionOutcomeFilter<$PrismaModel>
    _max?: NestedEnumResolutionOutcomeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    relatedId?: SortOrder
    relatedType?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    sentViaEmail?: SortOrder
    sentViaPush?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    relatedId?: SortOrder
    relatedType?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    sentViaEmail?: SortOrder
    sentViaPush?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    relatedId?: SortOrder
    relatedType?: SortOrder
    actionUrl?: SortOrder
    actionLabel?: SortOrder
    read?: SortOrder
    readAt?: SortOrder
    status?: SortOrder
    sentViaEmail?: SortOrder
    sentViaPush?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    metadata?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInsuranceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceStatus | EnumInsuranceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceStatusFilter<$PrismaModel> | $Enums.InsuranceStatus
  }

  export type ListingNullableScalarRelationFilter = {
    is?: ListingWhereInput | null
    isNot?: ListingWhereInput | null
  }

  export type InsurancePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    policyNumber?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    coverageAmount?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    documentUrl?: SortOrder
    certificateUrl?: SortOrder
    status?: SortOrder
    verificationDate?: SortOrder
    verifiedBy?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePolicyAvgOrderByAggregateInput = {
    coverageAmount?: SortOrder
  }

  export type InsurancePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    policyNumber?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    coverageAmount?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    documentUrl?: SortOrder
    certificateUrl?: SortOrder
    status?: SortOrder
    verificationDate?: SortOrder
    verifiedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    policyNumber?: SortOrder
    provider?: SortOrder
    type?: SortOrder
    coverageAmount?: SortOrder
    effectiveDate?: SortOrder
    expirationDate?: SortOrder
    documentUrl?: SortOrder
    certificateUrl?: SortOrder
    status?: SortOrder
    verificationDate?: SortOrder
    verifiedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsurancePolicySumOrderByAggregateInput = {
    coverageAmount?: SortOrder
  }

  export type EnumInsuranceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceStatus | EnumInsuranceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsuranceStatusFilter<$PrismaModel>
    _max?: NestedEnumInsuranceStatusFilter<$PrismaModel>
  }

  export type DeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    platform?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutRenterInput = {
    create?: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput> | BookingCreateWithoutRenterInput[] | BookingUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRenterInput | BookingCreateOrConnectWithoutRenterInput[]
    createMany?: BookingCreateManyRenterInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DisputeCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput> | DisputeCreateWithoutInitiatorInput[] | DisputeUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutInitiatorInput | DisputeCreateOrConnectWithoutInitiatorInput[]
    createMany?: DisputeCreateManyInitiatorInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type DisputeCreateNestedManyWithoutDefendantInput = {
    create?: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput> | DisputeCreateWithoutDefendantInput[] | DisputeUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutDefendantInput | DisputeCreateOrConnectWithoutDefendantInput[]
    createMany?: DisputeCreateManyDefendantInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type DisputeResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput> | DisputeResponseCreateWithoutUserInput[] | DisputeResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutUserInput | DisputeResponseCreateOrConnectWithoutUserInput[]
    createMany?: DisputeResponseCreateManyUserInputEnvelope
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
  }

  export type OrganizationMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type FavoriteListingCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput> | FavoriteListingCreateWithoutUserInput[] | FavoriteListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutUserInput | FavoriteListingCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteListingCreateManyUserInputEnvelope
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InsurancePolicyCreateNestedManyWithoutUserInput = {
    create?: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput> | InsurancePolicyCreateWithoutUserInput[] | InsurancePolicyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutUserInput | InsurancePolicyCreateOrConnectWithoutUserInput[]
    createMany?: InsurancePolicyCreateManyUserInputEnvelope
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
  }

  export type DeviceTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type ConditionReportCreateNestedManyWithoutReportedByUserInput = {
    create?: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput> | ConditionReportCreateWithoutReportedByUserInput[] | ConditionReportUncheckedCreateWithoutReportedByUserInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutReportedByUserInput | ConditionReportCreateOrConnectWithoutReportedByUserInput[]
    createMany?: ConditionReportCreateManyReportedByUserInputEnvelope
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutRenterInput = {
    create?: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput> | BookingCreateWithoutRenterInput[] | BookingUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRenterInput | BookingCreateOrConnectWithoutRenterInput[]
    createMany?: BookingCreateManyRenterInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutRevieweeInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedManyWithoutInitiatorInput = {
    create?: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput> | DisputeCreateWithoutInitiatorInput[] | DisputeUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutInitiatorInput | DisputeCreateOrConnectWithoutInitiatorInput[]
    createMany?: DisputeCreateManyInitiatorInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedManyWithoutDefendantInput = {
    create?: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput> | DisputeCreateWithoutDefendantInput[] | DisputeUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutDefendantInput | DisputeCreateOrConnectWithoutDefendantInput[]
    createMany?: DisputeCreateManyDefendantInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type DisputeResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput> | DisputeResponseCreateWithoutUserInput[] | DisputeResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutUserInput | DisputeResponseCreateOrConnectWithoutUserInput[]
    createMany?: DisputeResponseCreateManyUserInputEnvelope
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type FavoriteListingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput> | FavoriteListingCreateWithoutUserInput[] | FavoriteListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutUserInput | FavoriteListingCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteListingCreateManyUserInputEnvelope
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type InsurancePolicyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput> | InsurancePolicyCreateWithoutUserInput[] | InsurancePolicyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutUserInput | InsurancePolicyCreateOrConnectWithoutUserInput[]
    createMany?: InsurancePolicyCreateManyUserInputEnvelope
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
  }

  export type DeviceTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput = {
    create?: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput> | ConditionReportCreateWithoutReportedByUserInput[] | ConditionReportUncheckedCreateWithoutReportedByUserInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutReportedByUserInput | ConditionReportCreateOrConnectWithoutReportedByUserInput[]
    createMany?: ConditionReportCreateManyReportedByUserInputEnvelope
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumVerificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VerificationStatus
  }

  export type NullableEnumGovernmentIdTypeFieldUpdateOperationsInput = {
    set?: $Enums.GovernmentIdType | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOwnerInput | ListingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOwnerInput | ListingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOwnerInput | ListingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutRenterNestedInput = {
    create?: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput> | BookingCreateWithoutRenterInput[] | BookingUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRenterInput | BookingCreateOrConnectWithoutRenterInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRenterInput | BookingUpsertWithWhereUniqueWithoutRenterInput[]
    createMany?: BookingCreateManyRenterInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRenterInput | BookingUpdateWithWhereUniqueWithoutRenterInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRenterInput | BookingUpdateManyWithWhereWithoutRenterInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRevieweeInput | ReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRevieweeInput | ReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRevieweeInput | ReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DisputeUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput> | DisputeCreateWithoutInitiatorInput[] | DisputeUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutInitiatorInput | DisputeCreateOrConnectWithoutInitiatorInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutInitiatorInput | DisputeUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: DisputeCreateManyInitiatorInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutInitiatorInput | DisputeUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutInitiatorInput | DisputeUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type DisputeUpdateManyWithoutDefendantNestedInput = {
    create?: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput> | DisputeCreateWithoutDefendantInput[] | DisputeUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutDefendantInput | DisputeCreateOrConnectWithoutDefendantInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutDefendantInput | DisputeUpsertWithWhereUniqueWithoutDefendantInput[]
    createMany?: DisputeCreateManyDefendantInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutDefendantInput | DisputeUpdateWithWhereUniqueWithoutDefendantInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutDefendantInput | DisputeUpdateManyWithWhereWithoutDefendantInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type DisputeResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput> | DisputeResponseCreateWithoutUserInput[] | DisputeResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutUserInput | DisputeResponseCreateOrConnectWithoutUserInput[]
    upsert?: DisputeResponseUpsertWithWhereUniqueWithoutUserInput | DisputeResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DisputeResponseCreateManyUserInputEnvelope
    set?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    disconnect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    delete?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    update?: DisputeResponseUpdateWithWhereUniqueWithoutUserInput | DisputeResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DisputeResponseUpdateManyWithWhereWithoutUserInput | DisputeResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
  }

  export type OrganizationMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type FavoriteListingUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput> | FavoriteListingCreateWithoutUserInput[] | FavoriteListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutUserInput | FavoriteListingCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteListingUpsertWithWhereUniqueWithoutUserInput | FavoriteListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteListingCreateManyUserInputEnvelope
    set?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    disconnect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    delete?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    update?: FavoriteListingUpdateWithWhereUniqueWithoutUserInput | FavoriteListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteListingUpdateManyWithWhereWithoutUserInput | FavoriteListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InsurancePolicyUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput> | InsurancePolicyCreateWithoutUserInput[] | InsurancePolicyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutUserInput | InsurancePolicyCreateOrConnectWithoutUserInput[]
    upsert?: InsurancePolicyUpsertWithWhereUniqueWithoutUserInput | InsurancePolicyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsurancePolicyCreateManyUserInputEnvelope
    set?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    disconnect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    delete?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    update?: InsurancePolicyUpdateWithWhereUniqueWithoutUserInput | InsurancePolicyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsurancePolicyUpdateManyWithWhereWithoutUserInput | InsurancePolicyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
  }

  export type DeviceTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type ConditionReportUpdateManyWithoutReportedByUserNestedInput = {
    create?: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput> | ConditionReportCreateWithoutReportedByUserInput[] | ConditionReportUncheckedCreateWithoutReportedByUserInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutReportedByUserInput | ConditionReportCreateOrConnectWithoutReportedByUserInput[]
    upsert?: ConditionReportUpsertWithWhereUniqueWithoutReportedByUserInput | ConditionReportUpsertWithWhereUniqueWithoutReportedByUserInput[]
    createMany?: ConditionReportCreateManyReportedByUserInputEnvelope
    set?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    disconnect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    delete?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    update?: ConditionReportUpdateWithWhereUniqueWithoutReportedByUserInput | ConditionReportUpdateWithWhereUniqueWithoutReportedByUserInput[]
    updateMany?: ConditionReportUpdateManyWithWhereWithoutReportedByUserInput | ConditionReportUpdateManyWithWhereWithoutReportedByUserInput[]
    deleteMany?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput> | ListingCreateWithoutOwnerInput[] | ListingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOwnerInput | ListingCreateOrConnectWithoutOwnerInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOwnerInput | ListingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ListingCreateManyOwnerInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOwnerInput | ListingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOwnerInput | ListingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutRenterNestedInput = {
    create?: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput> | BookingCreateWithoutRenterInput[] | BookingUncheckedCreateWithoutRenterInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRenterInput | BookingCreateOrConnectWithoutRenterInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRenterInput | BookingUpsertWithWhereUniqueWithoutRenterInput[]
    createMany?: BookingCreateManyRenterInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRenterInput | BookingUpdateWithWhereUniqueWithoutRenterInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRenterInput | BookingUpdateManyWithWhereWithoutRenterInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput> | BookingCreateWithoutOwnerInput[] | BookingUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOwnerInput | BookingCreateOrConnectWithoutOwnerInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOwnerInput | BookingUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: BookingCreateManyOwnerInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOwnerInput | BookingUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOwnerInput | BookingUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput> | ReviewCreateWithoutReviewerInput[] | ReviewUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutReviewerInput | ReviewCreateOrConnectWithoutReviewerInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutReviewerInput | ReviewUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: ReviewCreateManyReviewerInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutReviewerInput | ReviewUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutReviewerInput | ReviewUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutRevieweeNestedInput = {
    create?: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput> | ReviewCreateWithoutRevieweeInput[] | ReviewUncheckedCreateWithoutRevieweeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRevieweeInput | ReviewCreateOrConnectWithoutRevieweeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRevieweeInput | ReviewUpsertWithWhereUniqueWithoutRevieweeInput[]
    createMany?: ReviewCreateManyRevieweeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRevieweeInput | ReviewUpdateWithWhereUniqueWithoutRevieweeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRevieweeInput | ReviewUpdateManyWithWhereWithoutRevieweeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput> | ConversationParticipantCreateWithoutUserInput[] | ConversationParticipantUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutUserInput | ConversationParticipantCreateOrConnectWithoutUserInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutUserInput | ConversationParticipantUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationParticipantCreateManyUserInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutUserInput | ConversationParticipantUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutUserInput | ConversationParticipantUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateManyWithoutInitiatorNestedInput = {
    create?: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput> | DisputeCreateWithoutInitiatorInput[] | DisputeUncheckedCreateWithoutInitiatorInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutInitiatorInput | DisputeCreateOrConnectWithoutInitiatorInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutInitiatorInput | DisputeUpsertWithWhereUniqueWithoutInitiatorInput[]
    createMany?: DisputeCreateManyInitiatorInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutInitiatorInput | DisputeUpdateWithWhereUniqueWithoutInitiatorInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutInitiatorInput | DisputeUpdateManyWithWhereWithoutInitiatorInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateManyWithoutDefendantNestedInput = {
    create?: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput> | DisputeCreateWithoutDefendantInput[] | DisputeUncheckedCreateWithoutDefendantInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutDefendantInput | DisputeCreateOrConnectWithoutDefendantInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutDefendantInput | DisputeUpsertWithWhereUniqueWithoutDefendantInput[]
    createMany?: DisputeCreateManyDefendantInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutDefendantInput | DisputeUpdateWithWhereUniqueWithoutDefendantInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutDefendantInput | DisputeUpdateManyWithWhereWithoutDefendantInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type DisputeResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput> | DisputeResponseCreateWithoutUserInput[] | DisputeResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutUserInput | DisputeResponseCreateOrConnectWithoutUserInput[]
    upsert?: DisputeResponseUpsertWithWhereUniqueWithoutUserInput | DisputeResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DisputeResponseCreateManyUserInputEnvelope
    set?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    disconnect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    delete?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    update?: DisputeResponseUpdateWithWhereUniqueWithoutUserInput | DisputeResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DisputeResponseUpdateManyWithWhereWithoutUserInput | DisputeResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput> | OrganizationMemberCreateWithoutUserInput[] | OrganizationMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutUserInput | OrganizationMemberCreateOrConnectWithoutUserInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutUserInput | OrganizationMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OrganizationMemberCreateManyUserInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutUserInput | OrganizationMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutUserInput | OrganizationMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type FavoriteListingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput> | FavoriteListingCreateWithoutUserInput[] | FavoriteListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutUserInput | FavoriteListingCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteListingUpsertWithWhereUniqueWithoutUserInput | FavoriteListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteListingCreateManyUserInputEnvelope
    set?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    disconnect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    delete?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    update?: FavoriteListingUpdateWithWhereUniqueWithoutUserInput | FavoriteListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteListingUpdateManyWithWhereWithoutUserInput | FavoriteListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput> | InsurancePolicyCreateWithoutUserInput[] | InsurancePolicyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutUserInput | InsurancePolicyCreateOrConnectWithoutUserInput[]
    upsert?: InsurancePolicyUpsertWithWhereUniqueWithoutUserInput | InsurancePolicyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsurancePolicyCreateManyUserInputEnvelope
    set?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    disconnect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    delete?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    update?: InsurancePolicyUpdateWithWhereUniqueWithoutUserInput | InsurancePolicyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsurancePolicyUpdateManyWithWhereWithoutUserInput | InsurancePolicyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput> | DeviceTokenCreateWithoutUserInput[] | DeviceTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutUserInput | DeviceTokenCreateOrConnectWithoutUserInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutUserInput | DeviceTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceTokenCreateManyUserInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutUserInput | DeviceTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutUserInput | DeviceTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput = {
    create?: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput> | ConditionReportCreateWithoutReportedByUserInput[] | ConditionReportUncheckedCreateWithoutReportedByUserInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutReportedByUserInput | ConditionReportCreateOrConnectWithoutReportedByUserInput[]
    upsert?: ConditionReportUpsertWithWhereUniqueWithoutReportedByUserInput | ConditionReportUpsertWithWhereUniqueWithoutReportedByUserInput[]
    createMany?: ConditionReportCreateManyReportedByUserInputEnvelope
    set?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    disconnect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    delete?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    update?: ConditionReportUpdateWithWhereUniqueWithoutReportedByUserInput | ConditionReportUpdateWithWhereUniqueWithoutReportedByUserInput[]
    updateMany?: ConditionReportUpdateManyWithWhereWithoutReportedByUserInput | ConditionReportUpdateManyWithWhereWithoutReportedByUserInput[]
    deleteMany?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type OrganizationMemberCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type ListingCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput> | ListingCreateWithoutOrganizationInput[] | ListingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOrganizationInput | ListingCreateOrConnectWithoutOrganizationInput[]
    createMany?: ListingCreateManyOrganizationInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput> | ListingCreateWithoutOrganizationInput[] | ListingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOrganizationInput | ListingCreateOrConnectWithoutOrganizationInput[]
    createMany?: ListingCreateManyOrganizationInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type EnumOrganizationStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrganizationStatus
  }

  export type OrganizationMemberUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type ListingUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput> | ListingCreateWithoutOrganizationInput[] | ListingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOrganizationInput | ListingCreateOrConnectWithoutOrganizationInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOrganizationInput | ListingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ListingCreateManyOrganizationInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOrganizationInput | ListingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOrganizationInput | ListingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput> | OrganizationMemberCreateWithoutOrganizationInput[] | OrganizationMemberUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: OrganizationMemberCreateOrConnectWithoutOrganizationInput | OrganizationMemberCreateOrConnectWithoutOrganizationInput[]
    upsert?: OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: OrganizationMemberCreateManyOrganizationInputEnvelope
    set?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    disconnect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    delete?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    connect?: OrganizationMemberWhereUniqueInput | OrganizationMemberWhereUniqueInput[]
    update?: OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput | OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput | OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput> | ListingCreateWithoutOrganizationInput[] | ListingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutOrganizationInput | ListingCreateOrConnectWithoutOrganizationInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutOrganizationInput | ListingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ListingCreateManyOrganizationInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutOrganizationInput | ListingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutOrganizationInput | ListingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrganizationsInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumOrgRoleFieldUpdateOperationsInput = {
    set?: $Enums.OrgRole
  }

  export type OrganizationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMembersInput
    upsert?: OrganizationUpsertWithoutMembersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMembersInput, OrganizationUpdateWithoutMembersInput>, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutOrganizationsNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationsInput
    upsert?: UserUpsertWithoutOrganizationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrganizationsInput, UserUpdateWithoutOrganizationsInput>, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type ListingCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type EnumPricingModeFieldUpdateOperationsInput = {
    set?: $Enums.PricingMode
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ListingUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoryInput | ListingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoryInput | ListingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoryInput | ListingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoryInput | ListingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoryInput | ListingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoryInput | ListingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutListingsInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutListingsInput = {
    create?: XOR<OrganizationCreateWithoutListingsInput, OrganizationUncheckedCreateWithoutListingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutListingsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutListingsInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    connect?: CategoryWhereUniqueInput
  }

  export type CancellationPolicyCreateNestedOneWithoutListingsInput = {
    create?: XOR<CancellationPolicyCreateWithoutListingsInput, CancellationPolicyUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutListingsInput
    connect?: CancellationPolicyWhereUniqueInput
  }

  export type AvailabilityCreateNestedManyWithoutListingInput = {
    create?: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput> | AvailabilityCreateWithoutListingInput[] | AvailabilityUncheckedCreateWithoutListingInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutListingInput | AvailabilityCreateOrConnectWithoutListingInput[]
    createMany?: AvailabilityCreateManyListingInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutListingInput = {
    create?: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput> | BookingCreateWithoutListingInput[] | BookingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutListingInput | BookingCreateOrConnectWithoutListingInput[]
    createMany?: BookingCreateManyListingInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutListingInput = {
    create?: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput> | ReviewCreateWithoutListingInput[] | ReviewUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutListingInput | ReviewCreateOrConnectWithoutListingInput[]
    createMany?: ReviewCreateManyListingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type FavoriteListingCreateNestedManyWithoutListingInput = {
    create?: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput> | FavoriteListingCreateWithoutListingInput[] | FavoriteListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutListingInput | FavoriteListingCreateOrConnectWithoutListingInput[]
    createMany?: FavoriteListingCreateManyListingInputEnvelope
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
  }

  export type InsurancePolicyCreateNestedManyWithoutListingInput = {
    create?: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput> | InsurancePolicyCreateWithoutListingInput[] | InsurancePolicyUncheckedCreateWithoutListingInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutListingInput | InsurancePolicyCreateOrConnectWithoutListingInput[]
    createMany?: InsurancePolicyCreateManyListingInputEnvelope
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
  }

  export type AvailabilityUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput> | AvailabilityCreateWithoutListingInput[] | AvailabilityUncheckedCreateWithoutListingInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutListingInput | AvailabilityCreateOrConnectWithoutListingInput[]
    createMany?: AvailabilityCreateManyListingInputEnvelope
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput> | BookingCreateWithoutListingInput[] | BookingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutListingInput | BookingCreateOrConnectWithoutListingInput[]
    createMany?: BookingCreateManyListingInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput> | ReviewCreateWithoutListingInput[] | ReviewUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutListingInput | ReviewCreateOrConnectWithoutListingInput[]
    createMany?: ReviewCreateManyListingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type FavoriteListingUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput> | FavoriteListingCreateWithoutListingInput[] | FavoriteListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutListingInput | FavoriteListingCreateOrConnectWithoutListingInput[]
    createMany?: FavoriteListingCreateManyListingInputEnvelope
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
  }

  export type InsurancePolicyUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput> | InsurancePolicyCreateWithoutListingInput[] | InsurancePolicyUncheckedCreateWithoutListingInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutListingInput | InsurancePolicyCreateOrConnectWithoutListingInput[]
    createMany?: InsurancePolicyCreateManyListingInputEnvelope
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
  }

  export type NullableEnumDepositTypeFieldUpdateOperationsInput = {
    set?: $Enums.DepositType | null
  }

  export type EnumBookingModeFieldUpdateOperationsInput = {
    set?: $Enums.BookingMode
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumListingConditionFieldUpdateOperationsInput = {
    set?: $Enums.ListingCondition | null
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type UserUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    upsert?: UserUpsertWithoutListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutListingsInput, UserUpdateWithoutListingsInput>, UserUncheckedUpdateWithoutListingsInput>
  }

  export type OrganizationUpdateOneWithoutListingsNestedInput = {
    create?: XOR<OrganizationCreateWithoutListingsInput, OrganizationUncheckedCreateWithoutListingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutListingsInput
    upsert?: OrganizationUpsertWithoutListingsInput
    disconnect?: OrganizationWhereInput | boolean
    delete?: OrganizationWhereInput | boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutListingsInput, OrganizationUpdateWithoutListingsInput>, OrganizationUncheckedUpdateWithoutListingsInput>
  }

  export type CategoryUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    upsert?: CategoryUpsertWithoutListingsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutListingsInput, CategoryUpdateWithoutListingsInput>, CategoryUncheckedUpdateWithoutListingsInput>
  }

  export type CancellationPolicyUpdateOneWithoutListingsNestedInput = {
    create?: XOR<CancellationPolicyCreateWithoutListingsInput, CancellationPolicyUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CancellationPolicyCreateOrConnectWithoutListingsInput
    upsert?: CancellationPolicyUpsertWithoutListingsInput
    disconnect?: CancellationPolicyWhereInput | boolean
    delete?: CancellationPolicyWhereInput | boolean
    connect?: CancellationPolicyWhereUniqueInput
    update?: XOR<XOR<CancellationPolicyUpdateToOneWithWhereWithoutListingsInput, CancellationPolicyUpdateWithoutListingsInput>, CancellationPolicyUncheckedUpdateWithoutListingsInput>
  }

  export type AvailabilityUpdateManyWithoutListingNestedInput = {
    create?: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput> | AvailabilityCreateWithoutListingInput[] | AvailabilityUncheckedCreateWithoutListingInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutListingInput | AvailabilityCreateOrConnectWithoutListingInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutListingInput | AvailabilityUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: AvailabilityCreateManyListingInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutListingInput | AvailabilityUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutListingInput | AvailabilityUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutListingNestedInput = {
    create?: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput> | BookingCreateWithoutListingInput[] | BookingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutListingInput | BookingCreateOrConnectWithoutListingInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutListingInput | BookingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BookingCreateManyListingInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutListingInput | BookingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutListingInput | BookingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutListingNestedInput = {
    create?: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput> | ReviewCreateWithoutListingInput[] | ReviewUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutListingInput | ReviewCreateOrConnectWithoutListingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutListingInput | ReviewUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ReviewCreateManyListingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutListingInput | ReviewUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutListingInput | ReviewUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type FavoriteListingUpdateManyWithoutListingNestedInput = {
    create?: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput> | FavoriteListingCreateWithoutListingInput[] | FavoriteListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutListingInput | FavoriteListingCreateOrConnectWithoutListingInput[]
    upsert?: FavoriteListingUpsertWithWhereUniqueWithoutListingInput | FavoriteListingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: FavoriteListingCreateManyListingInputEnvelope
    set?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    disconnect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    delete?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    update?: FavoriteListingUpdateWithWhereUniqueWithoutListingInput | FavoriteListingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: FavoriteListingUpdateManyWithWhereWithoutListingInput | FavoriteListingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
  }

  export type InsurancePolicyUpdateManyWithoutListingNestedInput = {
    create?: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput> | InsurancePolicyCreateWithoutListingInput[] | InsurancePolicyUncheckedCreateWithoutListingInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutListingInput | InsurancePolicyCreateOrConnectWithoutListingInput[]
    upsert?: InsurancePolicyUpsertWithWhereUniqueWithoutListingInput | InsurancePolicyUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: InsurancePolicyCreateManyListingInputEnvelope
    set?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    disconnect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    delete?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    update?: InsurancePolicyUpdateWithWhereUniqueWithoutListingInput | InsurancePolicyUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: InsurancePolicyUpdateManyWithWhereWithoutListingInput | InsurancePolicyUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
  }

  export type AvailabilityUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput> | AvailabilityCreateWithoutListingInput[] | AvailabilityUncheckedCreateWithoutListingInput[]
    connectOrCreate?: AvailabilityCreateOrConnectWithoutListingInput | AvailabilityCreateOrConnectWithoutListingInput[]
    upsert?: AvailabilityUpsertWithWhereUniqueWithoutListingInput | AvailabilityUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: AvailabilityCreateManyListingInputEnvelope
    set?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    disconnect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    delete?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    connect?: AvailabilityWhereUniqueInput | AvailabilityWhereUniqueInput[]
    update?: AvailabilityUpdateWithWhereUniqueWithoutListingInput | AvailabilityUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: AvailabilityUpdateManyWithWhereWithoutListingInput | AvailabilityUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput> | BookingCreateWithoutListingInput[] | BookingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutListingInput | BookingCreateOrConnectWithoutListingInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutListingInput | BookingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: BookingCreateManyListingInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutListingInput | BookingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutListingInput | BookingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput> | ReviewCreateWithoutListingInput[] | ReviewUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutListingInput | ReviewCreateOrConnectWithoutListingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutListingInput | ReviewUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ReviewCreateManyListingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutListingInput | ReviewUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutListingInput | ReviewUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type FavoriteListingUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput> | FavoriteListingCreateWithoutListingInput[] | FavoriteListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: FavoriteListingCreateOrConnectWithoutListingInput | FavoriteListingCreateOrConnectWithoutListingInput[]
    upsert?: FavoriteListingUpsertWithWhereUniqueWithoutListingInput | FavoriteListingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: FavoriteListingCreateManyListingInputEnvelope
    set?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    disconnect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    delete?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    connect?: FavoriteListingWhereUniqueInput | FavoriteListingWhereUniqueInput[]
    update?: FavoriteListingUpdateWithWhereUniqueWithoutListingInput | FavoriteListingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: FavoriteListingUpdateManyWithWhereWithoutListingInput | FavoriteListingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
  }

  export type InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput> | InsurancePolicyCreateWithoutListingInput[] | InsurancePolicyUncheckedCreateWithoutListingInput[]
    connectOrCreate?: InsurancePolicyCreateOrConnectWithoutListingInput | InsurancePolicyCreateOrConnectWithoutListingInput[]
    upsert?: InsurancePolicyUpsertWithWhereUniqueWithoutListingInput | InsurancePolicyUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: InsurancePolicyCreateManyListingInputEnvelope
    set?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    disconnect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    delete?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    connect?: InsurancePolicyWhereUniqueInput | InsurancePolicyWhereUniqueInput[]
    update?: InsurancePolicyUpdateWithWhereUniqueWithoutListingInput | InsurancePolicyUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: InsurancePolicyUpdateManyWithWhereWithoutListingInput | InsurancePolicyUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
  }

  export type ListingCreateNestedManyWithoutCancellationPolicyInput = {
    create?: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput> | ListingCreateWithoutCancellationPolicyInput[] | ListingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCancellationPolicyInput | ListingCreateOrConnectWithoutCancellationPolicyInput[]
    createMany?: ListingCreateManyCancellationPolicyInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutCancellationPolicyInput = {
    create?: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput> | ListingCreateWithoutCancellationPolicyInput[] | ListingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCancellationPolicyInput | ListingCreateOrConnectWithoutCancellationPolicyInput[]
    createMany?: ListingCreateManyCancellationPolicyInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type EnumCancellationPolicyTypeFieldUpdateOperationsInput = {
    set?: $Enums.CancellationPolicyType
  }

  export type ListingUpdateManyWithoutCancellationPolicyNestedInput = {
    create?: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput> | ListingCreateWithoutCancellationPolicyInput[] | ListingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCancellationPolicyInput | ListingCreateOrConnectWithoutCancellationPolicyInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCancellationPolicyInput | ListingUpsertWithWhereUniqueWithoutCancellationPolicyInput[]
    createMany?: ListingCreateManyCancellationPolicyInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCancellationPolicyInput | ListingUpdateWithWhereUniqueWithoutCancellationPolicyInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCancellationPolicyInput | ListingUpdateManyWithWhereWithoutCancellationPolicyInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutCancellationPolicyNestedInput = {
    create?: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput> | ListingCreateWithoutCancellationPolicyInput[] | ListingUncheckedCreateWithoutCancellationPolicyInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCancellationPolicyInput | ListingCreateOrConnectWithoutCancellationPolicyInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCancellationPolicyInput | ListingUpsertWithWhereUniqueWithoutCancellationPolicyInput[]
    createMany?: ListingCreateManyCancellationPolicyInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCancellationPolicyInput | ListingUpdateWithWhereUniqueWithoutCancellationPolicyInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCancellationPolicyInput | ListingUpdateManyWithWhereWithoutCancellationPolicyInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<ListingCreateWithoutAvailabilityInput, ListingUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ListingCreateOrConnectWithoutAvailabilityInput
    connect?: ListingWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<ListingCreateWithoutAvailabilityInput, ListingUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: ListingCreateOrConnectWithoutAvailabilityInput
    upsert?: ListingUpsertWithoutAvailabilityInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutAvailabilityInput, ListingUpdateWithoutAvailabilityInput>, ListingUncheckedUpdateWithoutAvailabilityInput>
  }

  export type UserCreateNestedOneWithoutFavoriteListingsInput = {
    create?: XOR<UserCreateWithoutFavoriteListingsInput, UserUncheckedCreateWithoutFavoriteListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteListingsInput
    connect?: UserWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutFavoritesInput
    connect?: ListingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoriteListingsNestedInput = {
    create?: XOR<UserCreateWithoutFavoriteListingsInput, UserUncheckedCreateWithoutFavoriteListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoriteListingsInput
    upsert?: UserUpsertWithoutFavoriteListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoriteListingsInput, UserUpdateWithoutFavoriteListingsInput>, UserUncheckedUpdateWithoutFavoriteListingsInput>
  }

  export type ListingUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutFavoritesInput
    upsert?: ListingUpsertWithoutFavoritesInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutFavoritesInput, ListingUpdateWithoutFavoritesInput>, ListingUncheckedUpdateWithoutFavoritesInput>
  }

  export type ListingCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ListingCreateWithoutBookingsInput, ListingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutBookingsInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsAsRenterInput = {
    create?: XOR<UserCreateWithoutBookingsAsRenterInput, UserUncheckedCreateWithoutBookingsAsRenterInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsRenterInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsAsOwnerInput = {
    create?: XOR<UserCreateWithoutBookingsAsOwnerInput, UserUncheckedCreateWithoutBookingsAsOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsOwnerInput
    connect?: UserWhereUniqueInput
  }

  export type BookingStateHistoryCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput> | BookingStateHistoryCreateWithoutBookingInput[] | BookingStateHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStateHistoryCreateOrConnectWithoutBookingInput | BookingStateHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStateHistoryCreateManyBookingInputEnvelope
    connect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
  }

  export type LedgerEntryCreateNestedManyWithoutBookingInput = {
    create?: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput> | LedgerEntryCreateWithoutBookingInput[] | LedgerEntryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBookingInput | LedgerEntryCreateOrConnectWithoutBookingInput[]
    createMany?: LedgerEntryCreateManyBookingInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type DepositHoldCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DepositHoldCreateWithoutBookingsInput, DepositHoldUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DepositHoldCreateOrConnectWithoutBookingsInput
    connect?: DepositHoldWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ConditionReportCreateNestedManyWithoutBookingInput = {
    create?: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput> | ConditionReportCreateWithoutBookingInput[] | ConditionReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutBookingInput | ConditionReportCreateOrConnectWithoutBookingInput[]
    createMany?: ConditionReportCreateManyBookingInputEnvelope
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DisputeCreateNestedManyWithoutBookingInput = {
    create?: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput> | DisputeCreateWithoutBookingInput[] | DisputeUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBookingInput | DisputeCreateOrConnectWithoutBookingInput[]
    createMany?: DisputeCreateManyBookingInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutBookingInput = {
    create?: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput> | ConversationCreateWithoutBookingInput[] | ConversationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutBookingInput | ConversationCreateOrConnectWithoutBookingInput[]
    createMany?: ConversationCreateManyBookingInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput> | BookingStateHistoryCreateWithoutBookingInput[] | BookingStateHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStateHistoryCreateOrConnectWithoutBookingInput | BookingStateHistoryCreateOrConnectWithoutBookingInput[]
    createMany?: BookingStateHistoryCreateManyBookingInputEnvelope
    connect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
  }

  export type LedgerEntryUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput> | LedgerEntryCreateWithoutBookingInput[] | LedgerEntryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBookingInput | LedgerEntryCreateOrConnectWithoutBookingInput[]
    createMany?: LedgerEntryCreateManyBookingInputEnvelope
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ConditionReportUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput> | ConditionReportCreateWithoutBookingInput[] | ConditionReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutBookingInput | ConditionReportCreateOrConnectWithoutBookingInput[]
    createMany?: ConditionReportCreateManyBookingInputEnvelope
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput> | DisputeCreateWithoutBookingInput[] | DisputeUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBookingInput | DisputeCreateOrConnectWithoutBookingInput[]
    createMany?: DisputeCreateManyBookingInputEnvelope
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput> | ConversationCreateWithoutBookingInput[] | ConversationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutBookingInput | ConversationCreateOrConnectWithoutBookingInput[]
    createMany?: ConversationCreateManyBookingInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type ListingUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ListingCreateWithoutBookingsInput, ListingUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutBookingsInput
    upsert?: ListingUpsertWithoutBookingsInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutBookingsInput, ListingUpdateWithoutBookingsInput>, ListingUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput = {
    create?: XOR<UserCreateWithoutBookingsAsRenterInput, UserUncheckedCreateWithoutBookingsAsRenterInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsRenterInput
    upsert?: UserUpsertWithoutBookingsAsRenterInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsAsRenterInput, UserUpdateWithoutBookingsAsRenterInput>, UserUncheckedUpdateWithoutBookingsAsRenterInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput = {
    create?: XOR<UserCreateWithoutBookingsAsOwnerInput, UserUncheckedCreateWithoutBookingsAsOwnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsAsOwnerInput
    upsert?: UserUpsertWithoutBookingsAsOwnerInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsAsOwnerInput, UserUpdateWithoutBookingsAsOwnerInput>, UserUncheckedUpdateWithoutBookingsAsOwnerInput>
  }

  export type BookingStateHistoryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput> | BookingStateHistoryCreateWithoutBookingInput[] | BookingStateHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStateHistoryCreateOrConnectWithoutBookingInput | BookingStateHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStateHistoryUpsertWithWhereUniqueWithoutBookingInput | BookingStateHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStateHistoryCreateManyBookingInputEnvelope
    set?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    disconnect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    delete?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    connect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    update?: BookingStateHistoryUpdateWithWhereUniqueWithoutBookingInput | BookingStateHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStateHistoryUpdateManyWithWhereWithoutBookingInput | BookingStateHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStateHistoryScalarWhereInput | BookingStateHistoryScalarWhereInput[]
  }

  export type LedgerEntryUpdateManyWithoutBookingNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput> | LedgerEntryCreateWithoutBookingInput[] | LedgerEntryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBookingInput | LedgerEntryCreateOrConnectWithoutBookingInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBookingInput | LedgerEntryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: LedgerEntryCreateManyBookingInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBookingInput | LedgerEntryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBookingInput | LedgerEntryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type DepositHoldUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DepositHoldCreateWithoutBookingsInput, DepositHoldUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DepositHoldCreateOrConnectWithoutBookingsInput
    upsert?: DepositHoldUpsertWithoutBookingsInput
    disconnect?: DepositHoldWhereInput | boolean
    delete?: DepositHoldWhereInput | boolean
    connect?: DepositHoldWhereUniqueInput
    update?: XOR<XOR<DepositHoldUpdateToOneWithWhereWithoutBookingsInput, DepositHoldUpdateWithoutBookingsInput>, DepositHoldUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ConditionReportUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput> | ConditionReportCreateWithoutBookingInput[] | ConditionReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutBookingInput | ConditionReportCreateOrConnectWithoutBookingInput[]
    upsert?: ConditionReportUpsertWithWhereUniqueWithoutBookingInput | ConditionReportUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ConditionReportCreateManyBookingInputEnvelope
    set?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    disconnect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    delete?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    update?: ConditionReportUpdateWithWhereUniqueWithoutBookingInput | ConditionReportUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ConditionReportUpdateManyWithWhereWithoutBookingInput | ConditionReportUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DisputeUpdateManyWithoutBookingNestedInput = {
    create?: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput> | DisputeCreateWithoutBookingInput[] | DisputeUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBookingInput | DisputeCreateOrConnectWithoutBookingInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutBookingInput | DisputeUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: DisputeCreateManyBookingInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutBookingInput | DisputeUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutBookingInput | DisputeUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput> | ConversationCreateWithoutBookingInput[] | ConversationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutBookingInput | ConversationCreateOrConnectWithoutBookingInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutBookingInput | ConversationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ConversationCreateManyBookingInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutBookingInput | ConversationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutBookingInput | ConversationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput> | BookingStateHistoryCreateWithoutBookingInput[] | BookingStateHistoryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: BookingStateHistoryCreateOrConnectWithoutBookingInput | BookingStateHistoryCreateOrConnectWithoutBookingInput[]
    upsert?: BookingStateHistoryUpsertWithWhereUniqueWithoutBookingInput | BookingStateHistoryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: BookingStateHistoryCreateManyBookingInputEnvelope
    set?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    disconnect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    delete?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    connect?: BookingStateHistoryWhereUniqueInput | BookingStateHistoryWhereUniqueInput[]
    update?: BookingStateHistoryUpdateWithWhereUniqueWithoutBookingInput | BookingStateHistoryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: BookingStateHistoryUpdateManyWithWhereWithoutBookingInput | BookingStateHistoryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: BookingStateHistoryScalarWhereInput | BookingStateHistoryScalarWhereInput[]
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput> | LedgerEntryCreateWithoutBookingInput[] | LedgerEntryUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LedgerEntryCreateOrConnectWithoutBookingInput | LedgerEntryCreateOrConnectWithoutBookingInput[]
    upsert?: LedgerEntryUpsertWithWhereUniqueWithoutBookingInput | LedgerEntryUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: LedgerEntryCreateManyBookingInputEnvelope
    set?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    disconnect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    delete?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    connect?: LedgerEntryWhereUniqueInput | LedgerEntryWhereUniqueInput[]
    update?: LedgerEntryUpdateWithWhereUniqueWithoutBookingInput | LedgerEntryUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: LedgerEntryUpdateManyWithWhereWithoutBookingInput | LedgerEntryUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ConditionReportUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput> | ConditionReportCreateWithoutBookingInput[] | ConditionReportUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConditionReportCreateOrConnectWithoutBookingInput | ConditionReportCreateOrConnectWithoutBookingInput[]
    upsert?: ConditionReportUpsertWithWhereUniqueWithoutBookingInput | ConditionReportUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ConditionReportCreateManyBookingInputEnvelope
    set?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    disconnect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    delete?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    connect?: ConditionReportWhereUniqueInput | ConditionReportWhereUniqueInput[]
    update?: ConditionReportUpdateWithWhereUniqueWithoutBookingInput | ConditionReportUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ConditionReportUpdateManyWithWhereWithoutBookingInput | ConditionReportUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput> | DisputeCreateWithoutBookingInput[] | DisputeUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: DisputeCreateOrConnectWithoutBookingInput | DisputeCreateOrConnectWithoutBookingInput[]
    upsert?: DisputeUpsertWithWhereUniqueWithoutBookingInput | DisputeUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: DisputeCreateManyBookingInputEnvelope
    set?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    disconnect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    delete?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    connect?: DisputeWhereUniqueInput | DisputeWhereUniqueInput[]
    update?: DisputeUpdateWithWhereUniqueWithoutBookingInput | DisputeUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: DisputeUpdateManyWithWhereWithoutBookingInput | DisputeUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput> | ConversationCreateWithoutBookingInput[] | ConversationUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutBookingInput | ConversationCreateOrConnectWithoutBookingInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutBookingInput | ConversationUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ConversationCreateManyBookingInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutBookingInput | ConversationUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutBookingInput | ConversationUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutStateHistoryInput = {
    create?: XOR<BookingCreateWithoutStateHistoryInput, BookingUncheckedCreateWithoutStateHistoryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutStateHistoryInput
    connect?: BookingWhereUniqueInput
  }

  export type NullableEnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus | null
  }

  export type BookingUpdateOneRequiredWithoutStateHistoryNestedInput = {
    create?: XOR<BookingCreateWithoutStateHistoryInput, BookingUncheckedCreateWithoutStateHistoryInput>
    connectOrCreate?: BookingCreateOrConnectWithoutStateHistoryInput
    upsert?: BookingUpsertWithoutStateHistoryInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutStateHistoryInput, BookingUpdateWithoutStateHistoryInput>, BookingUncheckedUpdateWithoutStateHistoryInput>
  }

  export type BookingCreateNestedOneWithoutLedgerEntriesInput = {
    create?: XOR<BookingCreateWithoutLedgerEntriesInput, BookingUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutLedgerEntriesInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumLedgerSideFieldUpdateOperationsInput = {
    set?: $Enums.LedgerSide
  }

  export type EnumLedgerEntryStatusFieldUpdateOperationsInput = {
    set?: $Enums.LedgerEntryStatus
  }

  export type BookingUpdateOneRequiredWithoutLedgerEntriesNestedInput = {
    create?: XOR<BookingCreateWithoutLedgerEntriesInput, BookingUncheckedCreateWithoutLedgerEntriesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutLedgerEntriesInput
    upsert?: BookingUpsertWithoutLedgerEntriesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutLedgerEntriesInput, BookingUpdateWithoutLedgerEntriesInput>, BookingUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type BookingCreateNestedManyWithoutDepositHoldInput = {
    create?: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput> | BookingCreateWithoutDepositHoldInput[] | BookingUncheckedCreateWithoutDepositHoldInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDepositHoldInput | BookingCreateOrConnectWithoutDepositHoldInput[]
    createMany?: BookingCreateManyDepositHoldInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDepositHoldInput = {
    create?: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput> | BookingCreateWithoutDepositHoldInput[] | BookingUncheckedCreateWithoutDepositHoldInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDepositHoldInput | BookingCreateOrConnectWithoutDepositHoldInput[]
    createMany?: BookingCreateManyDepositHoldInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EnumDepositStatusFieldUpdateOperationsInput = {
    set?: $Enums.DepositStatus
  }

  export type BookingUpdateManyWithoutDepositHoldNestedInput = {
    create?: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput> | BookingCreateWithoutDepositHoldInput[] | BookingUncheckedCreateWithoutDepositHoldInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDepositHoldInput | BookingCreateOrConnectWithoutDepositHoldInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDepositHoldInput | BookingUpsertWithWhereUniqueWithoutDepositHoldInput[]
    createMany?: BookingCreateManyDepositHoldInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDepositHoldInput | BookingUpdateWithWhereUniqueWithoutDepositHoldInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDepositHoldInput | BookingUpdateManyWithWhereWithoutDepositHoldInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDepositHoldNestedInput = {
    create?: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput> | BookingCreateWithoutDepositHoldInput[] | BookingUncheckedCreateWithoutDepositHoldInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDepositHoldInput | BookingCreateOrConnectWithoutDepositHoldInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDepositHoldInput | BookingUpsertWithWhereUniqueWithoutDepositHoldInput[]
    createMany?: BookingCreateManyDepositHoldInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDepositHoldInput | BookingUpdateWithWhereUniqueWithoutDepositHoldInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDepositHoldInput | BookingUpdateManyWithWhereWithoutDepositHoldInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type EnumRefundStatusFieldUpdateOperationsInput = {
    set?: $Enums.RefundStatus
  }

  export type EnumPayoutStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayoutStatus
  }

  export type BookingCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    connect?: BookingWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ListingCreateWithoutReviewsInput, ListingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutReviewsInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsGivenInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsReceivedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReviewTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReviewType
  }

  export type EnumReviewStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReviewStatus
  }

  export type BookingUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    upsert?: BookingUpsertWithoutReviewsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReviewsInput, BookingUpdateWithoutReviewsInput>, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type ListingUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ListingCreateWithoutReviewsInput, ListingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutReviewsInput
    upsert?: ListingUpsertWithoutReviewsInput
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutReviewsInput, ListingUpdateWithoutReviewsInput>, ListingUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsGivenNestedInput = {
    create?: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsGivenInput
    upsert?: UserUpsertWithoutReviewsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsGivenInput, UserUpdateWithoutReviewsGivenInput>, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsReceivedInput
    upsert?: UserUpsertWithoutReviewsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsReceivedInput, UserUpdateWithoutReviewsReceivedInput>, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type BookingCreateNestedOneWithoutConversationsInput = {
    create?: XOR<BookingCreateWithoutConversationsInput, BookingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutConversationsInput
    connect?: BookingWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EnumConversationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ConversationType
  }

  export type EnumConversationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConversationStatus
  }

  export type BookingUpdateOneWithoutConversationsNestedInput = {
    create?: XOR<BookingCreateWithoutConversationsInput, BookingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutConversationsInput
    upsert?: BookingUpsertWithoutConversationsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutConversationsInput, BookingUpdateWithoutConversationsInput>, BookingUncheckedUpdateWithoutConversationsInput>
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationParticipantsInput = {
    create?: XOR<UserCreateWithoutConversationParticipantsInput, UserUncheckedCreateWithoutConversationParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationParticipantsInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type UserUpdateOneRequiredWithoutConversationParticipantsNestedInput = {
    create?: XOR<UserCreateWithoutConversationParticipantsInput, UserUncheckedCreateWithoutConversationParticipantsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationParticipantsInput
    upsert?: UserUpsertWithoutConversationParticipantsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationParticipantsInput, UserUpdateWithoutConversationParticipantsInput>, UserUncheckedUpdateWithoutConversationParticipantsInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type MessageReadReceiptCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type EnumMessageStatusFieldUpdateOperationsInput = {
    set?: $Enums.MessageStatus
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageReadReceiptUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutMessageInput | MessageReadReceiptUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput> | MessageReadReceiptCreateWithoutMessageInput[] | MessageReadReceiptUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadReceiptCreateOrConnectWithoutMessageInput | MessageReadReceiptCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadReceiptCreateManyMessageInputEnvelope
    set?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    disconnect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    delete?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    connect?: MessageReadReceiptWhereUniqueInput | MessageReadReceiptWhereUniqueInput[]
    update?: MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput | MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadReceiptUpdateManyWithWhereWithoutMessageInput | MessageReadReceiptUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutReadReceiptsInput = {
    create?: XOR<MessageCreateWithoutReadReceiptsInput, MessageUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadReceiptsInput
    connect?: MessageWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadReceiptsNestedInput = {
    create?: XOR<MessageCreateWithoutReadReceiptsInput, MessageUncheckedCreateWithoutReadReceiptsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadReceiptsInput
    upsert?: MessageUpsertWithoutReadReceiptsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReadReceiptsInput, MessageUpdateWithoutReadReceiptsInput>, MessageUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type ReportPhotoCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput> | ReportPhotoCreateWithoutReportInput[] | ReportPhotoUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPhotoCreateOrConnectWithoutReportInput | ReportPhotoCreateOrConnectWithoutReportInput[]
    createMany?: ReportPhotoCreateManyReportInputEnvelope
    connect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
  }

  export type BookingCreateNestedOneWithoutConditionReportsInput = {
    create?: XOR<BookingCreateWithoutConditionReportsInput, BookingUncheckedCreateWithoutConditionReportsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutConditionReportsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConditionReportsReportedInput = {
    create?: XOR<UserCreateWithoutConditionReportsReportedInput, UserUncheckedCreateWithoutConditionReportsReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConditionReportsReportedInput
    connect?: UserWhereUniqueInput
  }

  export type DisputeCreateNestedOneWithoutConditionReportInput = {
    create?: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutConditionReportInput
    connect?: DisputeWhereUniqueInput
  }

  export type ReportPhotoUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput> | ReportPhotoCreateWithoutReportInput[] | ReportPhotoUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPhotoCreateOrConnectWithoutReportInput | ReportPhotoCreateOrConnectWithoutReportInput[]
    createMany?: ReportPhotoCreateManyReportInputEnvelope
    connect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
  }

  export type DisputeUncheckedCreateNestedOneWithoutConditionReportInput = {
    create?: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutConditionReportInput
    connect?: DisputeWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type ReportPhotoUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput> | ReportPhotoCreateWithoutReportInput[] | ReportPhotoUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPhotoCreateOrConnectWithoutReportInput | ReportPhotoCreateOrConnectWithoutReportInput[]
    upsert?: ReportPhotoUpsertWithWhereUniqueWithoutReportInput | ReportPhotoUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportPhotoCreateManyReportInputEnvelope
    set?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    disconnect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    delete?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    connect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    update?: ReportPhotoUpdateWithWhereUniqueWithoutReportInput | ReportPhotoUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportPhotoUpdateManyWithWhereWithoutReportInput | ReportPhotoUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportPhotoScalarWhereInput | ReportPhotoScalarWhereInput[]
  }

  export type BookingUpdateOneRequiredWithoutConditionReportsNestedInput = {
    create?: XOR<BookingCreateWithoutConditionReportsInput, BookingUncheckedCreateWithoutConditionReportsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutConditionReportsInput
    upsert?: BookingUpsertWithoutConditionReportsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutConditionReportsInput, BookingUpdateWithoutConditionReportsInput>, BookingUncheckedUpdateWithoutConditionReportsInput>
  }

  export type UserUpdateOneRequiredWithoutConditionReportsReportedNestedInput = {
    create?: XOR<UserCreateWithoutConditionReportsReportedInput, UserUncheckedCreateWithoutConditionReportsReportedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConditionReportsReportedInput
    upsert?: UserUpsertWithoutConditionReportsReportedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConditionReportsReportedInput, UserUpdateWithoutConditionReportsReportedInput>, UserUncheckedUpdateWithoutConditionReportsReportedInput>
  }

  export type DisputeUpdateOneWithoutConditionReportNestedInput = {
    create?: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutConditionReportInput
    upsert?: DisputeUpsertWithoutConditionReportInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutConditionReportInput, DisputeUpdateWithoutConditionReportInput>, DisputeUncheckedUpdateWithoutConditionReportInput>
  }

  export type ReportPhotoUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput> | ReportPhotoCreateWithoutReportInput[] | ReportPhotoUncheckedCreateWithoutReportInput[]
    connectOrCreate?: ReportPhotoCreateOrConnectWithoutReportInput | ReportPhotoCreateOrConnectWithoutReportInput[]
    upsert?: ReportPhotoUpsertWithWhereUniqueWithoutReportInput | ReportPhotoUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: ReportPhotoCreateManyReportInputEnvelope
    set?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    disconnect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    delete?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    connect?: ReportPhotoWhereUniqueInput | ReportPhotoWhereUniqueInput[]
    update?: ReportPhotoUpdateWithWhereUniqueWithoutReportInput | ReportPhotoUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: ReportPhotoUpdateManyWithWhereWithoutReportInput | ReportPhotoUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: ReportPhotoScalarWhereInput | ReportPhotoScalarWhereInput[]
  }

  export type DisputeUncheckedUpdateOneWithoutConditionReportNestedInput = {
    create?: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutConditionReportInput
    upsert?: DisputeUpsertWithoutConditionReportInput
    disconnect?: DisputeWhereInput | boolean
    delete?: DisputeWhereInput | boolean
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutConditionReportInput, DisputeUpdateWithoutConditionReportInput>, DisputeUncheckedUpdateWithoutConditionReportInput>
  }

  export type ConditionReportCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ConditionReportCreateWithoutPhotosInput, ConditionReportUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ConditionReportCreateOrConnectWithoutPhotosInput
    connect?: ConditionReportWhereUniqueInput
  }

  export type ConditionReportUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ConditionReportCreateWithoutPhotosInput, ConditionReportUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ConditionReportCreateOrConnectWithoutPhotosInput
    upsert?: ConditionReportUpsertWithoutPhotosInput
    connect?: ConditionReportWhereUniqueInput
    update?: XOR<XOR<ConditionReportUpdateToOneWithWhereWithoutPhotosInput, ConditionReportUpdateWithoutPhotosInput>, ConditionReportUncheckedUpdateWithoutPhotosInput>
  }

  export type DisputeResolutionCreateNestedOneWithoutDisputeInput = {
    create?: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: DisputeResolutionCreateOrConnectWithoutDisputeInput
    connect?: DisputeResolutionWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutDisputesInput = {
    create?: XOR<BookingCreateWithoutDisputesInput, BookingUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutDisputesInput
    connect?: BookingWhereUniqueInput
  }

  export type ConditionReportCreateNestedOneWithoutDisputeInput = {
    create?: XOR<ConditionReportCreateWithoutDisputeInput, ConditionReportUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: ConditionReportCreateOrConnectWithoutDisputeInput
    connect?: ConditionReportWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisputesInitiatedInput = {
    create?: XOR<UserCreateWithoutDisputesInitiatedInput, UserUncheckedCreateWithoutDisputesInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisputesDefendedInput = {
    create?: XOR<UserCreateWithoutDisputesDefendedInput, UserUncheckedCreateWithoutDisputesDefendedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesDefendedInput
    connect?: UserWhereUniqueInput
  }

  export type DisputeResponseCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput> | DisputeResponseCreateWithoutDisputeInput[] | DisputeResponseUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutDisputeInput | DisputeResponseCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeResponseCreateManyDisputeInputEnvelope
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
  }

  export type DisputeEvidenceCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput> | DisputeEvidenceCreateWithoutDisputeInput[] | DisputeEvidenceUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeEvidenceCreateOrConnectWithoutDisputeInput | DisputeEvidenceCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeEvidenceCreateManyDisputeInputEnvelope
    connect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
  }

  export type DisputeTimelineEventCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput> | DisputeTimelineEventCreateWithoutDisputeInput[] | DisputeTimelineEventUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeTimelineEventCreateOrConnectWithoutDisputeInput | DisputeTimelineEventCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeTimelineEventCreateManyDisputeInputEnvelope
    connect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
  }

  export type DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput = {
    create?: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: DisputeResolutionCreateOrConnectWithoutDisputeInput
    connect?: DisputeResolutionWhereUniqueInput
  }

  export type DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput> | DisputeResponseCreateWithoutDisputeInput[] | DisputeResponseUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutDisputeInput | DisputeResponseCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeResponseCreateManyDisputeInputEnvelope
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
  }

  export type DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput> | DisputeEvidenceCreateWithoutDisputeInput[] | DisputeEvidenceUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeEvidenceCreateOrConnectWithoutDisputeInput | DisputeEvidenceCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeEvidenceCreateManyDisputeInputEnvelope
    connect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
  }

  export type DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput = {
    create?: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput> | DisputeTimelineEventCreateWithoutDisputeInput[] | DisputeTimelineEventUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeTimelineEventCreateOrConnectWithoutDisputeInput | DisputeTimelineEventCreateOrConnectWithoutDisputeInput[]
    createMany?: DisputeTimelineEventCreateManyDisputeInputEnvelope
    connect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
  }

  export type EnumDisputeTypeFieldUpdateOperationsInput = {
    set?: $Enums.DisputeType
  }

  export type EnumDisputeStatusFieldUpdateOperationsInput = {
    set?: $Enums.DisputeStatus
  }

  export type EnumDisputePriorityFieldUpdateOperationsInput = {
    set?: $Enums.DisputePriority
  }

  export type DisputeResolutionUpdateOneWithoutDisputeNestedInput = {
    create?: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: DisputeResolutionCreateOrConnectWithoutDisputeInput
    upsert?: DisputeResolutionUpsertWithoutDisputeInput
    disconnect?: DisputeResolutionWhereInput | boolean
    delete?: DisputeResolutionWhereInput | boolean
    connect?: DisputeResolutionWhereUniqueInput
    update?: XOR<XOR<DisputeResolutionUpdateToOneWithWhereWithoutDisputeInput, DisputeResolutionUpdateWithoutDisputeInput>, DisputeResolutionUncheckedUpdateWithoutDisputeInput>
  }

  export type BookingUpdateOneRequiredWithoutDisputesNestedInput = {
    create?: XOR<BookingCreateWithoutDisputesInput, BookingUncheckedCreateWithoutDisputesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutDisputesInput
    upsert?: BookingUpsertWithoutDisputesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutDisputesInput, BookingUpdateWithoutDisputesInput>, BookingUncheckedUpdateWithoutDisputesInput>
  }

  export type ConditionReportUpdateOneWithoutDisputeNestedInput = {
    create?: XOR<ConditionReportCreateWithoutDisputeInput, ConditionReportUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: ConditionReportCreateOrConnectWithoutDisputeInput
    upsert?: ConditionReportUpsertWithoutDisputeInput
    disconnect?: ConditionReportWhereInput | boolean
    delete?: ConditionReportWhereInput | boolean
    connect?: ConditionReportWhereUniqueInput
    update?: XOR<XOR<ConditionReportUpdateToOneWithWhereWithoutDisputeInput, ConditionReportUpdateWithoutDisputeInput>, ConditionReportUncheckedUpdateWithoutDisputeInput>
  }

  export type UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutDisputesInitiatedInput, UserUncheckedCreateWithoutDisputesInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesInitiatedInput
    upsert?: UserUpsertWithoutDisputesInitiatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisputesInitiatedInput, UserUpdateWithoutDisputesInitiatedInput>, UserUncheckedUpdateWithoutDisputesInitiatedInput>
  }

  export type UserUpdateOneRequiredWithoutDisputesDefendedNestedInput = {
    create?: XOR<UserCreateWithoutDisputesDefendedInput, UserUncheckedCreateWithoutDisputesDefendedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputesDefendedInput
    upsert?: UserUpsertWithoutDisputesDefendedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisputesDefendedInput, UserUpdateWithoutDisputesDefendedInput>, UserUncheckedUpdateWithoutDisputesDefendedInput>
  }

  export type DisputeResponseUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput> | DisputeResponseCreateWithoutDisputeInput[] | DisputeResponseUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutDisputeInput | DisputeResponseCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeResponseUpsertWithWhereUniqueWithoutDisputeInput | DisputeResponseUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeResponseCreateManyDisputeInputEnvelope
    set?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    disconnect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    delete?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    update?: DisputeResponseUpdateWithWhereUniqueWithoutDisputeInput | DisputeResponseUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeResponseUpdateManyWithWhereWithoutDisputeInput | DisputeResponseUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
  }

  export type DisputeEvidenceUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput> | DisputeEvidenceCreateWithoutDisputeInput[] | DisputeEvidenceUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeEvidenceCreateOrConnectWithoutDisputeInput | DisputeEvidenceCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeEvidenceUpsertWithWhereUniqueWithoutDisputeInput | DisputeEvidenceUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeEvidenceCreateManyDisputeInputEnvelope
    set?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    disconnect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    delete?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    connect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    update?: DisputeEvidenceUpdateWithWhereUniqueWithoutDisputeInput | DisputeEvidenceUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeEvidenceUpdateManyWithWhereWithoutDisputeInput | DisputeEvidenceUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeEvidenceScalarWhereInput | DisputeEvidenceScalarWhereInput[]
  }

  export type DisputeTimelineEventUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput> | DisputeTimelineEventCreateWithoutDisputeInput[] | DisputeTimelineEventUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeTimelineEventCreateOrConnectWithoutDisputeInput | DisputeTimelineEventCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeTimelineEventUpsertWithWhereUniqueWithoutDisputeInput | DisputeTimelineEventUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeTimelineEventCreateManyDisputeInputEnvelope
    set?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    disconnect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    delete?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    connect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    update?: DisputeTimelineEventUpdateWithWhereUniqueWithoutDisputeInput | DisputeTimelineEventUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeTimelineEventUpdateManyWithWhereWithoutDisputeInput | DisputeTimelineEventUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeTimelineEventScalarWhereInput | DisputeTimelineEventScalarWhereInput[]
  }

  export type DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput = {
    create?: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
    connectOrCreate?: DisputeResolutionCreateOrConnectWithoutDisputeInput
    upsert?: DisputeResolutionUpsertWithoutDisputeInput
    disconnect?: DisputeResolutionWhereInput | boolean
    delete?: DisputeResolutionWhereInput | boolean
    connect?: DisputeResolutionWhereUniqueInput
    update?: XOR<XOR<DisputeResolutionUpdateToOneWithWhereWithoutDisputeInput, DisputeResolutionUpdateWithoutDisputeInput>, DisputeResolutionUncheckedUpdateWithoutDisputeInput>
  }

  export type DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput> | DisputeResponseCreateWithoutDisputeInput[] | DisputeResponseUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeResponseCreateOrConnectWithoutDisputeInput | DisputeResponseCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeResponseUpsertWithWhereUniqueWithoutDisputeInput | DisputeResponseUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeResponseCreateManyDisputeInputEnvelope
    set?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    disconnect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    delete?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    connect?: DisputeResponseWhereUniqueInput | DisputeResponseWhereUniqueInput[]
    update?: DisputeResponseUpdateWithWhereUniqueWithoutDisputeInput | DisputeResponseUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeResponseUpdateManyWithWhereWithoutDisputeInput | DisputeResponseUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
  }

  export type DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput> | DisputeEvidenceCreateWithoutDisputeInput[] | DisputeEvidenceUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeEvidenceCreateOrConnectWithoutDisputeInput | DisputeEvidenceCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeEvidenceUpsertWithWhereUniqueWithoutDisputeInput | DisputeEvidenceUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeEvidenceCreateManyDisputeInputEnvelope
    set?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    disconnect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    delete?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    connect?: DisputeEvidenceWhereUniqueInput | DisputeEvidenceWhereUniqueInput[]
    update?: DisputeEvidenceUpdateWithWhereUniqueWithoutDisputeInput | DisputeEvidenceUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeEvidenceUpdateManyWithWhereWithoutDisputeInput | DisputeEvidenceUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeEvidenceScalarWhereInput | DisputeEvidenceScalarWhereInput[]
  }

  export type DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput = {
    create?: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput> | DisputeTimelineEventCreateWithoutDisputeInput[] | DisputeTimelineEventUncheckedCreateWithoutDisputeInput[]
    connectOrCreate?: DisputeTimelineEventCreateOrConnectWithoutDisputeInput | DisputeTimelineEventCreateOrConnectWithoutDisputeInput[]
    upsert?: DisputeTimelineEventUpsertWithWhereUniqueWithoutDisputeInput | DisputeTimelineEventUpsertWithWhereUniqueWithoutDisputeInput[]
    createMany?: DisputeTimelineEventCreateManyDisputeInputEnvelope
    set?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    disconnect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    delete?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    connect?: DisputeTimelineEventWhereUniqueInput | DisputeTimelineEventWhereUniqueInput[]
    update?: DisputeTimelineEventUpdateWithWhereUniqueWithoutDisputeInput | DisputeTimelineEventUpdateWithWhereUniqueWithoutDisputeInput[]
    updateMany?: DisputeTimelineEventUpdateManyWithWhereWithoutDisputeInput | DisputeTimelineEventUpdateManyWithWhereWithoutDisputeInput[]
    deleteMany?: DisputeTimelineEventScalarWhereInput | DisputeTimelineEventScalarWhereInput[]
  }

  export type DisputeCreateNestedOneWithoutResponsesInput = {
    create?: XOR<DisputeCreateWithoutResponsesInput, DisputeUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutResponsesInput
    connect?: DisputeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDisputeResponsesInput = {
    create?: XOR<UserCreateWithoutDisputeResponsesInput, UserUncheckedCreateWithoutDisputeResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputeResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type DisputeUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<DisputeCreateWithoutResponsesInput, DisputeUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutResponsesInput
    upsert?: DisputeUpsertWithoutResponsesInput
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutResponsesInput, DisputeUpdateWithoutResponsesInput>, DisputeUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutDisputeResponsesNestedInput = {
    create?: XOR<UserCreateWithoutDisputeResponsesInput, UserUncheckedCreateWithoutDisputeResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDisputeResponsesInput
    upsert?: UserUpsertWithoutDisputeResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDisputeResponsesInput, UserUpdateWithoutDisputeResponsesInput>, UserUncheckedUpdateWithoutDisputeResponsesInput>
  }

  export type DisputeCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<DisputeCreateWithoutEvidenceInput, DisputeUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEvidenceInput
    connect?: DisputeWhereUniqueInput
  }

  export type EnumEvidenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.EvidenceType
  }

  export type DisputeUpdateOneRequiredWithoutEvidenceNestedInput = {
    create?: XOR<DisputeCreateWithoutEvidenceInput, DisputeUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutEvidenceInput
    upsert?: DisputeUpsertWithoutEvidenceInput
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutEvidenceInput, DisputeUpdateWithoutEvidenceInput>, DisputeUncheckedUpdateWithoutEvidenceInput>
  }

  export type DisputeCreateNestedOneWithoutTimelineInput = {
    create?: XOR<DisputeCreateWithoutTimelineInput, DisputeUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutTimelineInput
    connect?: DisputeWhereUniqueInput
  }

  export type DisputeUpdateOneRequiredWithoutTimelineNestedInput = {
    create?: XOR<DisputeCreateWithoutTimelineInput, DisputeUncheckedCreateWithoutTimelineInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutTimelineInput
    upsert?: DisputeUpsertWithoutTimelineInput
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutTimelineInput, DisputeUpdateWithoutTimelineInput>, DisputeUncheckedUpdateWithoutTimelineInput>
  }

  export type DisputeCreateNestedOneWithoutResolutionInput = {
    create?: XOR<DisputeCreateWithoutResolutionInput, DisputeUncheckedCreateWithoutResolutionInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutResolutionInput
    connect?: DisputeWhereUniqueInput
  }

  export type EnumResolutionOutcomeFieldUpdateOperationsInput = {
    set?: $Enums.ResolutionOutcome
  }

  export type DisputeUpdateOneRequiredWithoutResolutionNestedInput = {
    create?: XOR<DisputeCreateWithoutResolutionInput, DisputeUncheckedCreateWithoutResolutionInput>
    connectOrCreate?: DisputeCreateOrConnectWithoutResolutionInput
    upsert?: DisputeUpsertWithoutResolutionInput
    connect?: DisputeWhereUniqueInput
    update?: XOR<XOR<DisputeUpdateToOneWithWhereWithoutResolutionInput, DisputeUpdateWithoutResolutionInput>, DisputeUncheckedUpdateWithoutResolutionInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutInsurancePoliciesInput = {
    create?: XOR<UserCreateWithoutInsurancePoliciesInput, UserUncheckedCreateWithoutInsurancePoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurancePoliciesInput
    connect?: UserWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutInsurancePoliciesInput = {
    create?: XOR<ListingCreateWithoutInsurancePoliciesInput, ListingUncheckedCreateWithoutInsurancePoliciesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutInsurancePoliciesInput
    connect?: ListingWhereUniqueInput
  }

  export type EnumInsuranceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InsuranceStatus
  }

  export type UserUpdateOneRequiredWithoutInsurancePoliciesNestedInput = {
    create?: XOR<UserCreateWithoutInsurancePoliciesInput, UserUncheckedCreateWithoutInsurancePoliciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsurancePoliciesInput
    upsert?: UserUpsertWithoutInsurancePoliciesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsurancePoliciesInput, UserUpdateWithoutInsurancePoliciesInput>, UserUncheckedUpdateWithoutInsurancePoliciesInput>
  }

  export type ListingUpdateOneWithoutInsurancePoliciesNestedInput = {
    create?: XOR<ListingCreateWithoutInsurancePoliciesInput, ListingUncheckedCreateWithoutInsurancePoliciesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutInsurancePoliciesInput
    upsert?: ListingUpsertWithoutInsurancePoliciesInput
    disconnect?: ListingWhereInput | boolean
    delete?: ListingWhereInput | boolean
    connect?: ListingWhereUniqueInput
    update?: XOR<XOR<ListingUpdateToOneWithWhereWithoutInsurancePoliciesInput, ListingUpdateWithoutInsurancePoliciesInput>, ListingUncheckedUpdateWithoutInsurancePoliciesInput>
  }

  export type UserCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeviceTokensInput
    upsert?: UserUpsertWithoutDeviceTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeviceTokensInput, UserUpdateWithoutDeviceTokensInput>, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserCreateNestedOneWithoutUserPreferencesInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPreferencesInput
    upsert?: UserUpsertWithoutUserPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPreferencesInput, UserUpdateWithoutUserPreferencesInput>, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumVerificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusFilter<$PrismaModel> | $Enums.VerificationStatus
  }

  export type NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernmentIdType | EnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel> | $Enums.GovernmentIdType | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationStatus | EnumVerificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationStatus[] | ListEnumVerificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VerificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationStatusFilter<$PrismaModel>
    _max?: NestedEnumVerificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumGovernmentIdTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GovernmentIdType | EnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.GovernmentIdType[] | ListEnumGovernmentIdTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGovernmentIdTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.GovernmentIdType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumGovernmentIdTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumOrganizationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationStatus | EnumOrganizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationStatusFilter<$PrismaModel> | $Enums.OrganizationStatus
  }

  export type NestedEnumOrganizationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrganizationStatus | EnumOrganizationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrganizationStatus[] | ListEnumOrganizationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrganizationStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrganizationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrganizationStatusFilter<$PrismaModel>
    _max?: NestedEnumOrganizationStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrgRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleFilter<$PrismaModel> | $Enums.OrgRole
  }

  export type NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrgRole | EnumOrgRoleFieldRefInput<$PrismaModel>
    in?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrgRole[] | ListEnumOrgRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumOrgRoleWithAggregatesFilter<$PrismaModel> | $Enums.OrgRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrgRoleFilter<$PrismaModel>
    _max?: NestedEnumOrgRoleFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumPricingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingMode | EnumPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModeFilter<$PrismaModel> | $Enums.PricingMode
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPricingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingMode | EnumPricingModeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingMode[] | ListEnumPricingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingModeWithAggregatesFilter<$PrismaModel> | $Enums.PricingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingModeFilter<$PrismaModel>
    _max?: NestedEnumPricingModeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumDepositTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepositTypeNullableFilter<$PrismaModel> | $Enums.DepositType | null
  }

  export type NestedEnumBookingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMode | EnumBookingModeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingModeFilter<$PrismaModel> | $Enums.BookingMode
  }

  export type NestedEnumListingConditionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingCondition | EnumListingConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingConditionNullableFilter<$PrismaModel> | $Enums.ListingCondition | null
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedEnumDepositTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositType | EnumDepositTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DepositType[] | ListEnumDepositTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDepositTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DepositType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDepositTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDepositTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingMode | EnumBookingModeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingMode[] | ListEnumBookingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingModeWithAggregatesFilter<$PrismaModel> | $Enums.BookingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingModeFilter<$PrismaModel>
    _max?: NestedEnumBookingModeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumListingConditionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingCondition | EnumListingConditionFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListingCondition[] | ListEnumListingConditionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListingConditionNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListingCondition | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListingConditionNullableFilter<$PrismaModel>
    _max?: NestedEnumListingConditionNullableFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedEnumCancellationPolicyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicyType | EnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel> | $Enums.CancellationPolicyType
  }

  export type NestedEnumCancellationPolicyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicyType | EnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CancellationPolicyType[] | ListEnumCancellationPolicyTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCancellationPolicyTypeWithAggregatesFilter<$PrismaModel> | $Enums.CancellationPolicyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel>
    _max?: NestedEnumCancellationPolicyTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumLedgerSideFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerSide | EnumLedgerSideFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerSideFilter<$PrismaModel> | $Enums.LedgerSide
  }

  export type NestedEnumLedgerEntryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryStatus | EnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryStatusFilter<$PrismaModel> | $Enums.LedgerEntryStatus
  }

  export type NestedEnumLedgerSideWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerSide | EnumLedgerSideFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerSide[] | ListEnumLedgerSideFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerSideWithAggregatesFilter<$PrismaModel> | $Enums.LedgerSide
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerSideFilter<$PrismaModel>
    _max?: NestedEnumLedgerSideFilter<$PrismaModel>
  }

  export type NestedEnumLedgerEntryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LedgerEntryStatus | EnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LedgerEntryStatus[] | ListEnumLedgerEntryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLedgerEntryStatusWithAggregatesFilter<$PrismaModel> | $Enums.LedgerEntryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLedgerEntryStatusFilter<$PrismaModel>
    _max?: NestedEnumLedgerEntryStatusFilter<$PrismaModel>
  }

  export type NestedEnumDepositStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositStatusFilter<$PrismaModel> | $Enums.DepositStatus
  }

  export type NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepositStatus | EnumDepositStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepositStatus[] | ListEnumDepositStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDepositStatusWithAggregatesFilter<$PrismaModel> | $Enums.DepositStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepositStatusFilter<$PrismaModel>
    _max?: NestedEnumDepositStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumRefundStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusFilter<$PrismaModel> | $Enums.RefundStatus
  }

  export type NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RefundStatus | EnumRefundStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RefundStatus[] | ListEnumRefundStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRefundStatusWithAggregatesFilter<$PrismaModel> | $Enums.RefundStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRefundStatusFilter<$PrismaModel>
    _max?: NestedEnumRefundStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayoutStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusFilter<$PrismaModel> | $Enums.PayoutStatus
  }

  export type NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayoutStatus | EnumPayoutStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayoutStatus[] | ListEnumPayoutStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayoutStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayoutStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayoutStatusFilter<$PrismaModel>
    _max?: NestedEnumPayoutStatusFilter<$PrismaModel>
  }

  export type NestedEnumReviewTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeFilter<$PrismaModel> | $Enums.ReviewType
  }

  export type NestedEnumReviewStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusFilter<$PrismaModel> | $Enums.ReviewStatus
  }

  export type NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewType | EnumReviewTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewType[] | ListEnumReviewTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReviewType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewTypeFilter<$PrismaModel>
    _max?: NestedEnumReviewTypeFilter<$PrismaModel>
  }

  export type NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewStatus | EnumReviewStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewStatus[] | ListEnumReviewStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReviewStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewStatusFilter<$PrismaModel>
    _max?: NestedEnumReviewStatusFilter<$PrismaModel>
  }

  export type NestedEnumConversationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationType | EnumConversationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationTypeFilter<$PrismaModel> | $Enums.ConversationType
  }

  export type NestedEnumConversationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusFilter<$PrismaModel> | $Enums.ConversationStatus
  }

  export type NestedEnumConversationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationType | EnumConversationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationType[] | ListEnumConversationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ConversationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationTypeFilter<$PrismaModel>
    _max?: NestedEnumConversationTypeFilter<$PrismaModel>
  }

  export type NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConversationStatus | EnumConversationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConversationStatus[] | ListEnumConversationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConversationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConversationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConversationStatusFilter<$PrismaModel>
    _max?: NestedEnumConversationStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusFilter<$PrismaModel> | $Enums.MessageStatus
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageType[] | ListEnumMessageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageStatus | EnumMessageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageStatus[] | ListEnumMessageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageStatusWithAggregatesFilter<$PrismaModel> | $Enums.MessageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageStatusFilter<$PrismaModel>
    _max?: NestedEnumMessageStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportType[] | ListEnumReportTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type NestedEnumDisputeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeFilter<$PrismaModel> | $Enums.DisputeType
  }

  export type NestedEnumDisputeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusFilter<$PrismaModel> | $Enums.DisputeStatus
  }

  export type NestedEnumDisputePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputePriority | EnumDisputePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputePriorityFilter<$PrismaModel> | $Enums.DisputePriority
  }

  export type NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeType | EnumDisputeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeType[] | ListEnumDisputeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeTypeWithAggregatesFilter<$PrismaModel> | $Enums.DisputeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeTypeFilter<$PrismaModel>
    _max?: NestedEnumDisputeTypeFilter<$PrismaModel>
  }

  export type NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputeStatus | EnumDisputeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputeStatus[] | ListEnumDisputeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputeStatusWithAggregatesFilter<$PrismaModel> | $Enums.DisputeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputeStatusFilter<$PrismaModel>
    _max?: NestedEnumDisputeStatusFilter<$PrismaModel>
  }

  export type NestedEnumDisputePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DisputePriority | EnumDisputePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DisputePriority[] | ListEnumDisputePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumDisputePriorityWithAggregatesFilter<$PrismaModel> | $Enums.DisputePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDisputePriorityFilter<$PrismaModel>
    _max?: NestedEnumDisputePriorityFilter<$PrismaModel>
  }

  export type NestedEnumEvidenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeFilter<$PrismaModel> | $Enums.EvidenceType
  }

  export type NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceTypeFilter<$PrismaModel>
    _max?: NestedEnumEvidenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumResolutionOutcomeFilter<$PrismaModel = never> = {
    equals?: $Enums.ResolutionOutcome | EnumResolutionOutcomeFieldRefInput<$PrismaModel>
    in?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    not?: NestedEnumResolutionOutcomeFilter<$PrismaModel> | $Enums.ResolutionOutcome
  }

  export type NestedEnumResolutionOutcomeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ResolutionOutcome | EnumResolutionOutcomeFieldRefInput<$PrismaModel>
    in?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ResolutionOutcome[] | ListEnumResolutionOutcomeFieldRefInput<$PrismaModel>
    not?: NestedEnumResolutionOutcomeWithAggregatesFilter<$PrismaModel> | $Enums.ResolutionOutcome
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumResolutionOutcomeFilter<$PrismaModel>
    _max?: NestedEnumResolutionOutcomeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsuranceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceStatus | EnumInsuranceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceStatusFilter<$PrismaModel> | $Enums.InsuranceStatus
  }

  export type NestedEnumInsuranceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsuranceStatus | EnumInsuranceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsuranceStatus[] | ListEnumInsuranceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsuranceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsuranceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsuranceStatusFilter<$PrismaModel>
    _max?: NestedEnumInsuranceStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutOwnerInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutOwnerInput = {
    id?: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput>
  }

  export type ListingCreateManyOwnerInputEnvelope = {
    data: ListingCreateManyOwnerInput | ListingCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutRenterInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRenterInput = {
    id?: string
    listingId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRenterInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput>
  }

  export type BookingCreateManyRenterInputEnvelope = {
    data: BookingCreateManyRenterInput | BookingCreateManyRenterInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutOwnerInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutOwnerInput = {
    id?: string
    listingId: string
    renterId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingCreateManyOwnerInputEnvelope = {
    data: BookingCreateManyOwnerInput | BookingCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutReviewerInput = {
    id?: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewsInput
    listing: ListingCreateNestedOneWithoutReviewsInput
    reviewee: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutReviewerInput = {
    id?: string
    bookingId: string
    listingId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewCreateManyReviewerInputEnvelope = {
    data: ReviewCreateManyReviewerInput | ReviewCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutRevieweeInput = {
    id?: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewsInput
    listing: ListingCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
  }

  export type ReviewUncheckedCreateWithoutRevieweeInput = {
    id?: string
    bookingId: string
    listingId: string
    reviewerId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewCreateManyRevieweeInputEnvelope = {
    data: ReviewCreateManyRevieweeInput | ReviewCreateManyRevieweeInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutUserInput = {
    id?: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutUserInput = {
    id?: string
    conversationId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantCreateManyUserInputEnvelope = {
    data: ConversationParticipantCreateManyUserInput | ConversationParticipantCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutInitiatorInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutInitiatorInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutInitiatorInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput>
  }

  export type DisputeCreateManyInitiatorInputEnvelope = {
    data: DisputeCreateManyInitiatorInput | DisputeCreateManyInitiatorInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutDefendantInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutDefendantInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutDefendantInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput>
  }

  export type DisputeCreateManyDefendantInputEnvelope = {
    data: DisputeCreateManyDefendantInput | DisputeCreateManyDefendantInput[]
    skipDuplicates?: boolean
  }

  export type DisputeResponseCreateWithoutUserInput = {
    id?: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    dispute: DisputeCreateNestedOneWithoutResponsesInput
  }

  export type DisputeResponseUncheckedCreateWithoutUserInput = {
    id?: string
    disputeId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeResponseCreateOrConnectWithoutUserInput = {
    where: DisputeResponseWhereUniqueInput
    create: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput>
  }

  export type DisputeResponseCreateManyUserInputEnvelope = {
    data: DisputeResponseCreateManyUserInput | DisputeResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutMembersInput
  }

  export type OrganizationMemberUncheckedCreateWithoutUserInput = {
    id?: string
    organizationId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberCreateManyUserInputEnvelope = {
    data: OrganizationMemberCreateManyUserInput | OrganizationMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteListingCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    listing: ListingCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteListingUncheckedCreateWithoutUserInput = {
    id?: string
    listingId: string
    createdAt?: Date | string
  }

  export type FavoriteListingCreateOrConnectWithoutUserInput = {
    where: FavoriteListingWhereUniqueInput
    create: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput>
  }

  export type FavoriteListingCreateManyUserInputEnvelope = {
    data: FavoriteListingCreateManyUserInput | FavoriteListingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InsurancePolicyCreateWithoutUserInput = {
    id?: string
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    listing?: ListingCreateNestedOneWithoutInsurancePoliciesInput
  }

  export type InsurancePolicyUncheckedCreateWithoutUserInput = {
    id?: string
    listingId?: string | null
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePolicyCreateOrConnectWithoutUserInput = {
    where: InsurancePolicyWhereUniqueInput
    create: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput>
  }

  export type InsurancePolicyCreateManyUserInputEnvelope = {
    data: InsurancePolicyCreateManyUserInput | InsurancePolicyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTokenCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateOrConnectWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenCreateManyUserInputEnvelope = {
    data: DeviceTokenCreateManyUserInput | DeviceTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    preferences: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type ConditionReportCreateWithoutReportedByUserInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoCreateNestedManyWithoutReportInput
    booking: BookingCreateNestedOneWithoutConditionReportsInput
    dispute?: DisputeCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportUncheckedCreateWithoutReportedByUserInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoUncheckedCreateNestedManyWithoutReportInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportCreateOrConnectWithoutReportedByUserInput = {
    where: ConditionReportWhereUniqueInput
    create: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput>
  }

  export type ConditionReportCreateManyReportedByUserInputEnvelope = {
    data: ConditionReportCreateManyReportedByUserInput | ConditionReportCreateManyReportedByUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type ListingUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutOwnerInput, ListingUncheckedUpdateWithoutOwnerInput>
    create: XOR<ListingCreateWithoutOwnerInput, ListingUncheckedCreateWithoutOwnerInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutOwnerInput, ListingUncheckedUpdateWithoutOwnerInput>
  }

  export type ListingUpdateManyWithWhereWithoutOwnerInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ListingScalarWhereInput = {
    AND?: ListingScalarWhereInput | ListingScalarWhereInput[]
    OR?: ListingScalarWhereInput[]
    NOT?: ListingScalarWhereInput | ListingScalarWhereInput[]
    id?: StringFilter<"Listing"> | string
    ownerId?: StringFilter<"Listing"> | string
    organizationId?: StringNullableFilter<"Listing"> | string | null
    categoryId?: StringFilter<"Listing"> | string
    title?: StringFilter<"Listing"> | string
    description?: StringFilter<"Listing"> | string
    slug?: StringFilter<"Listing"> | string
    addressLine1?: StringNullableFilter<"Listing"> | string | null
    addressLine2?: StringNullableFilter<"Listing"> | string | null
    city?: StringFilter<"Listing"> | string
    state?: StringFilter<"Listing"> | string
    postalCode?: StringNullableFilter<"Listing"> | string | null
    country?: StringFilter<"Listing"> | string
    latitude?: FloatFilter<"Listing"> | number
    longitude?: FloatFilter<"Listing"> | number
    photos?: JsonFilter<"Listing">
    videos?: JsonFilter<"Listing">
    documents?: JsonFilter<"Listing">
    pricingMode?: EnumPricingModeFilter<"Listing"> | $Enums.PricingMode
    basePrice?: FloatFilter<"Listing"> | number
    hourlyPrice?: FloatNullableFilter<"Listing"> | number | null
    dailyPrice?: FloatNullableFilter<"Listing"> | number | null
    weeklyPrice?: FloatNullableFilter<"Listing"> | number | null
    monthlyPrice?: FloatNullableFilter<"Listing"> | number | null
    currency?: StringFilter<"Listing"> | string
    requiresDeposit?: BoolFilter<"Listing"> | boolean
    depositAmount?: FloatNullableFilter<"Listing"> | number | null
    depositType?: EnumDepositTypeNullableFilter<"Listing"> | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFilter<"Listing"> | $Enums.BookingMode
    minBookingHours?: IntNullableFilter<"Listing"> | number | null
    maxBookingDays?: IntNullableFilter<"Listing"> | number | null
    leadTime?: IntFilter<"Listing"> | number
    advanceNotice?: IntFilter<"Listing"> | number
    capacity?: IntNullableFilter<"Listing"> | number | null
    categorySpecificData?: JsonFilter<"Listing">
    condition?: EnumListingConditionNullableFilter<"Listing"> | $Enums.ListingCondition | null
    features?: JsonFilter<"Listing">
    amenities?: JsonFilter<"Listing">
    cancellationPolicyId?: StringNullableFilter<"Listing"> | string | null
    rules?: JsonFilter<"Listing">
    insurancePolicyId?: StringNullableFilter<"Listing"> | string | null
    insuranceVerified?: BoolFilter<"Listing"> | boolean
    insuranceVerifiedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    insuranceExpiresAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    status?: EnumListingStatusFilter<"Listing"> | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFilter<"Listing"> | $Enums.VerificationStatus
    rejectionReason?: StringNullableFilter<"Listing"> | string | null
    moderatedBy?: StringNullableFilter<"Listing"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    viewCount?: IntFilter<"Listing"> | number
    bookingCount?: IntFilter<"Listing"> | number
    favoriteCount?: IntFilter<"Listing"> | number
    averageRating?: FloatFilter<"Listing"> | number
    totalReviews?: IntFilter<"Listing"> | number
    metaTitle?: StringNullableFilter<"Listing"> | string | null
    metaDescription?: StringNullableFilter<"Listing"> | string | null
    createdAt?: DateTimeFilter<"Listing"> | Date | string
    updatedAt?: DateTimeFilter<"Listing"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Listing"> | Date | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutRenterInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRenterInput, BookingUncheckedUpdateWithoutRenterInput>
    create: XOR<BookingCreateWithoutRenterInput, BookingUncheckedCreateWithoutRenterInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRenterInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRenterInput, BookingUncheckedUpdateWithoutRenterInput>
  }

  export type BookingUpdateManyWithWhereWithoutRenterInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRenterInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    listingId?: StringFilter<"Booking"> | string
    renterId?: StringFilter<"Booking"> | string
    ownerId?: StringFilter<"Booking"> | string
    startDate?: DateTimeFilter<"Booking"> | Date | string
    endDate?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    guestCount?: IntFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    serviceFee?: FloatFilter<"Booking"> | number
    tax?: FloatFilter<"Booking"> | number
    depositAmount?: FloatFilter<"Booking"> | number
    discountAmount?: FloatFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    totalAmount?: FloatFilter<"Booking"> | number
    ownerEarnings?: FloatFilter<"Booking"> | number
    platformFee?: FloatFilter<"Booking"> | number
    currency?: StringFilter<"Booking"> | string
    renterMessage?: StringNullableFilter<"Booking"> | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    cancellationReason?: StringNullableFilter<"Booking"> | string | null
    cancelledBy?: StringNullableFilter<"Booking"> | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentIntentId?: StringNullableFilter<"Booking"> | string | null
    depositHoldId?: StringNullableFilter<"Booking"> | string | null
    depositReleased?: BoolFilter<"Booking"> | boolean
    depositReleasedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkInTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    checkOutTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    actualReturnTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    categoryData?: JsonFilter<"Booking">
    renterNotes?: StringNullableFilter<"Booking"> | string | null
    ownerNotes?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    confirmedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
  }

  export type BookingUpsertWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
    create: XOR<BookingCreateWithoutOwnerInput, BookingUncheckedCreateWithoutOwnerInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutOwnerInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutOwnerInput, BookingUncheckedUpdateWithoutOwnerInput>
  }

  export type BookingUpdateManyWithWhereWithoutOwnerInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
    create: XOR<ReviewCreateWithoutReviewerInput, ReviewUncheckedCreateWithoutReviewerInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutReviewerInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutReviewerInput, ReviewUncheckedUpdateWithoutReviewerInput>
  }

  export type ReviewUpdateManyWithWhereWithoutReviewerInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutReviewerInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    listingId?: StringFilter<"Review"> | string
    reviewerId?: StringFilter<"Review"> | string
    revieweeId?: StringFilter<"Review"> | string
    type?: EnumReviewTypeFilter<"Review"> | $Enums.ReviewType
    overallRating?: FloatFilter<"Review"> | number
    accuracyRating?: FloatNullableFilter<"Review"> | number | null
    communicationRating?: FloatNullableFilter<"Review"> | number | null
    cleanlinessRating?: FloatNullableFilter<"Review"> | number | null
    valueRating?: FloatNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    content?: StringFilter<"Review"> | string
    response?: StringNullableFilter<"Review"> | string | null
    respondedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    status?: EnumReviewStatusFilter<"Review"> | $Enums.ReviewStatus
    flagged?: BoolFilter<"Review"> | boolean
    flagReason?: StringNullableFilter<"Review"> | string | null
    moderatedBy?: StringNullableFilter<"Review"> | string | null
    moderatedAt?: DateTimeNullableFilter<"Review"> | Date | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutRevieweeInput, ReviewUncheckedUpdateWithoutRevieweeInput>
    create: XOR<ReviewCreateWithoutRevieweeInput, ReviewUncheckedCreateWithoutRevieweeInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutRevieweeInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutRevieweeInput, ReviewUncheckedUpdateWithoutRevieweeInput>
  }

  export type ReviewUpdateManyWithWhereWithoutRevieweeInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutRevieweeInput>
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationParticipantCreateWithoutUserInput, ConversationParticipantUncheckedCreateWithoutUserInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutUserInput, ConversationParticipantUncheckedUpdateWithoutUserInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutUserInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutUserInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    id?: StringFilter<"ConversationParticipant"> | string
    conversationId?: StringFilter<"ConversationParticipant"> | string
    userId?: StringFilter<"ConversationParticipant"> | string
    muted?: BoolFilter<"ConversationParticipant"> | boolean
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    content?: StringFilter<"Message"> | string
    attachments?: JsonFilter<"Message">
    metadata?: JsonFilter<"Message">
    status?: EnumMessageStatusFilter<"Message"> | $Enums.MessageStatus
    createdAt?: DateTimeFilter<"Message"> | Date | string
    editedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValues?: JsonNullableFilter<"AuditLog">
    newValues?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DisputeUpsertWithWhereUniqueWithoutInitiatorInput = {
    where: DisputeWhereUniqueInput
    update: XOR<DisputeUpdateWithoutInitiatorInput, DisputeUncheckedUpdateWithoutInitiatorInput>
    create: XOR<DisputeCreateWithoutInitiatorInput, DisputeUncheckedCreateWithoutInitiatorInput>
  }

  export type DisputeUpdateWithWhereUniqueWithoutInitiatorInput = {
    where: DisputeWhereUniqueInput
    data: XOR<DisputeUpdateWithoutInitiatorInput, DisputeUncheckedUpdateWithoutInitiatorInput>
  }

  export type DisputeUpdateManyWithWhereWithoutInitiatorInput = {
    where: DisputeScalarWhereInput
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyWithoutInitiatorInput>
  }

  export type DisputeScalarWhereInput = {
    AND?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
    OR?: DisputeScalarWhereInput[]
    NOT?: DisputeScalarWhereInput | DisputeScalarWhereInput[]
    id?: StringFilter<"Dispute"> | string
    bookingId?: StringFilter<"Dispute"> | string
    conditionReportId?: StringNullableFilter<"Dispute"> | string | null
    initiatorId?: StringFilter<"Dispute"> | string
    defendantId?: StringFilter<"Dispute"> | string
    type?: EnumDisputeTypeFilter<"Dispute"> | $Enums.DisputeType
    title?: StringFilter<"Dispute"> | string
    description?: StringFilter<"Dispute"> | string
    amount?: FloatNullableFilter<"Dispute"> | number | null
    currency?: StringFilter<"Dispute"> | string
    status?: EnumDisputeStatusFilter<"Dispute"> | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFilter<"Dispute"> | $Enums.DisputePriority
    slaDeadline?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    respondedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    resolvedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    assignedTo?: StringNullableFilter<"Dispute"> | string | null
    assignedAt?: DateTimeNullableFilter<"Dispute"> | Date | string | null
    createdAt?: DateTimeFilter<"Dispute"> | Date | string
    updatedAt?: DateTimeFilter<"Dispute"> | Date | string
  }

  export type DisputeUpsertWithWhereUniqueWithoutDefendantInput = {
    where: DisputeWhereUniqueInput
    update: XOR<DisputeUpdateWithoutDefendantInput, DisputeUncheckedUpdateWithoutDefendantInput>
    create: XOR<DisputeCreateWithoutDefendantInput, DisputeUncheckedCreateWithoutDefendantInput>
  }

  export type DisputeUpdateWithWhereUniqueWithoutDefendantInput = {
    where: DisputeWhereUniqueInput
    data: XOR<DisputeUpdateWithoutDefendantInput, DisputeUncheckedUpdateWithoutDefendantInput>
  }

  export type DisputeUpdateManyWithWhereWithoutDefendantInput = {
    where: DisputeScalarWhereInput
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyWithoutDefendantInput>
  }

  export type DisputeResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: DisputeResponseWhereUniqueInput
    update: XOR<DisputeResponseUpdateWithoutUserInput, DisputeResponseUncheckedUpdateWithoutUserInput>
    create: XOR<DisputeResponseCreateWithoutUserInput, DisputeResponseUncheckedCreateWithoutUserInput>
  }

  export type DisputeResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: DisputeResponseWhereUniqueInput
    data: XOR<DisputeResponseUpdateWithoutUserInput, DisputeResponseUncheckedUpdateWithoutUserInput>
  }

  export type DisputeResponseUpdateManyWithWhereWithoutUserInput = {
    where: DisputeResponseScalarWhereInput
    data: XOR<DisputeResponseUpdateManyMutationInput, DisputeResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type DisputeResponseScalarWhereInput = {
    AND?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
    OR?: DisputeResponseScalarWhereInput[]
    NOT?: DisputeResponseScalarWhereInput | DisputeResponseScalarWhereInput[]
    id?: StringFilter<"DisputeResponse"> | string
    disputeId?: StringFilter<"DisputeResponse"> | string
    userId?: StringFilter<"DisputeResponse"> | string
    content?: StringFilter<"DisputeResponse"> | string
    attachments?: JsonFilter<"DisputeResponse">
    createdAt?: DateTimeFilter<"DisputeResponse"> | Date | string
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
    create: XOR<OrganizationMemberCreateWithoutUserInput, OrganizationMemberUncheckedCreateWithoutUserInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutUserInput, OrganizationMemberUncheckedUpdateWithoutUserInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutUserInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationMemberScalarWhereInput = {
    AND?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    OR?: OrganizationMemberScalarWhereInput[]
    NOT?: OrganizationMemberScalarWhereInput | OrganizationMemberScalarWhereInput[]
    id?: StringFilter<"OrganizationMember"> | string
    organizationId?: StringFilter<"OrganizationMember"> | string
    userId?: StringFilter<"OrganizationMember"> | string
    role?: EnumOrgRoleFilter<"OrganizationMember"> | $Enums.OrgRole
    permissions?: JsonFilter<"OrganizationMember">
    invitedBy?: StringNullableFilter<"OrganizationMember"> | string | null
    joinedAt?: DateTimeFilter<"OrganizationMember"> | Date | string
  }

  export type FavoriteListingUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteListingWhereUniqueInput
    update: XOR<FavoriteListingUpdateWithoutUserInput, FavoriteListingUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteListingCreateWithoutUserInput, FavoriteListingUncheckedCreateWithoutUserInput>
  }

  export type FavoriteListingUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteListingWhereUniqueInput
    data: XOR<FavoriteListingUpdateWithoutUserInput, FavoriteListingUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteListingUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteListingScalarWhereInput
    data: XOR<FavoriteListingUpdateManyMutationInput, FavoriteListingUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteListingScalarWhereInput = {
    AND?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
    OR?: FavoriteListingScalarWhereInput[]
    NOT?: FavoriteListingScalarWhereInput | FavoriteListingScalarWhereInput[]
    id?: StringFilter<"FavoriteListing"> | string
    userId?: StringFilter<"FavoriteListing"> | string
    listingId?: StringFilter<"FavoriteListing"> | string
    createdAt?: DateTimeFilter<"FavoriteListing"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    relatedId?: StringNullableFilter<"Notification"> | string | null
    relatedType?: StringNullableFilter<"Notification"> | string | null
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    actionLabel?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    status?: StringNullableFilter<"Notification"> | string | null
    sentViaEmail?: BoolFilter<"Notification"> | boolean
    sentViaPush?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type InsurancePolicyUpsertWithWhereUniqueWithoutUserInput = {
    where: InsurancePolicyWhereUniqueInput
    update: XOR<InsurancePolicyUpdateWithoutUserInput, InsurancePolicyUncheckedUpdateWithoutUserInput>
    create: XOR<InsurancePolicyCreateWithoutUserInput, InsurancePolicyUncheckedCreateWithoutUserInput>
  }

  export type InsurancePolicyUpdateWithWhereUniqueWithoutUserInput = {
    where: InsurancePolicyWhereUniqueInput
    data: XOR<InsurancePolicyUpdateWithoutUserInput, InsurancePolicyUncheckedUpdateWithoutUserInput>
  }

  export type InsurancePolicyUpdateManyWithWhereWithoutUserInput = {
    where: InsurancePolicyScalarWhereInput
    data: XOR<InsurancePolicyUpdateManyMutationInput, InsurancePolicyUncheckedUpdateManyWithoutUserInput>
  }

  export type InsurancePolicyScalarWhereInput = {
    AND?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
    OR?: InsurancePolicyScalarWhereInput[]
    NOT?: InsurancePolicyScalarWhereInput | InsurancePolicyScalarWhereInput[]
    id?: StringFilter<"InsurancePolicy"> | string
    userId?: StringFilter<"InsurancePolicy"> | string
    listingId?: StringNullableFilter<"InsurancePolicy"> | string | null
    policyNumber?: StringFilter<"InsurancePolicy"> | string
    provider?: StringFilter<"InsurancePolicy"> | string
    type?: StringFilter<"InsurancePolicy"> | string
    coverageAmount?: IntFilter<"InsurancePolicy"> | number
    effectiveDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    expirationDate?: DateTimeFilter<"InsurancePolicy"> | Date | string
    documentUrl?: StringFilter<"InsurancePolicy"> | string
    certificateUrl?: StringNullableFilter<"InsurancePolicy"> | string | null
    status?: EnumInsuranceStatusFilter<"InsurancePolicy"> | $Enums.InsuranceStatus
    verificationDate?: DateTimeNullableFilter<"InsurancePolicy"> | Date | string | null
    verifiedBy?: StringNullableFilter<"InsurancePolicy"> | string | null
    notes?: StringNullableFilter<"InsurancePolicy"> | string | null
    metadata?: JsonNullableFilter<"InsurancePolicy">
    createdAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"InsurancePolicy"> | Date | string
  }

  export type DeviceTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    update: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceTokenCreateWithoutUserInput, DeviceTokenUncheckedCreateWithoutUserInput>
  }

  export type DeviceTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceTokenWhereUniqueInput
    data: XOR<DeviceTokenUpdateWithoutUserInput, DeviceTokenUncheckedUpdateWithoutUserInput>
  }

  export type DeviceTokenUpdateManyWithWhereWithoutUserInput = {
    where: DeviceTokenScalarWhereInput
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceTokenScalarWhereInput = {
    AND?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    OR?: DeviceTokenScalarWhereInput[]
    NOT?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    userId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    platform?: StringFilter<"DeviceToken"> | string
    active?: BoolFilter<"DeviceToken"> | boolean
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    preferences?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionReportUpsertWithWhereUniqueWithoutReportedByUserInput = {
    where: ConditionReportWhereUniqueInput
    update: XOR<ConditionReportUpdateWithoutReportedByUserInput, ConditionReportUncheckedUpdateWithoutReportedByUserInput>
    create: XOR<ConditionReportCreateWithoutReportedByUserInput, ConditionReportUncheckedCreateWithoutReportedByUserInput>
  }

  export type ConditionReportUpdateWithWhereUniqueWithoutReportedByUserInput = {
    where: ConditionReportWhereUniqueInput
    data: XOR<ConditionReportUpdateWithoutReportedByUserInput, ConditionReportUncheckedUpdateWithoutReportedByUserInput>
  }

  export type ConditionReportUpdateManyWithWhereWithoutReportedByUserInput = {
    where: ConditionReportScalarWhereInput
    data: XOR<ConditionReportUpdateManyMutationInput, ConditionReportUncheckedUpdateManyWithoutReportedByUserInput>
  }

  export type ConditionReportScalarWhereInput = {
    AND?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
    OR?: ConditionReportScalarWhereInput[]
    NOT?: ConditionReportScalarWhereInput | ConditionReportScalarWhereInput[]
    id?: StringFilter<"ConditionReport"> | string
    bookingId?: StringFilter<"ConditionReport"> | string
    reportType?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    type?: EnumReportTypeFilter<"ConditionReport"> | $Enums.ReportType
    reportedBy?: StringFilter<"ConditionReport"> | string
    reportedAt?: DateTimeFilter<"ConditionReport"> | Date | string
    checklistData?: JsonFilter<"ConditionReport">
    overallCondition?: StringNullableFilter<"ConditionReport"> | string | null
    condition?: StringNullableFilter<"ConditionReport"> | string | null
    notes?: StringNullableFilter<"ConditionReport"> | string | null
    damages?: JsonNullableFilter<"ConditionReport">
    issuesFound?: BoolFilter<"ConditionReport"> | boolean
    damageAmount?: FloatNullableFilter<"ConditionReport"> | number | null
    acknowledgedBy?: StringNullableFilter<"ConditionReport"> | string | null
    acknowledgedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
    disputeRaised?: BoolFilter<"ConditionReport"> | boolean
    status?: EnumReportStatusFilter<"ConditionReport"> | $Enums.ReportStatus
    createdAt?: DateTimeFilter<"ConditionReport"> | Date | string
    completedAt?: DateTimeNullableFilter<"ConditionReport"> | Date | string | null
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type OrganizationMemberCreateWithoutOrganizationInput = {
    id?: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutOrganizationsInput
  }

  export type OrganizationMemberUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type OrganizationMemberCreateOrConnectWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberCreateManyOrganizationInputEnvelope = {
    data: OrganizationMemberCreateManyOrganizationInput | OrganizationMemberCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ListingCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutOrganizationInput = {
    id?: string
    ownerId: string
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutOrganizationInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput>
  }

  export type ListingCreateManyOrganizationInputEnvelope = {
    data: ListingCreateManyOrganizationInput | ListingCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationMemberUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    update: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
    create: XOR<OrganizationMemberCreateWithoutOrganizationInput, OrganizationMemberUncheckedCreateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: OrganizationMemberWhereUniqueInput
    data: XOR<OrganizationMemberUpdateWithoutOrganizationInput, OrganizationMemberUncheckedUpdateWithoutOrganizationInput>
  }

  export type OrganizationMemberUpdateManyWithWhereWithoutOrganizationInput = {
    where: OrganizationMemberScalarWhereInput
    data: XOR<OrganizationMemberUpdateManyMutationInput, OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ListingUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutOrganizationInput, ListingUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ListingCreateWithoutOrganizationInput, ListingUncheckedCreateWithoutOrganizationInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutOrganizationInput, ListingUncheckedUpdateWithoutOrganizationInput>
  }

  export type ListingUpdateManyWithWhereWithoutOrganizationInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type OrganizationCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    listings?: ListingUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMembersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutOrganizationsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
  }

  export type OrganizationUpsertWithoutMembersInput = {
    update: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganizationCreateWithoutMembersInput, OrganizationUncheckedCreateWithoutMembersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMembersInput, OrganizationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganizationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listings?: ListingUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutOrganizationsInput = {
    update: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
    create: XOR<UserCreateWithoutOrganizationsInput, UserUncheckedCreateWithoutOrganizationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrganizationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrganizationsInput, UserUncheckedUpdateWithoutOrganizationsInput>
  }

  export type UserUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type ListingCreateWithoutCategoryInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutCategoryInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput>
  }

  export type ListingCreateManyCategoryInputEnvelope = {
    data: ListingCreateManyCategoryInput | ListingCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ListingUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutCategoryInput, ListingUncheckedUpdateWithoutCategoryInput>
    create: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutCategoryInput, ListingUncheckedUpdateWithoutCategoryInput>
  }

  export type ListingUpdateManyWithWhereWithoutCategoryInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutCategoryInput>
  }

  export type UserCreateWithoutListingsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutListingsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type OrganizationCreateWithoutListingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    logoUrl?: string | null
    websiteUrl?: string | null
    businessType?: string | null
    taxId?: string | null
    email: string
    phoneNumber?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    stripeConnectId?: string | null
    status?: $Enums.OrganizationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: OrganizationMemberUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutListingsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutListingsInput, OrganizationUncheckedCreateWithoutListingsInput>
  }

  export type CategoryCreateWithoutListingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    iconUrl?: string | null
    order?: number
    active?: boolean
    templateSchema: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: $Enums.PricingMode
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: number
    insuranceRequired?: boolean
    minimumInsuranceAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    iconUrl?: string | null
    order?: number
    active?: boolean
    templateSchema: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: $Enums.PricingMode
    allowInstantBook?: boolean
    requiresDepositDefault?: boolean
    defaultDepositPercentage?: number
    insuranceRequired?: boolean
    minimumInsuranceAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutListingsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
  }

  export type CancellationPolicyCreateWithoutListingsInput = {
    id?: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationPolicyUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
    type: $Enums.CancellationPolicyType
    description: string
    rules: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationPolicyCreateOrConnectWithoutListingsInput = {
    where: CancellationPolicyWhereUniqueInput
    create: XOR<CancellationPolicyCreateWithoutListingsInput, CancellationPolicyUncheckedCreateWithoutListingsInput>
  }

  export type AvailabilityCreateWithoutListingInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
  }

  export type AvailabilityUncheckedCreateWithoutListingInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
  }

  export type AvailabilityCreateOrConnectWithoutListingInput = {
    where: AvailabilityWhereUniqueInput
    create: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput>
  }

  export type AvailabilityCreateManyListingInputEnvelope = {
    data: AvailabilityCreateManyListingInput | AvailabilityCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutListingInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutListingInput = {
    id?: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutListingInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput>
  }

  export type BookingCreateManyListingInputEnvelope = {
    data: BookingCreateManyListingInput | BookingCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutListingInput = {
    id?: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewee: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutListingInput = {
    id?: string
    bookingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutListingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput>
  }

  export type ReviewCreateManyListingInputEnvelope = {
    data: ReviewCreateManyListingInput | ReviewCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteListingCreateWithoutListingInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoriteListingsInput
  }

  export type FavoriteListingUncheckedCreateWithoutListingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type FavoriteListingCreateOrConnectWithoutListingInput = {
    where: FavoriteListingWhereUniqueInput
    create: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput>
  }

  export type FavoriteListingCreateManyListingInputEnvelope = {
    data: FavoriteListingCreateManyListingInput | FavoriteListingCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type InsurancePolicyCreateWithoutListingInput = {
    id?: string
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsurancePoliciesInput
  }

  export type InsurancePolicyUncheckedCreateWithoutListingInput = {
    id?: string
    userId: string
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsurancePolicyCreateOrConnectWithoutListingInput = {
    where: InsurancePolicyWhereUniqueInput
    create: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput>
  }

  export type InsurancePolicyCreateManyListingInputEnvelope = {
    data: InsurancePolicyCreateManyListingInput | InsurancePolicyCreateManyListingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutListingsInput = {
    update: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type OrganizationUpsertWithoutListingsInput = {
    update: XOR<OrganizationUpdateWithoutListingsInput, OrganizationUncheckedUpdateWithoutListingsInput>
    create: XOR<OrganizationCreateWithoutListingsInput, OrganizationUncheckedCreateWithoutListingsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutListingsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutListingsInput, OrganizationUncheckedUpdateWithoutListingsInput>
  }

  export type OrganizationUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    websiteUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessType?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumOrganizationStatusFieldUpdateOperationsInput | $Enums.OrganizationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: OrganizationMemberUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CategoryUpsertWithoutListingsInput = {
    update: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutListingsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
  }

  export type CategoryUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    templateSchema?: JsonNullValueInput | InputJsonValue
    searchableFields?: JsonNullValueInput | InputJsonValue
    requiredFields?: JsonNullValueInput | InputJsonValue
    defaultPricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    allowInstantBook?: BoolFieldUpdateOperationsInput | boolean
    requiresDepositDefault?: BoolFieldUpdateOperationsInput | boolean
    defaultDepositPercentage?: FloatFieldUpdateOperationsInput | number
    insuranceRequired?: BoolFieldUpdateOperationsInput | boolean
    minimumInsuranceAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyUpsertWithoutListingsInput = {
    update: XOR<CancellationPolicyUpdateWithoutListingsInput, CancellationPolicyUncheckedUpdateWithoutListingsInput>
    create: XOR<CancellationPolicyCreateWithoutListingsInput, CancellationPolicyUncheckedCreateWithoutListingsInput>
    where?: CancellationPolicyWhereInput
  }

  export type CancellationPolicyUpdateToOneWithWhereWithoutListingsInput = {
    where?: CancellationPolicyWhereInput
    data: XOR<CancellationPolicyUpdateWithoutListingsInput, CancellationPolicyUncheckedUpdateWithoutListingsInput>
  }

  export type CancellationPolicyUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationPolicyUncheckedUpdateWithoutListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumCancellationPolicyTypeFieldUpdateOperationsInput | $Enums.CancellationPolicyType
    description?: StringFieldUpdateOperationsInput | string
    rules?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUpsertWithWhereUniqueWithoutListingInput = {
    where: AvailabilityWhereUniqueInput
    update: XOR<AvailabilityUpdateWithoutListingInput, AvailabilityUncheckedUpdateWithoutListingInput>
    create: XOR<AvailabilityCreateWithoutListingInput, AvailabilityUncheckedCreateWithoutListingInput>
  }

  export type AvailabilityUpdateWithWhereUniqueWithoutListingInput = {
    where: AvailabilityWhereUniqueInput
    data: XOR<AvailabilityUpdateWithoutListingInput, AvailabilityUncheckedUpdateWithoutListingInput>
  }

  export type AvailabilityUpdateManyWithWhereWithoutListingInput = {
    where: AvailabilityScalarWhereInput
    data: XOR<AvailabilityUpdateManyMutationInput, AvailabilityUncheckedUpdateManyWithoutListingInput>
  }

  export type AvailabilityScalarWhereInput = {
    AND?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    OR?: AvailabilityScalarWhereInput[]
    NOT?: AvailabilityScalarWhereInput | AvailabilityScalarWhereInput[]
    id?: StringFilter<"Availability"> | string
    listingId?: StringFilter<"Availability"> | string
    startDate?: DateTimeFilter<"Availability"> | Date | string
    endDate?: DateTimeFilter<"Availability"> | Date | string
    available?: BoolFilter<"Availability"> | boolean
    price?: FloatNullableFilter<"Availability"> | number | null
    minStay?: IntNullableFilter<"Availability"> | number | null
    createdAt?: DateTimeFilter<"Availability"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutListingInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutListingInput, BookingUncheckedUpdateWithoutListingInput>
    create: XOR<BookingCreateWithoutListingInput, BookingUncheckedCreateWithoutListingInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutListingInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutListingInput, BookingUncheckedUpdateWithoutListingInput>
  }

  export type BookingUpdateManyWithWhereWithoutListingInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutListingInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutListingInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutListingInput, ReviewUncheckedUpdateWithoutListingInput>
    create: XOR<ReviewCreateWithoutListingInput, ReviewUncheckedCreateWithoutListingInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutListingInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutListingInput, ReviewUncheckedUpdateWithoutListingInput>
  }

  export type ReviewUpdateManyWithWhereWithoutListingInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutListingInput>
  }

  export type FavoriteListingUpsertWithWhereUniqueWithoutListingInput = {
    where: FavoriteListingWhereUniqueInput
    update: XOR<FavoriteListingUpdateWithoutListingInput, FavoriteListingUncheckedUpdateWithoutListingInput>
    create: XOR<FavoriteListingCreateWithoutListingInput, FavoriteListingUncheckedCreateWithoutListingInput>
  }

  export type FavoriteListingUpdateWithWhereUniqueWithoutListingInput = {
    where: FavoriteListingWhereUniqueInput
    data: XOR<FavoriteListingUpdateWithoutListingInput, FavoriteListingUncheckedUpdateWithoutListingInput>
  }

  export type FavoriteListingUpdateManyWithWhereWithoutListingInput = {
    where: FavoriteListingScalarWhereInput
    data: XOR<FavoriteListingUpdateManyMutationInput, FavoriteListingUncheckedUpdateManyWithoutListingInput>
  }

  export type InsurancePolicyUpsertWithWhereUniqueWithoutListingInput = {
    where: InsurancePolicyWhereUniqueInput
    update: XOR<InsurancePolicyUpdateWithoutListingInput, InsurancePolicyUncheckedUpdateWithoutListingInput>
    create: XOR<InsurancePolicyCreateWithoutListingInput, InsurancePolicyUncheckedCreateWithoutListingInput>
  }

  export type InsurancePolicyUpdateWithWhereUniqueWithoutListingInput = {
    where: InsurancePolicyWhereUniqueInput
    data: XOR<InsurancePolicyUpdateWithoutListingInput, InsurancePolicyUncheckedUpdateWithoutListingInput>
  }

  export type InsurancePolicyUpdateManyWithWhereWithoutListingInput = {
    where: InsurancePolicyScalarWhereInput
    data: XOR<InsurancePolicyUpdateManyMutationInput, InsurancePolicyUncheckedUpdateManyWithoutListingInput>
  }

  export type ListingCreateWithoutCancellationPolicyInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutCancellationPolicyInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutCancellationPolicyInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput>
  }

  export type ListingCreateManyCancellationPolicyInputEnvelope = {
    data: ListingCreateManyCancellationPolicyInput | ListingCreateManyCancellationPolicyInput[]
    skipDuplicates?: boolean
  }

  export type ListingUpsertWithWhereUniqueWithoutCancellationPolicyInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutCancellationPolicyInput, ListingUncheckedUpdateWithoutCancellationPolicyInput>
    create: XOR<ListingCreateWithoutCancellationPolicyInput, ListingUncheckedCreateWithoutCancellationPolicyInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutCancellationPolicyInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutCancellationPolicyInput, ListingUncheckedUpdateWithoutCancellationPolicyInput>
  }

  export type ListingUpdateManyWithWhereWithoutCancellationPolicyInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutCancellationPolicyInput>
  }

  export type ListingCreateWithoutAvailabilityInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutAvailabilityInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutAvailabilityInput, ListingUncheckedCreateWithoutAvailabilityInput>
  }

  export type ListingUpsertWithoutAvailabilityInput = {
    update: XOR<ListingUpdateWithoutAvailabilityInput, ListingUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<ListingCreateWithoutAvailabilityInput, ListingUncheckedCreateWithoutAvailabilityInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutAvailabilityInput, ListingUncheckedUpdateWithoutAvailabilityInput>
  }

  export type ListingUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserCreateWithoutFavoriteListingsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutFavoriteListingsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutFavoriteListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoriteListingsInput, UserUncheckedCreateWithoutFavoriteListingsInput>
  }

  export type ListingCreateWithoutFavoritesInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutFavoritesInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutFavoritesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoriteListingsInput = {
    update: XOR<UserUpdateWithoutFavoriteListingsInput, UserUncheckedUpdateWithoutFavoriteListingsInput>
    create: XOR<UserCreateWithoutFavoriteListingsInput, UserUncheckedCreateWithoutFavoriteListingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoriteListingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoriteListingsInput, UserUncheckedUpdateWithoutFavoriteListingsInput>
  }

  export type UserUpdateWithoutFavoriteListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoriteListingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type ListingUpsertWithoutFavoritesInput = {
    update: XOR<ListingUpdateWithoutFavoritesInput, ListingUncheckedUpdateWithoutFavoritesInput>
    create: XOR<ListingCreateWithoutFavoritesInput, ListingUncheckedCreateWithoutFavoritesInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutFavoritesInput, ListingUncheckedUpdateWithoutFavoritesInput>
  }

  export type ListingUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutFavoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingCreateWithoutBookingsInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutBookingsInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutBookingsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutBookingsInput, ListingUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsAsRenterInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutBookingsAsRenterInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutBookingsAsRenterInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsAsRenterInput, UserUncheckedCreateWithoutBookingsAsRenterInput>
  }

  export type UserCreateWithoutBookingsAsOwnerInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutBookingsAsOwnerInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutBookingsAsOwnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsAsOwnerInput, UserUncheckedCreateWithoutBookingsAsOwnerInput>
  }

  export type BookingStateHistoryCreateWithoutBookingInput = {
    id?: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type BookingStateHistoryUncheckedCreateWithoutBookingInput = {
    id?: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type BookingStateHistoryCreateOrConnectWithoutBookingInput = {
    where: BookingStateHistoryWhereUniqueInput
    create: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingStateHistoryCreateManyBookingInputEnvelope = {
    data: BookingStateHistoryCreateManyBookingInput | BookingStateHistoryCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type LedgerEntryCreateWithoutBookingInput = {
    id?: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type LedgerEntryUncheckedCreateWithoutBookingInput = {
    id?: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type LedgerEntryCreateOrConnectWithoutBookingInput = {
    where: LedgerEntryWhereUniqueInput
    create: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput>
  }

  export type LedgerEntryCreateManyBookingInputEnvelope = {
    data: LedgerEntryCreateManyBookingInput | LedgerEntryCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type DepositHoldCreateWithoutBookingsInput = {
    id?: string
    bookingId?: string | null
    amount: number
    currency?: string
    paymentIntentId: string
    status?: $Enums.DepositStatus
    authorizedAt?: Date | string
    capturedAt?: Date | string | null
    releasedAt?: Date | string | null
    deductedAmount?: number
    deductionReason?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DepositHoldUncheckedCreateWithoutBookingsInput = {
    id?: string
    bookingId?: string | null
    amount: number
    currency?: string
    paymentIntentId: string
    status?: $Enums.DepositStatus
    authorizedAt?: Date | string
    capturedAt?: Date | string | null
    releasedAt?: Date | string | null
    deductedAmount?: number
    deductionReason?: string | null
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type DepositHoldCreateOrConnectWithoutBookingsInput = {
    where: DepositHoldWhereUniqueInput
    create: XOR<DepositHoldCreateWithoutBookingsInput, DepositHoldUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ConditionReportCreateWithoutBookingInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoCreateNestedManyWithoutReportInput
    reportedByUser: UserCreateNestedOneWithoutConditionReportsReportedInput
    dispute?: DisputeCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportUncheckedCreateWithoutBookingInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoUncheckedCreateNestedManyWithoutReportInput
    dispute?: DisputeUncheckedCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportCreateOrConnectWithoutBookingInput = {
    where: ConditionReportWhereUniqueInput
    create: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput>
  }

  export type ConditionReportCreateManyBookingInputEnvelope = {
    data: ConditionReportCreateManyBookingInput | ConditionReportCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutBookingInput = {
    id?: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    listing: ListingCreateNestedOneWithoutReviewsInput
    reviewer: UserCreateNestedOneWithoutReviewsGivenInput
    reviewee: UserCreateNestedOneWithoutReviewsReceivedInput
  }

  export type ReviewUncheckedCreateWithoutBookingInput = {
    id?: string
    listingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewCreateManyBookingInputEnvelope = {
    data: ReviewCreateManyBookingInput | ReviewCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type DisputeCreateWithoutBookingInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutBookingInput = {
    id?: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutBookingInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput>
  }

  export type DisputeCreateManyBookingInputEnvelope = {
    data: DisputeCreateManyBookingInput | DisputeCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutBookingInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutBookingInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutBookingInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput>
  }

  export type ConversationCreateManyBookingInputEnvelope = {
    data: ConversationCreateManyBookingInput | ConversationCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type ListingUpsertWithoutBookingsInput = {
    update: XOR<ListingUpdateWithoutBookingsInput, ListingUncheckedUpdateWithoutBookingsInput>
    create: XOR<ListingCreateWithoutBookingsInput, ListingUncheckedCreateWithoutBookingsInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutBookingsInput, ListingUncheckedUpdateWithoutBookingsInput>
  }

  export type ListingUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserUpsertWithoutBookingsAsRenterInput = {
    update: XOR<UserUpdateWithoutBookingsAsRenterInput, UserUncheckedUpdateWithoutBookingsAsRenterInput>
    create: XOR<UserCreateWithoutBookingsAsRenterInput, UserUncheckedCreateWithoutBookingsAsRenterInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsAsRenterInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsAsRenterInput, UserUncheckedUpdateWithoutBookingsAsRenterInput>
  }

  export type UserUpdateWithoutBookingsAsRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsAsRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUpsertWithoutBookingsAsOwnerInput = {
    update: XOR<UserUpdateWithoutBookingsAsOwnerInput, UserUncheckedUpdateWithoutBookingsAsOwnerInput>
    create: XOR<UserCreateWithoutBookingsAsOwnerInput, UserUncheckedCreateWithoutBookingsAsOwnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsAsOwnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsAsOwnerInput, UserUncheckedUpdateWithoutBookingsAsOwnerInput>
  }

  export type UserUpdateWithoutBookingsAsOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsAsOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type BookingStateHistoryUpsertWithWhereUniqueWithoutBookingInput = {
    where: BookingStateHistoryWhereUniqueInput
    update: XOR<BookingStateHistoryUpdateWithoutBookingInput, BookingStateHistoryUncheckedUpdateWithoutBookingInput>
    create: XOR<BookingStateHistoryCreateWithoutBookingInput, BookingStateHistoryUncheckedCreateWithoutBookingInput>
  }

  export type BookingStateHistoryUpdateWithWhereUniqueWithoutBookingInput = {
    where: BookingStateHistoryWhereUniqueInput
    data: XOR<BookingStateHistoryUpdateWithoutBookingInput, BookingStateHistoryUncheckedUpdateWithoutBookingInput>
  }

  export type BookingStateHistoryUpdateManyWithWhereWithoutBookingInput = {
    where: BookingStateHistoryScalarWhereInput
    data: XOR<BookingStateHistoryUpdateManyMutationInput, BookingStateHistoryUncheckedUpdateManyWithoutBookingInput>
  }

  export type BookingStateHistoryScalarWhereInput = {
    AND?: BookingStateHistoryScalarWhereInput | BookingStateHistoryScalarWhereInput[]
    OR?: BookingStateHistoryScalarWhereInput[]
    NOT?: BookingStateHistoryScalarWhereInput | BookingStateHistoryScalarWhereInput[]
    id?: StringFilter<"BookingStateHistory"> | string
    bookingId?: StringFilter<"BookingStateHistory"> | string
    fromState?: EnumBookingStatusNullableFilter<"BookingStateHistory"> | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFilter<"BookingStateHistory"> | $Enums.BookingStatus
    reason?: StringNullableFilter<"BookingStateHistory"> | string | null
    metadata?: JsonFilter<"BookingStateHistory">
    changedBy?: StringNullableFilter<"BookingStateHistory"> | string | null
    createdAt?: DateTimeFilter<"BookingStateHistory"> | Date | string
  }

  export type LedgerEntryUpsertWithWhereUniqueWithoutBookingInput = {
    where: LedgerEntryWhereUniqueInput
    update: XOR<LedgerEntryUpdateWithoutBookingInput, LedgerEntryUncheckedUpdateWithoutBookingInput>
    create: XOR<LedgerEntryCreateWithoutBookingInput, LedgerEntryUncheckedCreateWithoutBookingInput>
  }

  export type LedgerEntryUpdateWithWhereUniqueWithoutBookingInput = {
    where: LedgerEntryWhereUniqueInput
    data: XOR<LedgerEntryUpdateWithoutBookingInput, LedgerEntryUncheckedUpdateWithoutBookingInput>
  }

  export type LedgerEntryUpdateManyWithWhereWithoutBookingInput = {
    where: LedgerEntryScalarWhereInput
    data: XOR<LedgerEntryUpdateManyMutationInput, LedgerEntryUncheckedUpdateManyWithoutBookingInput>
  }

  export type LedgerEntryScalarWhereInput = {
    AND?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    OR?: LedgerEntryScalarWhereInput[]
    NOT?: LedgerEntryScalarWhereInput | LedgerEntryScalarWhereInput[]
    id?: StringFilter<"LedgerEntry"> | string
    bookingId?: StringFilter<"LedgerEntry"> | string
    accountType?: StringFilter<"LedgerEntry"> | string
    side?: EnumLedgerSideFilter<"LedgerEntry"> | $Enums.LedgerSide
    amount?: FloatFilter<"LedgerEntry"> | number
    currency?: StringFilter<"LedgerEntry"> | string
    transactionType?: StringFilter<"LedgerEntry"> | string
    description?: StringFilter<"LedgerEntry"> | string
    referenceId?: StringNullableFilter<"LedgerEntry"> | string | null
    status?: EnumLedgerEntryStatusFilter<"LedgerEntry"> | $Enums.LedgerEntryStatus
    metadata?: JsonFilter<"LedgerEntry">
    createdAt?: DateTimeFilter<"LedgerEntry"> | Date | string
    settledAt?: DateTimeNullableFilter<"LedgerEntry"> | Date | string | null
  }

  export type DepositHoldUpsertWithoutBookingsInput = {
    update: XOR<DepositHoldUpdateWithoutBookingsInput, DepositHoldUncheckedUpdateWithoutBookingsInput>
    create: XOR<DepositHoldCreateWithoutBookingsInput, DepositHoldUncheckedCreateWithoutBookingsInput>
    where?: DepositHoldWhereInput
  }

  export type DepositHoldUpdateToOneWithWhereWithoutBookingsInput = {
    where?: DepositHoldWhereInput
    data: XOR<DepositHoldUpdateWithoutBookingsInput, DepositHoldUncheckedUpdateWithoutBookingsInput>
  }

  export type DepositHoldUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepositHoldUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    paymentIntentId?: StringFieldUpdateOperationsInput | string
    status?: EnumDepositStatusFieldUpdateOperationsInput | $Enums.DepositStatus
    authorizedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    releasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deductedAmount?: FloatFieldUpdateOperationsInput | number
    deductionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    failureReason?: StringNullableFilter<"Payment"> | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ConditionReportUpsertWithWhereUniqueWithoutBookingInput = {
    where: ConditionReportWhereUniqueInput
    update: XOR<ConditionReportUpdateWithoutBookingInput, ConditionReportUncheckedUpdateWithoutBookingInput>
    create: XOR<ConditionReportCreateWithoutBookingInput, ConditionReportUncheckedCreateWithoutBookingInput>
  }

  export type ConditionReportUpdateWithWhereUniqueWithoutBookingInput = {
    where: ConditionReportWhereUniqueInput
    data: XOR<ConditionReportUpdateWithoutBookingInput, ConditionReportUncheckedUpdateWithoutBookingInput>
  }

  export type ConditionReportUpdateManyWithWhereWithoutBookingInput = {
    where: ConditionReportScalarWhereInput
    data: XOR<ConditionReportUpdateManyMutationInput, ConditionReportUncheckedUpdateManyWithoutBookingInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBookingInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutBookingInput>
  }

  export type DisputeUpsertWithWhereUniqueWithoutBookingInput = {
    where: DisputeWhereUniqueInput
    update: XOR<DisputeUpdateWithoutBookingInput, DisputeUncheckedUpdateWithoutBookingInput>
    create: XOR<DisputeCreateWithoutBookingInput, DisputeUncheckedCreateWithoutBookingInput>
  }

  export type DisputeUpdateWithWhereUniqueWithoutBookingInput = {
    where: DisputeWhereUniqueInput
    data: XOR<DisputeUpdateWithoutBookingInput, DisputeUncheckedUpdateWithoutBookingInput>
  }

  export type DisputeUpdateManyWithWhereWithoutBookingInput = {
    where: DisputeScalarWhereInput
    data: XOR<DisputeUpdateManyMutationInput, DisputeUncheckedUpdateManyWithoutBookingInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutBookingInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutBookingInput, ConversationUncheckedUpdateWithoutBookingInput>
    create: XOR<ConversationCreateWithoutBookingInput, ConversationUncheckedCreateWithoutBookingInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutBookingInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutBookingInput, ConversationUncheckedUpdateWithoutBookingInput>
  }

  export type ConversationUpdateManyWithWhereWithoutBookingInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutBookingInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    bookingId?: StringNullableFilter<"Conversation"> | string | null
    listingId?: StringNullableFilter<"Conversation"> | string | null
    type?: EnumConversationTypeFilter<"Conversation"> | $Enums.ConversationType
    subject?: StringNullableFilter<"Conversation"> | string | null
    lastMessageAt?: DateTimeNullableFilter<"Conversation"> | Date | string | null
    lastMessagePreview?: StringNullableFilter<"Conversation"> | string | null
    status?: EnumConversationStatusFilter<"Conversation"> | $Enums.ConversationStatus
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type BookingCreateWithoutStateHistoryInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutStateHistoryInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutStateHistoryInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutStateHistoryInput, BookingUncheckedCreateWithoutStateHistoryInput>
  }

  export type BookingUpsertWithoutStateHistoryInput = {
    update: XOR<BookingUpdateWithoutStateHistoryInput, BookingUncheckedUpdateWithoutStateHistoryInput>
    create: XOR<BookingCreateWithoutStateHistoryInput, BookingUncheckedCreateWithoutStateHistoryInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutStateHistoryInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutStateHistoryInput, BookingUncheckedUpdateWithoutStateHistoryInput>
  }

  export type BookingUpdateWithoutStateHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutStateHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutLedgerEntriesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutLedgerEntriesInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutLedgerEntriesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutLedgerEntriesInput, BookingUncheckedCreateWithoutLedgerEntriesInput>
  }

  export type BookingUpsertWithoutLedgerEntriesInput = {
    update: XOR<BookingUpdateWithoutLedgerEntriesInput, BookingUncheckedUpdateWithoutLedgerEntriesInput>
    create: XOR<BookingCreateWithoutLedgerEntriesInput, BookingUncheckedCreateWithoutLedgerEntriesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutLedgerEntriesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutLedgerEntriesInput, BookingUncheckedUpdateWithoutLedgerEntriesInput>
  }

  export type BookingUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutLedgerEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutDepositHoldInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutDepositHoldInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutDepositHoldInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput>
  }

  export type BookingCreateManyDepositHoldInputEnvelope = {
    data: BookingCreateManyDepositHoldInput | BookingCreateManyDepositHoldInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithWhereUniqueWithoutDepositHoldInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDepositHoldInput, BookingUncheckedUpdateWithoutDepositHoldInput>
    create: XOR<BookingCreateWithoutDepositHoldInput, BookingUncheckedCreateWithoutDepositHoldInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDepositHoldInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDepositHoldInput, BookingUncheckedUpdateWithoutDepositHoldInput>
  }

  export type BookingUpdateManyWithWhereWithoutDepositHoldInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDepositHoldInput>
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutReviewsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutReviewsInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReviewsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
  }

  export type ListingCreateWithoutReviewsInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutReviewsInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutReviewsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutReviewsInput, ListingUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsGivenInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutReviewsGivenInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutReviewsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
  }

  export type UserCreateWithoutReviewsReceivedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutReviewsReceivedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutReviewsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
  }

  export type BookingUpsertWithoutReviewsInput = {
    update: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ListingUpsertWithoutReviewsInput = {
    update: XOR<ListingUpdateWithoutReviewsInput, ListingUncheckedUpdateWithoutReviewsInput>
    create: XOR<ListingCreateWithoutReviewsInput, ListingUncheckedCreateWithoutReviewsInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutReviewsInput, ListingUncheckedUpdateWithoutReviewsInput>
  }

  export type ListingUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserUpsertWithoutReviewsGivenInput = {
    update: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
    create: XOR<UserCreateWithoutReviewsGivenInput, UserUncheckedCreateWithoutReviewsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsGivenInput, UserUncheckedUpdateWithoutReviewsGivenInput>
  }

  export type UserUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUpsertWithoutReviewsReceivedInput = {
    update: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
    create: XOR<UserCreateWithoutReviewsReceivedInput, UserUncheckedCreateWithoutReviewsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsReceivedInput, UserUncheckedUpdateWithoutReviewsReceivedInput>
  }

  export type UserUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type BookingCreateWithoutConversationsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutConversationsInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutConversationsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutConversationsInput, BookingUncheckedCreateWithoutConversationsInput>
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    id?: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    userId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    sender: UserCreateNestedOneWithoutMessagesInput
    readReceipts?: MessageReadReceiptCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    readReceipts?: MessageReadReceiptUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutConversationsInput = {
    update: XOR<BookingUpdateWithoutConversationsInput, BookingUncheckedUpdateWithoutConversationsInput>
    create: XOR<BookingCreateWithoutConversationsInput, BookingUncheckedCreateWithoutConversationsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutConversationsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutConversationsInput, BookingUncheckedUpdateWithoutConversationsInput>
  }

  export type BookingUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    bookingId?: string | null
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type UserCreateWithoutConversationParticipantsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutConversationParticipantsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutConversationParticipantsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationParticipantsInput, UserUncheckedCreateWithoutConversationParticipantsInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutConversationParticipantsInput = {
    update: XOR<UserUpdateWithoutConversationParticipantsInput, UserUncheckedUpdateWithoutConversationParticipantsInput>
    create: XOR<UserCreateWithoutConversationParticipantsInput, UserUncheckedCreateWithoutConversationParticipantsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationParticipantsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationParticipantsInput, UserUncheckedUpdateWithoutConversationParticipantsInput>
  }

  export type UserUpdateWithoutConversationParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutConversationsInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    bookingId?: string | null
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type MessageReadReceiptCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptCreateOrConnectWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    create: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadReceiptCreateManyMessageInputEnvelope = {
    data: MessageReadReceiptCreateManyMessageInput | MessageReadReceiptCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutConversationsNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type MessageReadReceiptUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    update: XOR<MessageReadReceiptUpdateWithoutMessageInput, MessageReadReceiptUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadReceiptCreateWithoutMessageInput, MessageReadReceiptUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadReceiptUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadReceiptWhereUniqueInput
    data: XOR<MessageReadReceiptUpdateWithoutMessageInput, MessageReadReceiptUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadReceiptUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadReceiptScalarWhereInput
    data: XOR<MessageReadReceiptUpdateManyMutationInput, MessageReadReceiptUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageReadReceiptScalarWhereInput = {
    AND?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
    OR?: MessageReadReceiptScalarWhereInput[]
    NOT?: MessageReadReceiptScalarWhereInput | MessageReadReceiptScalarWhereInput[]
    id?: StringFilter<"MessageReadReceipt"> | string
    messageId?: StringFilter<"MessageReadReceipt"> | string
    userId?: StringFilter<"MessageReadReceipt"> | string
    readAt?: DateTimeFilter<"MessageReadReceipt"> | Date | string
  }

  export type MessageCreateWithoutReadReceiptsInput = {
    id?: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutReadReceiptsInput = {
    id?: string
    conversationId: string
    senderId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutReadReceiptsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadReceiptsInput, MessageUncheckedCreateWithoutReadReceiptsInput>
  }

  export type MessageUpsertWithoutReadReceiptsInput = {
    update: XOR<MessageUpdateWithoutReadReceiptsInput, MessageUncheckedUpdateWithoutReadReceiptsInput>
    create: XOR<MessageCreateWithoutReadReceiptsInput, MessageUncheckedCreateWithoutReadReceiptsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReadReceiptsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReadReceiptsInput, MessageUncheckedUpdateWithoutReadReceiptsInput>
  }

  export type MessageUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadReceiptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportPhotoCreateWithoutReportInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
  }

  export type ReportPhotoUncheckedCreateWithoutReportInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
  }

  export type ReportPhotoCreateOrConnectWithoutReportInput = {
    where: ReportPhotoWhereUniqueInput
    create: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput>
  }

  export type ReportPhotoCreateManyReportInputEnvelope = {
    data: ReportPhotoCreateManyReportInput | ReportPhotoCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutConditionReportsInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    disputes?: DisputeCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutConditionReportsInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    disputes?: DisputeUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutConditionReportsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutConditionReportsInput, BookingUncheckedCreateWithoutConditionReportsInput>
  }

  export type UserCreateWithoutConditionReportsReportedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConditionReportsReportedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConditionReportsReportedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConditionReportsReportedInput, UserUncheckedCreateWithoutConditionReportsReportedInput>
  }

  export type DisputeCreateWithoutConditionReportInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutConditionReportInput = {
    id?: string
    bookingId: string
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutConditionReportInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
  }

  export type ReportPhotoUpsertWithWhereUniqueWithoutReportInput = {
    where: ReportPhotoWhereUniqueInput
    update: XOR<ReportPhotoUpdateWithoutReportInput, ReportPhotoUncheckedUpdateWithoutReportInput>
    create: XOR<ReportPhotoCreateWithoutReportInput, ReportPhotoUncheckedCreateWithoutReportInput>
  }

  export type ReportPhotoUpdateWithWhereUniqueWithoutReportInput = {
    where: ReportPhotoWhereUniqueInput
    data: XOR<ReportPhotoUpdateWithoutReportInput, ReportPhotoUncheckedUpdateWithoutReportInput>
  }

  export type ReportPhotoUpdateManyWithWhereWithoutReportInput = {
    where: ReportPhotoScalarWhereInput
    data: XOR<ReportPhotoUpdateManyMutationInput, ReportPhotoUncheckedUpdateManyWithoutReportInput>
  }

  export type ReportPhotoScalarWhereInput = {
    AND?: ReportPhotoScalarWhereInput | ReportPhotoScalarWhereInput[]
    OR?: ReportPhotoScalarWhereInput[]
    NOT?: ReportPhotoScalarWhereInput | ReportPhotoScalarWhereInput[]
    id?: StringFilter<"ReportPhoto"> | string
    reportId?: StringFilter<"ReportPhoto"> | string
    url?: StringFilter<"ReportPhoto"> | string
    thumbnailUrl?: StringNullableFilter<"ReportPhoto"> | string | null
    caption?: StringNullableFilter<"ReportPhoto"> | string | null
    tags?: JsonFilter<"ReportPhoto">
    metadata?: JsonFilter<"ReportPhoto">
    order?: IntFilter<"ReportPhoto"> | number
    uploadedAt?: DateTimeFilter<"ReportPhoto"> | Date | string
  }

  export type BookingUpsertWithoutConditionReportsInput = {
    update: XOR<BookingUpdateWithoutConditionReportsInput, BookingUncheckedUpdateWithoutConditionReportsInput>
    create: XOR<BookingCreateWithoutConditionReportsInput, BookingUncheckedCreateWithoutConditionReportsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutConditionReportsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutConditionReportsInput, BookingUncheckedUpdateWithoutConditionReportsInput>
  }

  export type BookingUpdateWithoutConditionReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutConditionReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutConditionReportsReportedInput = {
    update: XOR<UserUpdateWithoutConditionReportsReportedInput, UserUncheckedUpdateWithoutConditionReportsReportedInput>
    create: XOR<UserCreateWithoutConditionReportsReportedInput, UserUncheckedCreateWithoutConditionReportsReportedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConditionReportsReportedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConditionReportsReportedInput, UserUncheckedUpdateWithoutConditionReportsReportedInput>
  }

  export type UserUpdateWithoutConditionReportsReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConditionReportsReportedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
  }

  export type DisputeUpsertWithoutConditionReportInput = {
    update: XOR<DisputeUpdateWithoutConditionReportInput, DisputeUncheckedUpdateWithoutConditionReportInput>
    create: XOR<DisputeCreateWithoutConditionReportInput, DisputeUncheckedCreateWithoutConditionReportInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutConditionReportInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutConditionReportInput, DisputeUncheckedUpdateWithoutConditionReportInput>
  }

  export type DisputeUpdateWithoutConditionReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutConditionReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type ConditionReportCreateWithoutPhotosInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    booking: BookingCreateNestedOneWithoutConditionReportsInput
    reportedByUser: UserCreateNestedOneWithoutConditionReportsReportedInput
    dispute?: DisputeCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportUncheckedCreateWithoutPhotosInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    dispute?: DisputeUncheckedCreateNestedOneWithoutConditionReportInput
  }

  export type ConditionReportCreateOrConnectWithoutPhotosInput = {
    where: ConditionReportWhereUniqueInput
    create: XOR<ConditionReportCreateWithoutPhotosInput, ConditionReportUncheckedCreateWithoutPhotosInput>
  }

  export type ConditionReportUpsertWithoutPhotosInput = {
    update: XOR<ConditionReportUpdateWithoutPhotosInput, ConditionReportUncheckedUpdateWithoutPhotosInput>
    create: XOR<ConditionReportCreateWithoutPhotosInput, ConditionReportUncheckedCreateWithoutPhotosInput>
    where?: ConditionReportWhereInput
  }

  export type ConditionReportUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ConditionReportWhereInput
    data: XOR<ConditionReportUpdateWithoutPhotosInput, ConditionReportUncheckedUpdateWithoutPhotosInput>
  }

  export type ConditionReportUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    booking?: BookingUpdateOneRequiredWithoutConditionReportsNestedInput
    reportedByUser?: UserUpdateOneRequiredWithoutConditionReportsReportedNestedInput
    dispute?: DisputeUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateWithoutPhotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispute?: DisputeUncheckedUpdateOneWithoutConditionReportNestedInput
  }

  export type DisputeResolutionCreateWithoutDisputeInput = {
    id?: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount?: number | null
    payoutAdjustment?: number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy: string
    resolvedAt?: Date | string
  }

  export type DisputeResolutionUncheckedCreateWithoutDisputeInput = {
    id?: string
    outcome: $Enums.ResolutionOutcome
    summary: string
    refundAmount?: number | null
    payoutAdjustment?: number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy: string
    resolvedAt?: Date | string
  }

  export type DisputeResolutionCreateOrConnectWithoutDisputeInput = {
    where: DisputeResolutionWhereUniqueInput
    create: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
  }

  export type BookingCreateWithoutDisputesInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    listing: ListingCreateNestedOneWithoutBookingsInput
    renter: UserCreateNestedOneWithoutBookingsAsRenterInput
    owner: UserCreateNestedOneWithoutBookingsAsOwnerInput
    stateHistory?: BookingStateHistoryCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryCreateNestedManyWithoutBookingInput
    depositHold?: DepositHoldCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    conversations?: ConversationCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutDisputesInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
    stateHistory?: BookingStateHistoryUncheckedCreateNestedManyWithoutBookingInput
    ledgerEntries?: LedgerEntryUncheckedCreateNestedManyWithoutBookingInput
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    conditionReports?: ConditionReportUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutDisputesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDisputesInput, BookingUncheckedCreateWithoutDisputesInput>
  }

  export type ConditionReportCreateWithoutDisputeInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoCreateNestedManyWithoutReportInput
    booking: BookingCreateNestedOneWithoutConditionReportsInput
    reportedByUser: UserCreateNestedOneWithoutConditionReportsReportedInput
  }

  export type ConditionReportUncheckedCreateWithoutDisputeInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
    photos?: ReportPhotoUncheckedCreateNestedManyWithoutReportInput
  }

  export type ConditionReportCreateOrConnectWithoutDisputeInput = {
    where: ConditionReportWhereUniqueInput
    create: XOR<ConditionReportCreateWithoutDisputeInput, ConditionReportUncheckedCreateWithoutDisputeInput>
  }

  export type UserCreateWithoutDisputesInitiatedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutDisputesInitiatedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutDisputesInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisputesInitiatedInput, UserUncheckedCreateWithoutDisputesInitiatedInput>
  }

  export type UserCreateWithoutDisputesDefendedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutDisputesDefendedInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutDisputesDefendedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisputesDefendedInput, UserUncheckedCreateWithoutDisputesDefendedInput>
  }

  export type DisputeResponseCreateWithoutDisputeInput = {
    id?: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutDisputeResponsesInput
  }

  export type DisputeResponseUncheckedCreateWithoutDisputeInput = {
    id?: string
    userId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeResponseCreateOrConnectWithoutDisputeInput = {
    where: DisputeResponseWhereUniqueInput
    create: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeResponseCreateManyDisputeInputEnvelope = {
    data: DisputeResponseCreateManyDisputeInput | DisputeResponseCreateManyDisputeInput[]
    skipDuplicates?: boolean
  }

  export type DisputeEvidenceCreateWithoutDisputeInput = {
    id?: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
  }

  export type DisputeEvidenceUncheckedCreateWithoutDisputeInput = {
    id?: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
  }

  export type DisputeEvidenceCreateOrConnectWithoutDisputeInput = {
    where: DisputeEvidenceWhereUniqueInput
    create: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeEvidenceCreateManyDisputeInputEnvelope = {
    data: DisputeEvidenceCreateManyDisputeInput | DisputeEvidenceCreateManyDisputeInput[]
    skipDuplicates?: boolean
  }

  export type DisputeTimelineEventCreateWithoutDisputeInput = {
    id?: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeTimelineEventUncheckedCreateWithoutDisputeInput = {
    id?: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeTimelineEventCreateOrConnectWithoutDisputeInput = {
    where: DisputeTimelineEventWhereUniqueInput
    create: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeTimelineEventCreateManyDisputeInputEnvelope = {
    data: DisputeTimelineEventCreateManyDisputeInput | DisputeTimelineEventCreateManyDisputeInput[]
    skipDuplicates?: boolean
  }

  export type DisputeResolutionUpsertWithoutDisputeInput = {
    update: XOR<DisputeResolutionUpdateWithoutDisputeInput, DisputeResolutionUncheckedUpdateWithoutDisputeInput>
    create: XOR<DisputeResolutionCreateWithoutDisputeInput, DisputeResolutionUncheckedCreateWithoutDisputeInput>
    where?: DisputeResolutionWhereInput
  }

  export type DisputeResolutionUpdateToOneWithWhereWithoutDisputeInput = {
    where?: DisputeResolutionWhereInput
    data: XOR<DisputeResolutionUpdateWithoutDisputeInput, DisputeResolutionUncheckedUpdateWithoutDisputeInput>
  }

  export type DisputeResolutionUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResolutionUncheckedUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    outcome?: EnumResolutionOutcomeFieldUpdateOperationsInput | $Enums.ResolutionOutcome
    summary?: StringFieldUpdateOperationsInput | string
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    payoutAdjustment?: NullableFloatFieldUpdateOperationsInput | number | null
    actionsTaken?: JsonNullValueInput | InputJsonValue
    resolvedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpsertWithoutDisputesInput = {
    update: XOR<BookingUpdateWithoutDisputesInput, BookingUncheckedUpdateWithoutDisputesInput>
    create: XOR<BookingCreateWithoutDisputesInput, BookingUncheckedCreateWithoutDisputesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutDisputesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutDisputesInput, BookingUncheckedUpdateWithoutDisputesInput>
  }

  export type BookingUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutDisputesInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ConditionReportUpsertWithoutDisputeInput = {
    update: XOR<ConditionReportUpdateWithoutDisputeInput, ConditionReportUncheckedUpdateWithoutDisputeInput>
    create: XOR<ConditionReportCreateWithoutDisputeInput, ConditionReportUncheckedCreateWithoutDisputeInput>
    where?: ConditionReportWhereInput
  }

  export type ConditionReportUpdateToOneWithWhereWithoutDisputeInput = {
    where?: ConditionReportWhereInput
    data: XOR<ConditionReportUpdateWithoutDisputeInput, ConditionReportUncheckedUpdateWithoutDisputeInput>
  }

  export type ConditionReportUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUpdateManyWithoutReportNestedInput
    booking?: BookingUpdateOneRequiredWithoutConditionReportsNestedInput
    reportedByUser?: UserUpdateOneRequiredWithoutConditionReportsReportedNestedInput
  }

  export type ConditionReportUncheckedUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUncheckedUpdateManyWithoutReportNestedInput
  }

  export type UserUpsertWithoutDisputesInitiatedInput = {
    update: XOR<UserUpdateWithoutDisputesInitiatedInput, UserUncheckedUpdateWithoutDisputesInitiatedInput>
    create: XOR<UserCreateWithoutDisputesInitiatedInput, UserUncheckedCreateWithoutDisputesInitiatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisputesInitiatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisputesInitiatedInput, UserUncheckedUpdateWithoutDisputesInitiatedInput>
  }

  export type UserUpdateWithoutDisputesInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisputesInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUpsertWithoutDisputesDefendedInput = {
    update: XOR<UserUpdateWithoutDisputesDefendedInput, UserUncheckedUpdateWithoutDisputesDefendedInput>
    create: XOR<UserCreateWithoutDisputesDefendedInput, UserUncheckedCreateWithoutDisputesDefendedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisputesDefendedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisputesDefendedInput, UserUncheckedUpdateWithoutDisputesDefendedInput>
  }

  export type UserUpdateWithoutDisputesDefendedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisputesDefendedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type DisputeResponseUpsertWithWhereUniqueWithoutDisputeInput = {
    where: DisputeResponseWhereUniqueInput
    update: XOR<DisputeResponseUpdateWithoutDisputeInput, DisputeResponseUncheckedUpdateWithoutDisputeInput>
    create: XOR<DisputeResponseCreateWithoutDisputeInput, DisputeResponseUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeResponseUpdateWithWhereUniqueWithoutDisputeInput = {
    where: DisputeResponseWhereUniqueInput
    data: XOR<DisputeResponseUpdateWithoutDisputeInput, DisputeResponseUncheckedUpdateWithoutDisputeInput>
  }

  export type DisputeResponseUpdateManyWithWhereWithoutDisputeInput = {
    where: DisputeResponseScalarWhereInput
    data: XOR<DisputeResponseUpdateManyMutationInput, DisputeResponseUncheckedUpdateManyWithoutDisputeInput>
  }

  export type DisputeEvidenceUpsertWithWhereUniqueWithoutDisputeInput = {
    where: DisputeEvidenceWhereUniqueInput
    update: XOR<DisputeEvidenceUpdateWithoutDisputeInput, DisputeEvidenceUncheckedUpdateWithoutDisputeInput>
    create: XOR<DisputeEvidenceCreateWithoutDisputeInput, DisputeEvidenceUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeEvidenceUpdateWithWhereUniqueWithoutDisputeInput = {
    where: DisputeEvidenceWhereUniqueInput
    data: XOR<DisputeEvidenceUpdateWithoutDisputeInput, DisputeEvidenceUncheckedUpdateWithoutDisputeInput>
  }

  export type DisputeEvidenceUpdateManyWithWhereWithoutDisputeInput = {
    where: DisputeEvidenceScalarWhereInput
    data: XOR<DisputeEvidenceUpdateManyMutationInput, DisputeEvidenceUncheckedUpdateManyWithoutDisputeInput>
  }

  export type DisputeEvidenceScalarWhereInput = {
    AND?: DisputeEvidenceScalarWhereInput | DisputeEvidenceScalarWhereInput[]
    OR?: DisputeEvidenceScalarWhereInput[]
    NOT?: DisputeEvidenceScalarWhereInput | DisputeEvidenceScalarWhereInput[]
    id?: StringFilter<"DisputeEvidence"> | string
    disputeId?: StringFilter<"DisputeEvidence"> | string
    uploadedBy?: StringFilter<"DisputeEvidence"> | string
    type?: EnumEvidenceTypeFilter<"DisputeEvidence"> | $Enums.EvidenceType
    url?: StringFilter<"DisputeEvidence"> | string
    description?: StringNullableFilter<"DisputeEvidence"> | string | null
    metadata?: JsonFilter<"DisputeEvidence">
    uploadedAt?: DateTimeFilter<"DisputeEvidence"> | Date | string
  }

  export type DisputeTimelineEventUpsertWithWhereUniqueWithoutDisputeInput = {
    where: DisputeTimelineEventWhereUniqueInput
    update: XOR<DisputeTimelineEventUpdateWithoutDisputeInput, DisputeTimelineEventUncheckedUpdateWithoutDisputeInput>
    create: XOR<DisputeTimelineEventCreateWithoutDisputeInput, DisputeTimelineEventUncheckedCreateWithoutDisputeInput>
  }

  export type DisputeTimelineEventUpdateWithWhereUniqueWithoutDisputeInput = {
    where: DisputeTimelineEventWhereUniqueInput
    data: XOR<DisputeTimelineEventUpdateWithoutDisputeInput, DisputeTimelineEventUncheckedUpdateWithoutDisputeInput>
  }

  export type DisputeTimelineEventUpdateManyWithWhereWithoutDisputeInput = {
    where: DisputeTimelineEventScalarWhereInput
    data: XOR<DisputeTimelineEventUpdateManyMutationInput, DisputeTimelineEventUncheckedUpdateManyWithoutDisputeInput>
  }

  export type DisputeTimelineEventScalarWhereInput = {
    AND?: DisputeTimelineEventScalarWhereInput | DisputeTimelineEventScalarWhereInput[]
    OR?: DisputeTimelineEventScalarWhereInput[]
    NOT?: DisputeTimelineEventScalarWhereInput | DisputeTimelineEventScalarWhereInput[]
    id?: StringFilter<"DisputeTimelineEvent"> | string
    disputeId?: StringFilter<"DisputeTimelineEvent"> | string
    eventType?: StringFilter<"DisputeTimelineEvent"> | string
    description?: StringFilter<"DisputeTimelineEvent"> | string
    metadata?: JsonFilter<"DisputeTimelineEvent">
    createdAt?: DateTimeFilter<"DisputeTimelineEvent"> | Date | string
  }

  export type DisputeCreateWithoutResponsesInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutResponsesInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutResponsesInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutResponsesInput, DisputeUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutDisputeResponsesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutDisputeResponsesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutDisputeResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDisputeResponsesInput, UserUncheckedCreateWithoutDisputeResponsesInput>
  }

  export type DisputeUpsertWithoutResponsesInput = {
    update: XOR<DisputeUpdateWithoutResponsesInput, DisputeUncheckedUpdateWithoutResponsesInput>
    create: XOR<DisputeCreateWithoutResponsesInput, DisputeUncheckedCreateWithoutResponsesInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutResponsesInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutResponsesInput, DisputeUncheckedUpdateWithoutResponsesInput>
  }

  export type DisputeUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type UserUpsertWithoutDisputeResponsesInput = {
    update: XOR<UserUpdateWithoutDisputeResponsesInput, UserUncheckedUpdateWithoutDisputeResponsesInput>
    create: XOR<UserCreateWithoutDisputeResponsesInput, UserUncheckedCreateWithoutDisputeResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDisputeResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDisputeResponsesInput, UserUncheckedUpdateWithoutDisputeResponsesInput>
  }

  export type UserUpdateWithoutDisputeResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDisputeResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type DisputeCreateWithoutEvidenceInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutEvidenceInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutEvidenceInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutEvidenceInput, DisputeUncheckedCreateWithoutEvidenceInput>
  }

  export type DisputeUpsertWithoutEvidenceInput = {
    update: XOR<DisputeUpdateWithoutEvidenceInput, DisputeUncheckedUpdateWithoutEvidenceInput>
    create: XOR<DisputeCreateWithoutEvidenceInput, DisputeUncheckedCreateWithoutEvidenceInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutEvidenceInput, DisputeUncheckedUpdateWithoutEvidenceInput>
  }

  export type DisputeUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeCreateWithoutTimelineInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionCreateNestedOneWithoutDisputeInput
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutTimelineInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    resolution?: DisputeResolutionUncheckedCreateNestedOneWithoutDisputeInput
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutTimelineInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutTimelineInput, DisputeUncheckedCreateWithoutTimelineInput>
  }

  export type DisputeUpsertWithoutTimelineInput = {
    update: XOR<DisputeUpdateWithoutTimelineInput, DisputeUncheckedUpdateWithoutTimelineInput>
    create: XOR<DisputeCreateWithoutTimelineInput, DisputeUncheckedCreateWithoutTimelineInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutTimelineInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutTimelineInput, DisputeUncheckedUpdateWithoutTimelineInput>
  }

  export type DisputeUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutTimelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeCreateWithoutResolutionInput = {
    id?: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutDisputesInput
    conditionReport?: ConditionReportCreateNestedOneWithoutDisputeInput
    initiator: UserCreateNestedOneWithoutDisputesInitiatedInput
    defendant: UserCreateNestedOneWithoutDisputesDefendedInput
    responses?: DisputeResponseCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventCreateNestedManyWithoutDisputeInput
  }

  export type DisputeUncheckedCreateWithoutResolutionInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: DisputeResponseUncheckedCreateNestedManyWithoutDisputeInput
    evidence?: DisputeEvidenceUncheckedCreateNestedManyWithoutDisputeInput
    timeline?: DisputeTimelineEventUncheckedCreateNestedManyWithoutDisputeInput
  }

  export type DisputeCreateOrConnectWithoutResolutionInput = {
    where: DisputeWhereUniqueInput
    create: XOR<DisputeCreateWithoutResolutionInput, DisputeUncheckedCreateWithoutResolutionInput>
  }

  export type DisputeUpsertWithoutResolutionInput = {
    update: XOR<DisputeUpdateWithoutResolutionInput, DisputeUncheckedUpdateWithoutResolutionInput>
    create: XOR<DisputeCreateWithoutResolutionInput, DisputeUncheckedCreateWithoutResolutionInput>
    where?: DisputeWhereInput
  }

  export type DisputeUpdateToOneWithWhereWithoutResolutionInput = {
    where?: DisputeWhereInput
    data: XOR<DisputeUpdateWithoutResolutionInput, DisputeUncheckedUpdateWithoutResolutionInput>
  }

  export type DisputeUpdateWithoutResolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutResolutionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserCreateWithoutInsurancePoliciesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutInsurancePoliciesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutInsurancePoliciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsurancePoliciesInput, UserUncheckedCreateWithoutInsurancePoliciesInput>
  }

  export type ListingCreateWithoutInsurancePoliciesInput = {
    id?: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    owner: UserCreateNestedOneWithoutListingsInput
    organization?: OrganizationCreateNestedOneWithoutListingsInput
    category: CategoryCreateNestedOneWithoutListingsInput
    cancellationPolicy?: CancellationPolicyCreateNestedOneWithoutListingsInput
    availability?: AvailabilityCreateNestedManyWithoutListingInput
    bookings?: BookingCreateNestedManyWithoutListingInput
    reviews?: ReviewCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutInsurancePoliciesInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    availability?: AvailabilityUncheckedCreateNestedManyWithoutListingInput
    bookings?: BookingUncheckedCreateNestedManyWithoutListingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutListingInput
    favorites?: FavoriteListingUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutInsurancePoliciesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutInsurancePoliciesInput, ListingUncheckedCreateWithoutInsurancePoliciesInput>
  }

  export type UserUpsertWithoutInsurancePoliciesInput = {
    update: XOR<UserUpdateWithoutInsurancePoliciesInput, UserUncheckedUpdateWithoutInsurancePoliciesInput>
    create: XOR<UserCreateWithoutInsurancePoliciesInput, UserUncheckedCreateWithoutInsurancePoliciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsurancePoliciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsurancePoliciesInput, UserUncheckedUpdateWithoutInsurancePoliciesInput>
  }

  export type UserUpdateWithoutInsurancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsurancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type ListingUpsertWithoutInsurancePoliciesInput = {
    update: XOR<ListingUpdateWithoutInsurancePoliciesInput, ListingUncheckedUpdateWithoutInsurancePoliciesInput>
    create: XOR<ListingCreateWithoutInsurancePoliciesInput, ListingUncheckedCreateWithoutInsurancePoliciesInput>
    where?: ListingWhereInput
  }

  export type ListingUpdateToOneWithWhereWithoutInsurancePoliciesInput = {
    where?: ListingWhereInput
    data: XOR<ListingUpdateWithoutInsurancePoliciesInput, ListingUncheckedUpdateWithoutInsurancePoliciesInput>
  }

  export type ListingUpdateWithoutInsurancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutInsurancePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserCreateWithoutDeviceTokensInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    userPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutDeviceTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
  }

  export type UserUpsertWithoutDeviceTokensInput = {
    update: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<UserCreateWithoutDeviceTokensInput, UserUncheckedCreateWithoutDeviceTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeviceTokensInput, UserUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    userPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserCreateWithoutUserPreferencesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    listings?: ListingCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutUserInput
    conditionReportsReported?: ConditionReportCreateNestedManyWithoutReportedByUserInput
  }

  export type UserUncheckedCreateWithoutUserPreferencesInput = {
    id?: string
    email: string
    emailVerified?: boolean
    emailVerificationToken?: string | null
    passwordHash: string
    firstName: string
    lastName: string
    phoneNumber?: string | null
    phone?: string | null
    phoneVerified?: boolean
    dateOfBirth?: Date | string | null
    profilePhotoUrl?: string | null
    bio?: string | null
    addressLine1?: string | null
    addressLine2?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    idVerificationStatus?: $Enums.VerificationStatus
    idVerificationUrl?: string | null
    governmentIdUrl?: string | null
    governmentIdType?: $Enums.GovernmentIdType | null
    governmentIdNumber?: string | null
    stripeCustomerId?: string | null
    stripeConnectId?: string | null
    stripeOnboardingComplete?: boolean
    stripeChargesEnabled?: boolean
    stripePayoutsEnabled?: boolean
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    preferredLanguage?: string
    preferredCurrency?: string
    timezone?: string
    mfaEnabled?: boolean
    mfaSecret?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    lastLoginIp?: string | null
    averageRating?: number
    totalReviews?: number
    responseRate?: number
    responseTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    listings?: ListingUncheckedCreateNestedManyWithoutOwnerInput
    bookingsAsRenter?: BookingUncheckedCreateNestedManyWithoutRenterInput
    bookingsAsOwner?: BookingUncheckedCreateNestedManyWithoutOwnerInput
    reviewsGiven?: ReviewUncheckedCreateNestedManyWithoutReviewerInput
    reviewsReceived?: ReviewUncheckedCreateNestedManyWithoutRevieweeInput
    conversationParticipants?: ConversationParticipantUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    disputesInitiated?: DisputeUncheckedCreateNestedManyWithoutInitiatorInput
    disputesDefended?: DisputeUncheckedCreateNestedManyWithoutDefendantInput
    disputeResponses?: DisputeResponseUncheckedCreateNestedManyWithoutUserInput
    organizations?: OrganizationMemberUncheckedCreateNestedManyWithoutUserInput
    favoriteListings?: FavoriteListingUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    insurancePolicies?: InsurancePolicyUncheckedCreateNestedManyWithoutUserInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutUserInput
    conditionReportsReported?: ConditionReportUncheckedCreateNestedManyWithoutReportedByUserInput
  }

  export type UserCreateOrConnectWithoutUserPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
  }

  export type UserUpsertWithoutUserPreferencesInput = {
    update: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
    create: XOR<UserCreateWithoutUserPreferencesInput, UserUncheckedCreateWithoutUserPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPreferencesInput, UserUncheckedUpdateWithoutUserPreferencesInput>
  }

  export type UserUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    listings?: ListingUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUpdateManyWithoutReportedByUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    idVerificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    idVerificationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdUrl?: NullableStringFieldUpdateOperationsInput | string | null
    governmentIdType?: NullableEnumGovernmentIdTypeFieldUpdateOperationsInput | $Enums.GovernmentIdType | null
    governmentIdNumber?: NullableStringFieldUpdateOperationsInput | string | null
    stripeCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeConnectId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeOnboardingComplete?: BoolFieldUpdateOperationsInput | boolean
    stripeChargesEnabled?: BoolFieldUpdateOperationsInput | boolean
    stripePayoutsEnabled?: BoolFieldUpdateOperationsInput | boolean
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    preferredLanguage?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginIp?: NullableStringFieldUpdateOperationsInput | string | null
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    responseRate?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    listings?: ListingUncheckedUpdateManyWithoutOwnerNestedInput
    bookingsAsRenter?: BookingUncheckedUpdateManyWithoutRenterNestedInput
    bookingsAsOwner?: BookingUncheckedUpdateManyWithoutOwnerNestedInput
    reviewsGiven?: ReviewUncheckedUpdateManyWithoutReviewerNestedInput
    reviewsReceived?: ReviewUncheckedUpdateManyWithoutRevieweeNestedInput
    conversationParticipants?: ConversationParticipantUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    disputesInitiated?: DisputeUncheckedUpdateManyWithoutInitiatorNestedInput
    disputesDefended?: DisputeUncheckedUpdateManyWithoutDefendantNestedInput
    disputeResponses?: DisputeResponseUncheckedUpdateManyWithoutUserNestedInput
    organizations?: OrganizationMemberUncheckedUpdateManyWithoutUserNestedInput
    favoriteListings?: FavoriteListingUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutUserNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutUserNestedInput
    conditionReportsReported?: ConditionReportUncheckedUpdateManyWithoutReportedByUserNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    refreshToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type ListingCreateManyOwnerInput = {
    id?: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type BookingCreateManyRenterInput = {
    id?: string
    listingId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BookingCreateManyOwnerInput = {
    id?: string
    listingId: string
    renterId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ReviewCreateManyReviewerInput = {
    id?: string
    bookingId: string
    listingId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyRevieweeInput = {
    id?: string
    bookingId: string
    listingId: string
    reviewerId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationParticipantCreateManyUserInput = {
    id?: string
    conversationId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DisputeCreateManyInitiatorInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateManyDefendantInput = {
    id?: string
    bookingId: string
    conditionReportId?: string | null
    initiatorId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeResponseCreateManyUserInput = {
    id?: string
    disputeId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrganizationMemberCreateManyUserInput = {
    id?: string
    organizationId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type FavoriteListingCreateManyUserInput = {
    id?: string
    listingId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: string | null
    relatedType?: string | null
    actionUrl?: string | null
    actionLabel?: string | null
    read?: boolean
    readAt?: Date | string | null
    status?: string | null
    sentViaEmail?: boolean
    sentViaPush?: boolean
    createdAt?: Date | string
  }

  export type InsurancePolicyCreateManyUserInput = {
    id?: string
    listingId?: string | null
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateManyUserInput = {
    id?: string
    token: string
    platform: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConditionReportCreateManyReportedByUserInput = {
    id?: string
    bookingId: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpdateWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRenterInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    listing?: ListingUpdateOneRequiredWithoutReviewsNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    listing?: ListingUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutRevieweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateManyWithoutInitiatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    booking?: BookingUpdateOneRequiredWithoutDisputesNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateManyWithoutDefendantInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dispute?: DisputeUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type DisputeResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    disputeId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutMembersNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteListingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedType?: NullableStringFieldUpdateOperationsInput | string | null
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    actionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    sentViaEmail?: BoolFieldUpdateOperationsInput | boolean
    sentViaPush?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneWithoutInsurancePoliciesNestedInput
  }

  export type InsurancePolicyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionReportUpdateWithoutReportedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUpdateManyWithoutReportNestedInput
    booking?: BookingUpdateOneRequiredWithoutConditionReportsNestedInput
    dispute?: DisputeUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateWithoutReportedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUncheckedUpdateManyWithoutReportNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateManyWithoutReportedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationMemberCreateManyOrganizationInput = {
    id?: string
    userId: string
    role?: $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: string | null
    joinedAt?: Date | string
  }

  export type ListingCreateManyOrganizationInput = {
    id?: string
    ownerId: string
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type OrganizationMemberUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutOrganizationsNestedInput
  }

  export type OrganizationMemberUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationMemberUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumOrgRoleFieldUpdateOperationsInput | $Enums.OrgRole
    permissions?: JsonNullValueInput | InputJsonValue
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ListingCreateManyCategoryInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ListingUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    cancellationPolicy?: CancellationPolicyUpdateOneWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    cancellationPolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AvailabilityCreateManyListingInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
  }

  export type BookingCreateManyListingInput = {
    id?: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositHoldId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type ReviewCreateManyListingInput = {
    id?: string
    bookingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FavoriteListingCreateManyListingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type InsurancePolicyCreateManyListingInput = {
    id?: string
    userId: string
    policyNumber: string
    provider: string
    type: string
    coverageAmount: number
    effectiveDate: Date | string
    expirationDate: Date | string
    documentUrl: string
    certificateUrl?: string | null
    status?: $Enums.InsuranceStatus
    verificationDate?: Date | string | null
    verifiedBy?: string | null
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AvailabilityUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AvailabilityUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    depositHold?: DepositHoldUpdateOneWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositHoldId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoriteListingsNestedInput
  }

  export type FavoriteListingUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteListingUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsurancePoliciesNestedInput
  }

  export type InsurancePolicyUncheckedUpdateWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsurancePolicyUncheckedUpdateManyWithoutListingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    coverageAmount?: IntFieldUpdateOperationsInput | number
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documentUrl?: StringFieldUpdateOperationsInput | string
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsuranceStatusFieldUpdateOperationsInput | $Enums.InsuranceStatus
    verificationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ListingCreateManyCancellationPolicyInput = {
    id?: string
    ownerId: string
    organizationId?: string | null
    categoryId: string
    title: string
    description: string
    slug: string
    addressLine1?: string | null
    addressLine2?: string | null
    city: string
    state: string
    postalCode?: string | null
    country: string
    latitude: number
    longitude: number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: $Enums.PricingMode
    basePrice: number
    hourlyPrice?: number | null
    dailyPrice?: number | null
    weeklyPrice?: number | null
    monthlyPrice?: number | null
    currency?: string
    requiresDeposit?: boolean
    depositAmount?: number | null
    depositType?: $Enums.DepositType | null
    bookingMode?: $Enums.BookingMode
    minBookingHours?: number | null
    maxBookingDays?: number | null
    leadTime?: number
    advanceNotice?: number
    capacity?: number | null
    categorySpecificData: JsonNullValueInput | InputJsonValue
    condition?: $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: string | null
    insuranceVerified?: boolean
    insuranceVerifiedAt?: Date | string | null
    insuranceExpiresAt?: Date | string | null
    status?: $Enums.ListingStatus
    verificationStatus?: $Enums.VerificationStatus
    rejectionReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    viewCount?: number
    bookingCount?: number
    favoriteCount?: number
    averageRating?: number
    totalReviews?: number
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ListingUpdateWithoutCancellationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutListingsNestedInput
    organization?: OrganizationUpdateOneWithoutListingsNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    availability?: AvailabilityUpdateManyWithoutListingNestedInput
    bookings?: BookingUpdateManyWithoutListingNestedInput
    reviews?: ReviewUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutCancellationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    availability?: AvailabilityUncheckedUpdateManyWithoutListingNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutListingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutListingNestedInput
    favorites?: FavoriteListingUncheckedUpdateManyWithoutListingNestedInput
    insurancePolicies?: InsurancePolicyUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutCancellationPolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    addressLine1?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    photos?: JsonNullValueInput | InputJsonValue
    videos?: JsonNullValueInput | InputJsonValue
    documents?: JsonNullValueInput | InputJsonValue
    pricingMode?: EnumPricingModeFieldUpdateOperationsInput | $Enums.PricingMode
    basePrice?: FloatFieldUpdateOperationsInput | number
    hourlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    dailyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    weeklyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    requiresDeposit?: BoolFieldUpdateOperationsInput | boolean
    depositAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    depositType?: NullableEnumDepositTypeFieldUpdateOperationsInput | $Enums.DepositType | null
    bookingMode?: EnumBookingModeFieldUpdateOperationsInput | $Enums.BookingMode
    minBookingHours?: NullableIntFieldUpdateOperationsInput | number | null
    maxBookingDays?: NullableIntFieldUpdateOperationsInput | number | null
    leadTime?: IntFieldUpdateOperationsInput | number
    advanceNotice?: IntFieldUpdateOperationsInput | number
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    categorySpecificData?: JsonNullValueInput | InputJsonValue
    condition?: NullableEnumListingConditionFieldUpdateOperationsInput | $Enums.ListingCondition | null
    features?: JsonNullValueInput | InputJsonValue
    amenities?: JsonNullValueInput | InputJsonValue
    rules?: JsonNullValueInput | InputJsonValue
    insurancePolicyId?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceVerified?: BoolFieldUpdateOperationsInput | boolean
    insuranceVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    insuranceExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    verificationStatus?: EnumVerificationStatusFieldUpdateOperationsInput | $Enums.VerificationStatus
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    bookingCount?: IntFieldUpdateOperationsInput | number
    favoriteCount?: IntFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalReviews?: IntFieldUpdateOperationsInput | number
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingStateHistoryCreateManyBookingInput = {
    id?: string
    fromState?: $Enums.BookingStatus | null
    toState: $Enums.BookingStatus
    reason?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: string | null
    createdAt?: Date | string
  }

  export type LedgerEntryCreateManyBookingInput = {
    id?: string
    accountType: string
    side: $Enums.LedgerSide
    amount: number
    currency?: string
    transactionType: string
    description: string
    referenceId?: string | null
    status?: $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    settledAt?: Date | string | null
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    amount: number
    currency?: string
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    status?: $Enums.PaymentStatus
    failureReason?: string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConditionReportCreateManyBookingInput = {
    id?: string
    reportType: $Enums.ReportType
    type: $Enums.ReportType
    reportedBy: string
    reportedAt?: Date | string
    checklistData: JsonNullValueInput | InputJsonValue
    overallCondition?: string | null
    condition?: string | null
    notes?: string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: boolean
    damageAmount?: number | null
    acknowledgedBy?: string | null
    acknowledgedAt?: Date | string | null
    disputeRaised?: boolean
    status?: $Enums.ReportStatus
    createdAt?: Date | string
    completedAt?: Date | string | null
  }

  export type ReviewCreateManyBookingInput = {
    id?: string
    listingId: string
    reviewerId: string
    revieweeId: string
    type: $Enums.ReviewType
    overallRating: number
    accuracyRating?: number | null
    communicationRating?: number | null
    cleanlinessRating?: number | null
    valueRating?: number | null
    title?: string | null
    content: string
    response?: string | null
    respondedAt?: Date | string | null
    status?: $Enums.ReviewStatus
    flagged?: boolean
    flagReason?: string | null
    moderatedBy?: string | null
    moderatedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisputeCreateManyBookingInput = {
    id?: string
    conditionReportId?: string | null
    initiatorId: string
    defendantId: string
    type: $Enums.DisputeType
    title: string
    description: string
    amount?: number | null
    currency?: string
    status?: $Enums.DisputeStatus
    priority?: $Enums.DisputePriority
    slaDeadline?: Date | string | null
    respondedAt?: Date | string | null
    resolvedAt?: Date | string | null
    assignedTo?: string | null
    assignedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyBookingInput = {
    id?: string
    listingId?: string | null
    type?: $Enums.ConversationType
    subject?: string | null
    lastMessageAt?: Date | string | null
    lastMessagePreview?: string | null
    status?: $Enums.ConversationStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingStateHistoryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStateHistoryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingStateHistoryUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromState?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    toState?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    changedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LedgerEntryUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LedgerEntryUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: StringFieldUpdateOperationsInput | string
    side?: EnumLedgerSideFieldUpdateOperationsInput | $Enums.LedgerSide
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    transactionType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    referenceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLedgerEntryStatusFieldUpdateOperationsInput | $Enums.LedgerEntryStatus
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConditionReportUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUpdateManyWithoutReportNestedInput
    reportedByUser?: UserUpdateOneRequiredWithoutConditionReportsReportedNestedInput
    dispute?: DisputeUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    photos?: ReportPhotoUncheckedUpdateManyWithoutReportNestedInput
    dispute?: DisputeUncheckedUpdateOneWithoutConditionReportNestedInput
  }

  export type ConditionReportUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    reportedBy?: StringFieldUpdateOperationsInput | string
    reportedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistData?: JsonNullValueInput | InputJsonValue
    overallCondition?: NullableStringFieldUpdateOperationsInput | string | null
    condition?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    damages?: NullableJsonNullValueInput | InputJsonValue
    issuesFound?: BoolFieldUpdateOperationsInput | boolean
    damageAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    acknowledgedBy?: NullableStringFieldUpdateOperationsInput | string | null
    acknowledgedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    disputeRaised?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutReviewsNestedInput
    reviewer?: UserUpdateOneRequiredWithoutReviewsGivenNestedInput
    reviewee?: UserUpdateOneRequiredWithoutReviewsReceivedNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    reviewerId?: StringFieldUpdateOperationsInput | string
    revieweeId?: StringFieldUpdateOperationsInput | string
    type?: EnumReviewTypeFieldUpdateOperationsInput | $Enums.ReviewType
    overallRating?: FloatFieldUpdateOperationsInput | number
    accuracyRating?: NullableFloatFieldUpdateOperationsInput | number | null
    communicationRating?: NullableFloatFieldUpdateOperationsInput | number | null
    cleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    valueRating?: NullableFloatFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    response?: NullableStringFieldUpdateOperationsInput | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumReviewStatusFieldUpdateOperationsInput | $Enums.ReviewStatus
    flagged?: BoolFieldUpdateOperationsInput | boolean
    flagReason?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    moderatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUpdateOneWithoutDisputeNestedInput
    conditionReport?: ConditionReportUpdateOneWithoutDisputeNestedInput
    initiator?: UserUpdateOneRequiredWithoutDisputesInitiatedNestedInput
    defendant?: UserUpdateOneRequiredWithoutDisputesDefendedNestedInput
    responses?: DisputeResponseUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolution?: DisputeResolutionUncheckedUpdateOneWithoutDisputeNestedInput
    responses?: DisputeResponseUncheckedUpdateManyWithoutDisputeNestedInput
    evidence?: DisputeEvidenceUncheckedUpdateManyWithoutDisputeNestedInput
    timeline?: DisputeTimelineEventUncheckedUpdateManyWithoutDisputeNestedInput
  }

  export type DisputeUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    conditionReportId?: NullableStringFieldUpdateOperationsInput | string | null
    initiatorId?: StringFieldUpdateOperationsInput | string
    defendantId?: StringFieldUpdateOperationsInput | string
    type?: EnumDisputeTypeFieldUpdateOperationsInput | $Enums.DisputeType
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumDisputeStatusFieldUpdateOperationsInput | $Enums.DisputeStatus
    priority?: EnumDisputePriorityFieldUpdateOperationsInput | $Enums.DisputePriority
    slaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumConversationTypeFieldUpdateOperationsInput | $Enums.ConversationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastMessagePreview?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumConversationStatusFieldUpdateOperationsInput | $Enums.ConversationStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyDepositHoldInput = {
    id?: string
    listingId: string
    renterId: string
    ownerId: string
    startDate: Date | string
    endDate: Date | string
    duration: number
    guestCount?: number
    basePrice: number
    serviceFee: number
    tax: number
    depositAmount?: number
    discountAmount?: number
    totalPrice: number
    totalAmount: number
    ownerEarnings: number
    platformFee: number
    currency?: string
    renterMessage?: string | null
    status?: $Enums.BookingStatus
    cancellationReason?: string | null
    cancelledBy?: string | null
    cancelledAt?: Date | string | null
    paymentIntentId?: string | null
    depositReleased?: boolean
    depositReleasedAt?: Date | string | null
    checkInTime?: Date | string | null
    checkOutTime?: Date | string | null
    actualReturnTime?: Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: string | null
    ownerNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    confirmedAt?: Date | string | null
    completedAt?: Date | string | null
  }

  export type BookingUpdateWithoutDepositHoldInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    listing?: ListingUpdateOneRequiredWithoutBookingsNestedInput
    renter?: UserUpdateOneRequiredWithoutBookingsAsRenterNestedInput
    owner?: UserUpdateOneRequiredWithoutBookingsAsOwnerNestedInput
    stateHistory?: BookingStateHistoryUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUpdateManyWithoutBookingNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutDepositHoldInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stateHistory?: BookingStateHistoryUncheckedUpdateManyWithoutBookingNestedInput
    ledgerEntries?: LedgerEntryUncheckedUpdateManyWithoutBookingNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    conditionReports?: ConditionReportUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    disputes?: DisputeUncheckedUpdateManyWithoutBookingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutDepositHoldInput = {
    id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    renterId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    guestCount?: IntFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    serviceFee?: FloatFieldUpdateOperationsInput | number
    tax?: FloatFieldUpdateOperationsInput | number
    depositAmount?: FloatFieldUpdateOperationsInput | number
    discountAmount?: FloatFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    ownerEarnings?: FloatFieldUpdateOperationsInput | number
    platformFee?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    renterMessage?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledBy?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    depositReleased?: BoolFieldUpdateOperationsInput | boolean
    depositReleasedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actualReturnTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categoryData?: JsonNullValueInput | InputJsonValue
    renterNotes?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    confirmedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ConversationParticipantCreateManyConversationInput = {
    id?: string
    userId: string
    muted?: boolean
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    type?: $Enums.MessageType
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: $Enums.MessageStatus
    createdAt?: Date | string
    editedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    muted?: BoolFieldUpdateOperationsInput | boolean
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
    readReceipts?: MessageReadReceiptUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readReceipts?: MessageReadReceiptUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumMessageStatusFieldUpdateOperationsInput | $Enums.MessageStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    editedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageReadReceiptCreateManyMessageInput = {
    id?: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadReceiptUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadReceiptUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPhotoCreateManyReportInput = {
    id?: string
    url: string
    thumbnailUrl?: string | null
    caption?: string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: number
    uploadedAt?: Date | string
  }

  export type ReportPhotoUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPhotoUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportPhotoUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: JsonNullValueInput | InputJsonValue
    metadata?: JsonNullValueInput | InputJsonValue
    order?: IntFieldUpdateOperationsInput | number
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseCreateManyDisputeInput = {
    id?: string
    userId: string
    content: string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeEvidenceCreateManyDisputeInput = {
    id?: string
    uploadedBy: string
    type: $Enums.EvidenceType
    url: string
    description?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: Date | string
  }

  export type DisputeTimelineEventCreateManyDisputeInput = {
    id?: string
    eventType: string
    description: string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type DisputeResponseUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDisputeResponsesNestedInput
  }

  export type DisputeResponseUncheckedUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeResponseUncheckedUpdateManyWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    attachments?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceUncheckedUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeEvidenceUncheckedUpdateManyWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventUncheckedUpdateWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisputeTimelineEventUncheckedUpdateManyWithoutDisputeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}